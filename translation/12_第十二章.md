**C H A P T E R T W E L V E**

Pointers and Memory Management

SUMMING UP

> Up until now, the memory needed to store all objects has been
> allocated behind the scenes. We access that memory with variables
> names or sending messages.

COMING UP

> Th is chapter introduces the notion of *indirection*. Indirection
> occurs when there is a substitute for something. Consider a library
> catalog card that holds the Dewey decimal number of a book. Th e card
> itself is not the book. Rather, the card is a reference to the book.
> Because the card names the location of the book, in a sense, the card
> contains an “address.” C++ has its own method for implementing
> indirection through *pointers*—variables that store addresses of, or
> pointers to, other variables. Th is chapter also introduces the
> primitive C array and memory management. After studying this chapter,
> you will be able to

-   understand that pointer objects store addresses of other objects

-   use primitive C++ arrays with no range checking

-   use several methods for initializing pointers

-   use the new and delete operators for memory management

12.1 MEMORY CONSIDERATIONS

> Every object has a name, state, and set of available operations.
> Objects also have *scope*—where they are known—and *lifetime*—the
> length of time from when they are constructed to when they go out of
> existence. From initializations such as
>
> int able = 123; int baker = 987;
>
> most of these characteristics of the objects can be ascertained.
> However, the location of the object in memory—its address—is not so
> obvious. Until now, we have relied on the system to manage addresses.
> C++ allows programmers to manipulate those addresses directly.
>
> Each object resides in a specifi c memory location, which is one or
> more bytes of computer memory. Each object is located by using the
> address of the fi rst byte in the object memory loca-
>
> 343
>
> tion. For example, here is a machine-level view of values showing able
> stored at address 6300 and baker at address 6304. Th ese addresses are
> arbitrary and could be stored at any other address. Also with C++,
> ints are usually, but are not required to be, stored in four bytes of
> memory.

  **Address **   **Type **   **Name **   **State**
  -------------- ----------- ----------- -----------
  6300           int         > able      > 123
  > 6304         int         > baker     > 987

> Th e object named able is shown to reside in the bytes 6300, 6301,
> 6302, and 6303. Th e address of able is the fi rst of those four bytes
> of memory, or 6300. Although we do not always need to know the exact
> addresses of objects, the concept of objects that store addresses
> eventually becomes important in the study of computing fundamentals
> with C++.
>
> Th e memory allocated for many objects is determined at compile time.
> A char object might require one byte of memory, an int usually
> requires either two or four depending on the computer system, and a
> double object requires a specifi c and predictable (at least by
> machine) number of bytes. Th ese types are said to be *static* because
> the memory is allocated at compile time. Th e amount of memory
> allocated for a static variable is fi xed and will not change while
> the program is running.
>
> Pointer objects allow programmers to write code that allows for
> runtime allocation of memory. Th e space is made available while the
> program is running. Th ese runtime-allocated objects are *dynamic*
> because they consume chunks of memory at runtime. Th e major benefi t
> is this: memory is allocated on an as-needed basis. Th e memory can
> also be deallocated, or returned, to the system when no longer needed
> so it can be used later.
>
> Dynamic objects manage collections that may shrink and grow in size,
> where the size is limited only by available memory. Programmers can
> more eff ectively control computer resources. For example, string
> objects employ behind-the-scenes dynamic memory allocation that
> permits a runtime sizing of string objects. Th is implementation of
> the string class was chosen because there is no way to predict how
> many characters will be entered by the user at runtime:
>
> string name; // Memory allocated during input cout << "Enter
> your name: "; cin >> name;
>
> Th e string class also allows programmers to assign varying-length
> strings:
>
> string a, b; // Appropriate memory is allocated on assignment
>
> a = "The string a should have its own space"; // 38 chars b = "The
> string b should also"; // 24 chars
>
> An alternative would be to allocate a vector of chars of arbitrary
> size for every string object during the call to the constructor. But
> what size should we use? We could pick a size large enough to
> accommodate most strings, but this would waste large amounts of
> memory. Imagine a vector of 1,000 strings in which each string is
> allocated 128 or 200 bytes of memory, even if the average length of
> the strings ends up to be only 9 characters. Without pointers, the
> programmer might be forced into this alternative of wasted computer
> memory. To understand memory management, pointers must be understood.

12.1.1 POINTERS

> *Pointers* store the addresses of other objects—they point *to* other
> objects. A pointer object is declared with an asterisk (\*) after the
> class name.

**General Form 12.1** *Declaring pointer variables*

> *class-name*\* *identi er*;
>
> Th e asterisk indicates that *identi er* can store the address of an
> object of type *class-name*. For example, in the declaration int\*
> intPtr;
>
> the pointer object named intPtr may store the address of one int
> object. Th e object named intPtr does not represent an int—it
> represents the address of an int. A pointer object may have one of
> these states:

1.  It may be undefi ned (garbage, as intPtr currently is).

2.  It may contain the special pointer value nullptr, signifying the
    > pointer points to nothing.

3.  It may point to an instance of the class it was declared to
    > point to.

> Currently any attempt to use the undefi ned value of intPtr will
> result in undefi ned system behavior. One way to set the state of
> intPtr is to assign it the special pointer constant nullptr that means
> the pointer does not point to anything.
>
> intPtr = nullptr; // intPtr points to nothing
>
> Because pointer objects store addresses, their values become more
> meaningful when visibly written in a box with an arrow pointing to the
> object. So these statements
>
> int anInt = 123; // Allocate memory for an int and initialize it int\*
> p; // Allocate memory to store the address of an int object
>
> can be graphically represented as follows:

anInt p

> Th e ? signifi es a pointer object that has not yet been assigned a
> value. Th e ? is a garbage value. To indicate the pointer is pointing
> to nothing, we use the C++ keyword nullptr:
>
> p = nullptr;
>
> When nullptr is assigned to the pointer p, the state of p could be
> pictured with a symbol such as the diagonal line show here:
>
> p
>
> Pointer objects may be assigned values through the *address of*
> operator &. Th e & operator returns the address of the object that
> follows it.

**General Form 12.2** *Obtaining the address of an object*

> &*object-name*;
>
> For example, the expression &anInt evaluates to the address of anInt.
> Th e following statement stores the address of anInt in the pointer
> object p (the expression &anInt is read as “address of anInt”):
>
> p = &anInt; // &anInt returns memory location (address) of anInt
>
> Th is assignment is best presented pictorially by moving the arrow
> from ? to the memory that holds the address of anInt:

p 123 anInt

> Th e arrow from p to anInt indicates that p is now pointing to the
> object anInt; however, the actual value stored in p is an address—the
> memory location of anInt.
>
> Th e state of the object pointed to by a pointer object can be altered
> indirectly. For example, the state of anInt can be changed without
> even using the object name. Th is *indirect addressing* with the
> dereference, or indirection, operator \* allows the program to inspect
> or change the memory pointed to by the pointer object. Here is an
> example of how the memory for the anInt pointed to by p may be
> altered:
>
> = 456; // Indirect addressing stores 456 in anInt

**General Form 12.3** *Indirect addressing*

> \**pointer-object*;
>
> Th e assignment to \*p does not change p. Instead, it changes the
> state of the object pointed to by p.
>
> Note that the \* has two diff erent meanings for a pointer. First,
> when you declare a pointer, the asterisk means you are declaring a
> pointer, for example:
>
> int\* pInteger; double\* pDouble;
>
> Second, when you use the asterisk with an existing pointer, it means
> you are dereferencing the pointer:
>
> \*pInteger = 456;
>
> \*pDoube = 123.45;
>
> In math, \* signifi es multiplication. As you can see, the asterisk is
> truly an overloaded operator. Pay close attention to how it is used in
> your code to determine the meaning of the asterisk. Th e asterisk that
> precedes a pointer object tells the pointer to go to the address that
> the pointer is storing and change the value at that address. So for
> example, if anInt were stored at address 6308, 6308 is stored in p:
>
> p 6308 456 anInt \*p
>
> To illustrate the diff erences between p, \*p, and &anInt, consider
> the indirect addressing method used in the following program that
> interchanges the value of two pointers. By the end of the program, the
> two pointer objects p1 and p2 point to each other’s original int
> object. Note that since the pointers are pointing to double values,
> the pointers must be declared as double pointers. Th is tells the
> compiler to go to the address stored in the double pointer and read
> enough bytes for a double object (usually 8 bytes).
>
> // Interchange two pointer values. The pointers are switched // to
> point to the other's original int object.
>
> \#include <iostream> using namespace std;
>
> int main() { double\* p1; double\* p2; double\* temp; double n1 =
> 99.9; double n2 = 88.8;
>
> // Let p1 point to n1 and p2 point to n2 p1 = &n1; p2 = &n2;
>
> cout << "\*p1 and \*p2 before switch" << endl;
>
> // Get the integers indirectly with the \* operator
>
> cout << (\*p1) << " " << (\*p2) << endl;
>
> // Swap the pointers by letting p1 point to where p2 is pointing.
>
> // Also let p2 point to where p1 is pointing.
>
> temp = p1; p1 = p2; p2 = temp;
>
> // Now the values of the pointers are switched to point to each
>
> // other's int object. The ints themselves do not move.
>
> cout << "\*p1 and \*p2 after switch" << endl; cout
> << (\*p1) << " " << (\*p2) << endl <<
> endl;
>
> cout << "Actual memory locations in hexadecimal:" << endl;
> cout << p1 << " " << p2 << endl;
>
> return 0; }
>
> Output
>
> \*p1 and \*p2 before switch
>
> 99.9 88.8 \*p1 and \*p2 after switch
>
> 88.8 99.9
>
> Actual memory locations in hexadecimal:
>
> 0x7fff5d00cbf0 0x7fff5d00cbf8
>
> Th e values 99.9 and 88.8 were not moved in memory. Instead, the
> pointers to these double objects were interchanged. Th e following
> graphic representation traces this program execution. First, all fi ve
> objects are initialized as follows. *Note:* All boxes represent memory
> storing the state of an object.
>
> n1n2

p1p2temp

> Th e next two statements (p1 = &n1; and p2 = &n2;) store the addresses
> of the doubles in the pointers. Th e statement temp = p1; means that
> the pointer object temp is set to point to the same memory location as
> p1.
>
> // Both temp and p1 are pointers to an integer
>
> Th e address (shown as arrows) of p1 was stored in temp. At this point
> the expression temp == p1 would be true. Th is change is indicated by
> the fact that arrows from both p1 and temp point to the same
> location—the object named n1.
>
> Next, the assignment p1 = p2; causes p1 to point to the same place as
> p2. So p1 and p2 now store the same address. Th e two pointer values
> are equal.
>
> And fi nally, p2 = temp; causes p2 to point to the same double to
> which p1 was originally pointing.
>
> Now that p2 points to n1 and p1 points to n2, cout << (\*p1)
> displays 88.8 rather than the original 99.9.
>
> At fi rst, working with pointers is not easy. It takes a shift from
> understanding objects that store values to understanding objects that
> store addresses of other objects that store values. Algorithm design
> and debugging are diff erent when using pointers. One low-cost tool
> that helps during debugging is the use of arrows to represent pointer
> values. Algorithms are traced by moving the arrow rather than writing
> the address.
>
> Also when writing debugging code, the value being pointed to is
> usually more telling than the address of where that object is located.
> So debug with \* as in cout << (\*aPointer); rather than cout
> << aPointer;. With this, you see the more useful values of the
> objects, not their addresses.

12.1.2 POINTERS TO OBJECTS

> Pointers to ints and doubles refer to one single value stored in those
> locations. Th ere are no associated member functions. Now consider
> what happens with a pointer to an object during a message. Because the
> dereference operator has a lower priority than a function call, this
> code will not work:
>
> BankAccount anAcct("Functions > Dereference", 123.45);
>
> BankAccount\* bp; bp = &anAcct; \*bp.deposit(123.45); // ERROR
>
> One way to fi x this is to override the priority scheme by wrapping
> the pointer dereference in parentheses. Now \*bp returns the
> BankAccount object *before* the deposit function gets called:
>
> (\*bp).deposit(123.45); // OKAY
>
> Or you could use the C++ arrow operator -> as a shortcut to denote
> that the pointer is pointing to an instance of a true class:
>
> bp->deposit(123.45); // SHORTCUT

Both techniques are used in the following program:

> \#include <iostream> using namespace std; \#include
> "BankAccount.h"
>
> int main() {
>
> BankAccount anAcct("both (\*bp) and bp-> work ", 100.00);
>
> BankAccount\* bp; bp = &anAcct;
>
> // Wrap the dereference in parentheses because the dereference
>
> // operator \* has lower precedence than function calls
>
> (\*bp).deposit(123.45);
>
> cout << (\*bp).getName() << (\*bp).getBalance() <<
> endl;
>
> // Use -> for pointers to objects other than int or double
> bp->withdraw(111.11);
>
> cout << bp->getName() << bp->getBalance() <<
> endl;
>
> return 0; }
>
> Output
>
> both (\*bp) and bp-> work 223.45 both (\*bp) and bp-> work
> 112.34

SELF-CHECK

12-1 What do pointer objects store?

12-2 Use these statements to answer the questions below:

> double\* doublePtr; double aDouble = 1.23; doublePtr = &aDouble;

a.  What is the name of the pointer object?

b.  What is the value of doublePtr?

c.  What is the value of \*doublePtr?

d.  Write code to *indirectly* change the value of aDouble from 1.23
    > to 2.23.

    3.  What is the value of \*ptr after this code runs:

> int anInt = 123; int\* ptr = &anInt; \*ptr += \*ptr;

3.  What is the value of s3 after this code runs:

> string s1 = string("one"); string\* p1 = &s1; string s3 =
> p1->c\_str(); s3 += p1->c\_str(); cout << s3;

3.  Write an expression that evaluates to the sum of the two BankAccount
    > balances indirectly.

> BankAccount ba1("one", 100.00);
>
> BankAccount ba2("two", 200.00);
>
> BankAccount\* a = &ba1;
>
> BankAccount\* b = &ba2;

3.  Write the output generated by the following program:

> \#include <iostream> using namespace std; int main() { int\* p;
> int j = 12; p = &j;
>
> cout << ((\*p) + (\*p)) << " " << ((\*p) \* (\*p))
> << endl; return 0; }

3.  Write statements that store the address of ch, a char object, into a
    > char pointer object named charPtr.

4.  Write the minimum code that declares and initializes all the objects
    > as shown in the diagram below:

> n1n2n3 p1p2p3

3.  Using the code from your answer to the previous question, write a
    > statement that indirectly displays the sum of all the integers
    > using \* (the dereference operator).

4.  Write the output generated by the following code:

> int p = 111; int\* q = &p; p += 222;
>
> cout << "p? " << p << endl; cout << "q? "
> << \*q << endl;

3.  Write the output generated by the following code:

> int n1 = 4; int n2 = 8; int\* ptr1; int\* ptr2; ptr1 = &n1; ptr2 =
> &n2;
>
> cout << (\*ptr1) << " " << (\*ptr2) << endl;
> 12-12 Write the output generated by the following code:
>
> double\* p = new double; double\* q = new double;
>
> \*p = 1.23; \*q = 4.56; p = q;
>
> cout << (\*p) << " " << (\*q);
>
> 12-13 In the preceding code of 12-12, is it possible to retrieve the
> value 1.23 by modifying the last line?

12.2 THE PRIMITIVE C ARRAY

> Th e vector class is a relatively new addition to C++. In the past,
> the built-in, primitive C array was frequently used to store
> collections of objects. Because an array actually stores the address
> of the fi rst element, it is a useful example for illustrating pointer
> usage. Th e C array is used so frequently for implementing programs
> that you are likely to see it in existing code. But more importantly,
> the primitive C array illustrates the benefi ts of dynamic memory
> management. It

12.2: The Primitive C Array

> provides a peek under the hood of vector::resize and string
> assignments. Both use pointers and dynamic allocation to better manage
> memory.
>
> Th e primitive C array is a fi xed-size collection of elements that
> are of the same class. Arrays are homogeneous because they store
> collections of like objects. Th e objects in the collection may be one
> of the built-in classes char, int, long, or double. Th e objects may
> also be declared as a programmer-defi ned class such as BankAccount as
> long as the class has a default constructor. Here is the general form
> for declaring a primitive C array:

General Form 12.4 *Array declaration*

> *type* *array-name*\[*capacity*\];
>
> Th e *type* specifi es the type of objects stored under *array-name*.
> Th e *capacity* specifi es the maximum number of elements that can be
> stored under the array name. Th e capacity must be an integer constant
> (such as 100) or a named integer constant. An array cannot be sized or
> resized at runtime as a vector object can, at least not as a standard
> operation. Th e array shown next stores a maximum of one hundred:
>
> double x\[100\];
>
> Individual array elements are referenced through subscripts in the
> same manner seen with vector objects:

**General Form 12.5** *Referencing individual array elements*

> *array-name*\[*int-expression*\];
>
> Th e subscript range of a primitive array is the same as a vector
> going from 0 through capacity - 1.

12.2.1 DIFFERENCES BETWEEN PRIMITIVE ARRAYS AND vectors

> Th ere are many similarities between arrays and vectors—especially in
> the referencing of individual elements. In fact, the same
> vector-processing algorithms of chapter 10, “Vectors,” could also be
> applied to primitive C arrays. Th e most noticeable diff erence is
> that primitive C arrays cannot be made to automatically check for
> out-of-bounds subscripts. Th is is one of the drawbacks of the C
> array. It is safer to have the subscript range-checking feature
> available, especially when fi rst learning about arrays and vectors.
>
> Some very strange errors occur when the code lets the computer “walk
> off ” the end of an array. Th e important state of other objects may
> be accidentally destroyed. With the subscript range checking of vector
> objects, the program can notify the programmer whenever there is an
> attempt to reference out-of-bounds memory. Th is can be a preferable
> situation.

Here are the diff erences between the vector class and primitive C
arrays:

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  > **Diff erence**                                                              vector **Example**                                    **C Array Example**
  ------------------------------------------------------------------------------ ----------------------------------------------------- ----------------------------------------------------
  > vectors can initialize all vector elements at construction; arrays cannot.   vector <int> x(100, 0); // All elements are 0   int x\[100\]; // Elements are garbage

  > vectors can be easily resized at runtime; arrays take a lot more work.       int n; cin >> n;                                // See growing an array
                                                                                                                                       
                                                                                 x.resize(n);                                          // in a later chapter

  > vectors can be made to prevent out-of-range subscripts.                      // You are told                                       // Destroys other variables cin >> x\[100\];
                                                                                                                                       
                                                                                 // something is wrong cin >> x.at(100);         

  > vectors require an \#include; primitive, built-in arrays do not.             \#include <vector>                              > // No \#include required
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

12.2.2 THE ARRAY / POINTER CONNECTION

> It turns out that all primitive C array variables actually store the
> pointer to—or the address of— the fi rst array element. Whenever the
> subscript operator is applied to an array object, an address is
> computed. For example, if x is an array of integers, each array
> element is four bytes long, and x has the value of address 6000, the
> following formula computes x\[3\] as 6000 + (3 \* 4).
>
> Formula for Computing the Address of Individual Array Elements
>
> *address of rst array element* + (*subscript* \* *size of one
> element*)
>
> Th erefore, x\[3\] is stored at address 6012.

  **Reference **   **Address **   **Value**
  ---------------- -------------- -----------
  x\[0\]           6000           > ?
  x\[1\]           6004           > ?
  x\[2\]           6008           > ?
  x\[3\]           6012           > ?
  x\[4\]           6016           > ?

12.2.3 PASSING PRIMITIVE ARRAY ARGUMENTS

> When an array is passed to a function, the address of the fi rst array
> element gets sent. Arrays are automatically passed by reference. An
> array parameter is declared with the class and the parameter name
> followed by \[ \]. Th is is illustrated in the next program where
> main() passes an array to the

12.2: The Primitive C Array

> function init. Notice that when the function init alters the array
> parameter x, the associated array argument anArray is also altered.
> Both x and anArray have the fi rst three array elements assigned a
> value (90, 95, 99). Th is occurs even though & is not used for the
> parameter anArray. anArray is passed by value.
>
> // Pass the address of the array to a function.
>
> // The & is not required. An array stores an address.
>
> \#include <iostream> using namespace std;
>
> void init(int x\[\], int & n) {
>
> // x and n are reference parameters; however, x does not need & x\[0\]
> = 90; x\[1\] = 95; x\[2\] = 99; n = 3; }
>
> int main() { int n = 5; int anArray\[5\];
>
> init(anArray, n); // init will change x and anArray for (int index =
> 0; index < n; index++) { cout << anArray\[index\] << "
> ";
>
> } cout << endl;
>
> return 0; }
>
> Output
>
> 90 95 99
>
> Since the value stored in the array name is an address—a reference to
> the fi rst array element, passing the array name to a function
> actually passes an address. Th erefore, arrays are automatically
> passed by reference, which is the address of the fi rst array element.
> Subscripting parameter x results in the equivalent of subscripting
> argument anArray. Th e following fi gure depicts that anArray was
> passed by reference, even though & was not used:
>
> void init(int x\[\], int & n) { x

} // a change to x is a change to anArray in main

> int main() { anArray

12.3 ALLOCATING MEMORY WITH new

> Pointer objects are frequently assigned values through the new
> operator. When the new operator precedes a class name, the resulting
> expression allocates a contiguous block of memory large enough to
> store one instance of that class. Additionally, the same expression
> returns the address, or a pointer to, this memory.
>
> **General Form 12.6** *Dynamic memory allocation (for one object
> only)*
>
> new *class-name*;
>
> Th e memory is allocated at runtime from the *free store*—a portion of
> computer memory reserved for this purpose (the free store is sometimes
> called the *heap*). For example, the following expression allocates
> enough memory to store one int value. Th e expression returns a
> pointer to that memory.
>
> new int; // Allocate memory, return a pointer value (an address)
>
> Instead of ignoring the returned pointer value (the address where an
> integer could be stored), such pointer expressions are usually
> combined with pointer objects in initializations.

int\* intPtr = new int; // Allocate memory, store address in intPtr Th e
above is an abbreviated form of the following equivalent code:

> int\* intPtr; intPtr = new int; // Allocate memory, store address in
> intPtr
>
> Now we have a situation where intPtr holds the address of an int
> object—where an int could be stored. Th is is shown in the next fi
> gure where the undefi ned int value is signifi ed as ? and the pointer
> value is represented as an arrow indicating a value that points to
> that undefi ned int:
>
> intPtr
>
> Th is statement initializes that new allocation of memory:
>
> \*intPtr = 123;
>
> Th is resulting representation shows the state of the pointer and the
> int:
>
> intPtr 123
>
> Th e following program shows dynamic allocation of one int object:
>
> // Illustrate one pointer object and one int object
>
> \#include <iostream>

12.3: Allocating Memory with new

> using namespace std;
>
> int main() {
>
> // Declare an intPtr as a pointer to an int int\* intPtr;
>
> // Allocate memory for an int and store address in intPtr intPtr = new
> int;
>
> // Store 123 into memory referenced by intPtr
>
> \*intPtr = 123;
>
> cout << "\\n The address stored in the pointer object: "
> << intPtr; cout << "\\nThe value of the int pointed to by
> intPtr: " << \*intPtr;
>
> return 0; }
>
> Output (address shown in hexadecimal (a is 10, f is 15)
>
> The address stored in the pointer object: 0x7fbd3bc04a20
>
> The value of the int pointed to by intPtr: 123
>
> Notice that the pointer object, with value 25,360 (0x7fbd3bc04a20
> hexadecimal), is referenced as intPtr. Th e actual int with value 123
> is dereferenced as \*intPtr.

12.3.1 ALLOCATING MEMORY FOR ARRAYS AT RUNTIME

> At times it is convenient to allocate arrays at runtime, when a
> maximum capacity is better known. Th e C++ new operator accomplishes
> this by allocating memory for many objects with \[*capacity*\], where
> *capacity* represents the number of objects to allocate.

**General Form 12.7** *Dynamic memory allocation (capacity objects)*

> new *type*\[*capacity*\];
>
> *Example:* allocate memory for 10 integers
>
> new int\[10\]; // Allocate memory for 10 integers and return // a
> pointer to this newly allocated memory
>
> Because new returns a pointer to the fi rst byte of the array, it can
> be used for pointer object initialization with this shortcut:

**General Form 12.8** *Initializing pointer objects*

> *type*\* *identi er* = new *class-name*\[*number of elements*\];

*Example:*

> int\* nums = new int\[10\];
>
> Now the pointer object nums points to the fi rst of 4 \* 10 bytes of
> uninitialized (garbage) memory where each 4 bytes stores one integer:
>
> nums

  > ?       ?         ?         > ?       > ?       > ?     > ?       > ?       > ?       ?
  --------- --------- --------- --------- --------- ------- --------- --------- --------- -------
  > \[0\]   > \[1\]   > \[2\]   > \[3\]   > \[4\]   \[5\]   > \[6\]   > \[7\]   > \[8\]   \[9\]

> One time you might fi nd this dynamic allocation of memory useful is
> when you have an array of objects set to an initial capacity, and then
> at runtime, you need to store more than the maximum capacity. Th is
> can be done with the following algorithm:

-   Make a temporary array that is bigger than the instance variable.

-   Copy the original contents (num\[0\] through nums\[n - 1\]) into
    > this temporary array.

-   Assign the reference to the temporary array to refer to the
    > original array.

> // This code dynamically (at runtime) "grows" an array
>
> \#include <iostream> using namespace std;
>
> int main() { int n = 10;
>
> int\* nums = new int\[n\]; // Some C++ compilers can not handle
> int\[n\] int anInt = 1;
>
> // Initialize n array elements with a for loop for (int i = 0; i <
> n; i++) { nums\[i\] = anInt; anInt += 3; }
>
> // Show the lled array for (int i = 0; i < n; i++) { cout <<
> nums\[i\] << " "; }
>
> // Need more room? Grow the array at runtime
>
> int\* temp = new int\[n+5\]; // Some C++ compilers can not handle
> int\[n+5\]
>
> // 2) copy the elements to the temporary array for (int i = 0; i <
> n; i++) { temp\[i\] = nums\[i\]; }
>
> // Make the original array pointer refer to the "bigger" array nums =
> temp;

12.3: Allocating Memory with new

> // Add 3 more elements to the bigger array nums\[n++\] = 997;
> nums\[n++\] = 998; nums\[n++\] = 999;
>
> // Print the larger array with the added elements cout << endl
> << "Larger array" << endl; for (int i = 0; i < n; i++)
> { cout << nums\[i\] << " ";
>
> } return 0; }
>
> Output
>
> 1 4 7 10 13 16 19 22 25 28
>
> Larger array
>
> 1 4 7 10 13 16 19 22 25 28 997 998 999

Here are the arrays through pictures—fi rst the original array fi lled
to capacity:

> nums

  9       12      15      18      21
  ------- ------- ------- ------- -------
  \[0\]   \[1\]   \[2\]   \[3\]   \[4\]

Th is is the new array with twice the capacity of the original:

> temp

  ------------------------------------------------------------------------------------------------------
       > ?       ?         ?         > ?       > ?       > ?     > ?       > ?       > ?       ?
       --------- --------- --------- --------- --------- ------- --------- --------- --------- -------
       > \[0\]   > \[1\]   > \[2\]   > \[3\]   > \[4\]   \[5\]   > \[6\]   > \[7\]   > \[8\]   \[9\]
     
     
  -- ---------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------

> Finally, nums is made to point to the new array, the same one
> referenced by temp with this one assignment statement:
>
> nums = temp;

After three integers are added to the larger-capacity array, we have
this situation:

> temp

  ------------------------------------------------------------------------------------------------------
       > ?       ?         ?         > ?       > ?       > ?     > ?       > ?       > ?       ?
       --------- --------- --------- --------- --------- ------- --------- --------- --------- -------
       > \[0\]   > \[1\]   > \[2\]   > \[3\]   > \[4\]   \[5\]   > \[6\]   > \[7\]   > \[8\]   \[9\]
     
     
  -- ---------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------

> nums

SELF-CHECK

> 12-14 Write the output of the following code:
>
> int\* x = new int\[10\]; x\[0\] = 4; x\[1\] = 8;
>
> cout << x\[0\] + x\[1\] << endl;
>
> 12-15 Write one initialization using new to allocate an array that can
> store 1000 doubles.
>
> 12-16 Write the code that initializes all 1000 doubles of the previous
> question to -1.
>
> 12-17 Write the output generated by the following code:
>
> const int MAX = 6; int\* x = new int\[MAX\];
>
> for(int i = 0; i < MAX; i++) { x\[i\] = 2 \* i;
>
> }
>
> for(int i = 0; i < MAX; i++) { cout << x\[i\] << " "; }
>
> 12-18 Primitive arrays can be declared and initialized at the same
> time with array initializers such as the following:
>
> int x\[\] = {3, -4, -3, 6, 1}; int n = 5;
>
> Write the code that fi nds the range of the array elements in x. Range
> is defi ned as the largest minus the smallest integer. Your code must
> work for arrays that have array initializers with diff erent values
> and capacities.
>
> 12-19 Declare an array of strings with an array initializer that has
> the following strings in this order: "a", "b", "c", and "d".

12.4 THE delete OPERATOR

> So far, the new operator examples allocated only small amounts of
> memory. However, consider what happens when dynamic data grows to a
> large size. Using new without returning memory to the free store
> results in a *memory leak*. Th is limits the amount of memory
> available to a program. At some point, a program no longer needs
> dynamically allocated memory. When this occurs, the unneeded memory
> should be allocated back to the free store. Th is makes it available
> for other

12.4: The delete Operator

> objects that have yet to be dynamically allocated. Th is return of
> memory, or *deallocation*, is accomplished with the C++ built-in
> *delete* operator. Th e delete operator has two general forms:

**General Form 12.9** *Deallocating memory—a form of recycling*

> delete *pointer-object*; delete\[\] *pointer-to-array*;
>
> Th e fi rst form returns the memory allocated for one dynamic object
> back to the free store. Th e second form returns memory allocated for
> a group of objects with new and \[ \]. In the following program, the
> delete operator allocates enough memory for one double pointed to by
> p, ten chars pointed to by charArray, and 100 integers pointed to by
> x.
>
> // Allocate and deallocate memory at runtime
>
> \#include <iostream> using namespace std;
>
> int main() { int\* p = new int; \*p = 123;
>
> int\* x = new int\[10000\]; // claim 40,000 bytes from the free store
> x\[0\] = 76; x\[1\] = 89;
>
> // ... x\[9999\] = \*p;
>
> // When no longer needed, free the memory to avoid memory leaks delete
> p; delete\[\] x; // All the bytes of memory pointed to by p and x can
> be allocated later
>
> return 0; }
>
> After the two delete statements return the allocated memory back to
> the free store, the pointers should not be used. Using them at this
> point results in unpredictable behavior. Our programs with arrays
> should use delete to return the memory no longer needed. Th ere are no
> notifi cations or errors shown. Instead, we get memory leaks, which
> means memory no longer needed cannot be recycled later.
>
> double\* temp = new double\[n+5\]; for (int i = 0; i < 10; i++) {
> temp\[i\] = nums\[i\]; } delete\[\] nums; // Avoid a memory leak by
> freeing up memory

**12.5 THE SINGLY LINKED STRUCTURE **

WITH C structs

> A singly linked data structure is an alternative way to store a
> collection of elements in a sequential fashion. Th ere is high
> probability that your standard C++ list class has been implemented
> using a linked structure with some of the concepts presented in this
> section.
>
> Instead of having elements stored in contiguous memory, this singly
> linked structure will have a collection of linked node objects where
> each node stores an element and a link to the next node in the
> sequential collection. We also need a pointer to the fi rst node,
> which is named rst here.
>
> To accomplish this, a pointer data member is added to a class or a
> struct. A struct is the same thing as a class except that by default,
> members of a class are private and members of a struct are public.
> However, if you use public and private explicitly, there is no diff
> erence other than the name. Th e struct is presented here for
> historical reasons and because structs typically have constructors and
> data members only. Because struct data members are public by default,
> adding public: is not necessary.

An example struct with two public data members and a start to
LinkedList:

> \#ifndef LINKEDLIST\_H\_
>
> \#de ne LINKEDLIST\_H\_
>
> /\*\*

-   This le contains two types:

> \*

-   1\) struct node to hold an element and a link to another node

-   2\) class LinkedList to hold an indexed sequential collection using

-   the singly linked data structure

> \*

-   A LinkedList can only store string elements. Templates are not \*
    > used here to allow focus on pointers and memory management.

> \*/ struct node {
>
> // Two public data members std::string data; node\* next;
>
> // Two public constructors node() {
>
> next = nullptr; }
>
> node(std::string element) { data = element; next = nullptr; }
>
> }; // class LinkedList will go here . . .
>
> \#endif /\* LINKEDLIST\_H\_ \*/
>
> Th e following code constructs a new node object pointed to by rst and
> displays the value using the -> operator, which is necessary for
> dereferencing the public data members of node.
>
> \#include <iostream>
>
> \#include <string>
>
> \#include "LinkedList.h" using namespace std;
>
> int main() {
>
> // Let nodePointer reference a dynamically allocated node object
> node\* rst = new node("Kim"); // assert: nodePointer->next ==
> nullptr
>
> // Display the state of the public data member my\_data cout <<
> " The value: " << rst->data << endl; cout <<
> "\#characters: " << rst->data.length() << endl; }
>
> **Output:**
>
> The value: Kim
>
> \#characters: 3

Here is a representation of what this looks like in memory:

> A linked structure has the characteristic that one element can be
> referenced from another element. With a data member to store a pointer
> to another object of the same class, objects can be linked together in
> such a way that the pointer in the fi rst node object can be used to
> fi nd the second node. Th e following code constructs three node
> objects that are linked together. Notice that a reference to the data
> of the second node is made using the pointer p >next.
>
> // Build the rst node node\* p = new node("One");
>
> // Construct a second node pointed to by the rst node's next
> p->next = new node("Two");
>
> // Build a third node pointed to by p->next->next
> p->next->next = new node("Three");

Here is a representation of what three linked nodes look like in memory:

> Th ese three nodes can be traversed by allowing a pointer, named ptr
> here, to refer to all three nodes. It begins by having ptr point to
> the fi rst node. If ptr is not nullptr, the node’s data is displayed
> (inside the loop).
>
> // Traverse the nodes until a next eld is nullptr node\* ptr = p; //
> Don't change p, which is a pointer to the rst node while(ptr !=
> nullptr) { cout << ptr->data << endl; ptr =
> ptr->next; }
>
> ptr is updated to point to the next node or it is set to nullptr at
> the end of each loop iteration with the statement ptr = ptr >next.

12.5.1 A LIST CLASS USING THE SINGLY-LINKED DATA STRUCTURE

> Th is section describes LinkedList member functions that use these
> node objects. Th e constructor establishes an empty list using a dummy
> header node. Th is makes the coding easier during add and remove.
>
> class LinkedList {
>
> private:
>
> node\* header; node\* last; int n; public:
>
> //--constructor
>
> LinkedList() {
>
> // Create a dummy header node to make things easier header = new node;
> // call node's default constructor last = rst; n = 0; }
>
> Here is a representation of what an empty list with a dummy fi rst
> node looks like in memory:

12.5.2 add(std::string)

> Adding an element to a linked list has diff erent meanings for ordered
> and unordered lists. An ordered list stores objects in an ascending
> order based on the meaning of <. Th e linked list developed here is
> not ordered so the elements will not be in alphabetic order. Since
> this linked list here is unordered, all new elements can be added at
> the very end of the list. Th is is easy when a dummy headed node is
> employed to avoid the special case of adding to an empty list or
> removing an element. Elements are added by creating a new object
> pointed to by last->next. Th e member data last must then be
> updated to point to the last node. Th e current count must also be
> incremented.
>
> void add(const std::string newElement) { // Allocate and initialize a
> new node last->next = new node(newElement);
>
> // Update the last pointer last = last->next;
>
> // Maintain current size n++; }

Th is one adds message results in the pictures of memory shown below:

> LinkedList stringList; // n == 0 stringList.add("First"); // n == 1
>
> stringList.add("Second"); // n == 2

12.5.3 get(int index)

> Th e get operation uses a for loop to advance an external pointer ptr
> to the correct node. Notice that if index is 0, the for loop does not
> advance ptr, leaving it to point to the fi rst real node— the one
> pointed to by header->next, which would be the value " rst".
>
> std::string get(int index) { node\* ptr = rst->next; for (int i =
> 0; i < index; i++) { ptr = ptr->next;
>
> }
>
> return ptr->data; }

12.5.4 remove(string removalCandidate)

> Th ese two possibilities must be considered when removing an element
> from a linked list:

1.  the == operation does not match an element in the list

2.  the == operation does match an element in the list

> Th e search for a particular element in a linked list is similar to a
> sequential search through a vector or array. Th e diff erence is that
> now, instead of a subscript, a pointer will be used to access the data
> members.
>
> Th e search for "Second" begins by pointing a variable named ptr to
> the fi rst element in the list. With the node header, we can peek one
> node ahead in the search while maintaining a pointer to the node that
> precedes the node to be removed.
>
> A sequential search continues until ptr->next->data equals the
> removalCandidate or there are no more elements to search. Since
> ptr->data == removalElement ("First" == "Second") is false, the
> loop advances ptr to the next node in the list.
>
> Now the node pointed to by ptr points to the node before the node to
> be removed: ptr->next->data == "Second" is true now. With the
> help of the dummy header node, this algorithm is able to peek at the
> data one node ahead. Th is comes in handy as we need to send a pointer
> around the node to be deleted with ptr->next =
> ptr->next->next.
>
> Now the node pointed to ptr->next can safely be returned to the
> free store with delete.
>
> bool remove(const std::string removalElement) {
>
> // Create an external pointer to point to the node before the rst node
> node\* ptr = header;
>
> // Search the remaining list elements until
>
> // found or the end of the list is found
>
> while (ptr->next != nullptr && ptr->next->data !=
> removalElement) { ptr = ptr->next; }
>
> // Don't delete a nonexistent node
>
> if (ptr->next == nullptr) { // removalElement was not found return
> false;
>
> } else {
>
> // Check if the last node is being removed so last gets corrected
> if(ptr->next == last) { last = ptr;
>
> }
>
> // Send the link around the node to be removed ptr->next =
> ptr->next->next; if (ptr != header)
>
> delete ptr->next; // Deallocate memory n--; // Maintain current
> size return true; // Report successful removal
>
> }
>
> }
>
> If the last node is to be removed, last must be adjusted to the
> preceding node. If ptr points to the last node, the element was not
> found so remove returns false.

SELF-CHECK

> 12-20 Draw a picture of a linked list with two nodes before and after
> removing the fi rst node.
>
> 12-21 Draw a picture of a linked list with one node before and after
> removing the fi rst node.
>
> 12-22 What happens if removalCandidate is not found in the list?
>
> 12-23 True or False

Chapter Summary

a.  Th e size of a dynamically linked list must be determined before the
    > program begins to execute.

b.  Elements in a linked list are referenced through subscripts.

c.  Elements may be inserted into or deleted from a linked list at the
    > beginning, end, or even the middle of a linked list.

d.  When an element is to be inserted into or deleted from a linked
    > list, the list should be checked to see if it is empty.

e.  When an element has been removed from a dynamically linked list, the
    > memory it used should be returned to the free store.

> 12-24 Write method bool removeLast() to remove the last element in a
> LinkedList. Return false if the list is empty. Th e program should
> generate the output shown in comments.
>
> \#include <iostream>
>
> \#include <string>
>
> \#include "LinkedList.h" using namespace std;
>
> int main() {
>
> LinkedList list;
>
> cout << list.removeLast() << endl; // 0 list.add("A");
>
> cout << list.removeLast() << endl; // 1 list.add("B");
> list.add("C"); list.add("D");
>
> cout << list.removeLast() << endl; // 1 list.add("E");
> cout << list.get(0) << " "; cout << list.get(1)
> << " "; cout << list.get(2) << endl; // B C E cout
> << list.size() << endl; // 3 return 0; }

CHAPTER SUMMARY

-   Pointers store addresses of other objects. A pointer object points
    > to some object. For example, ptr is a pointer and \*ptr is a
    > reference to the double object x that starts as 99.9.

> double \* ptr; double x = 99.9; ptr = &x;
>
> \*ptr = 1.234;
>
> In the last statement, the pointer changes the value stored in x to
> 1.234. Th e \* (asterisk) dereferences the pointer. Th is means the
> pointer goes to the address stored in the pointer, which in this case
> is the address of x and changes the value stored at that address. Th
> erefore, the pointer changes the value stored in x indirectly.

-   Th e address of a variable is the fi rst address at the location
    > where the state is stored. If it takes 4 bytes to store an int,
    > the address of the int is the address of the fi rst byte of the
    > int value, which is the address stored in the pointer. Th e
    > pointer knows when to stop reading addresses because the pointer
    > was declared as an int pointer. Th erefore, it reads 4 bytes (this
    > may vary depending on your computer system).

-   Th e address operator & gives us the address of a variable.

-   Th e primitive C array—similar to the C++ vector class—is available
    > on all compilers and will often be seen in existing C and
    > C++ code.

-   Th e new operator allocates memory from the free store. Th e delete
    > operator deallocates memory. If more than one object is allocated
    > as in char\* name = new char\[10\]; it must be deallocated with \[
    > \] like this: delete \[\] name;

-   You can allocate memory at runtime with new and return it to the
    > free store with delete.

PROGRAMMING TIPS

1.  Draw linked structures when debugging programs with pointers. Th e
    > value of a pointer object represents a location in the memory of
    > the computer. Th ese values are diffi cult to use in a
    > program trace. A diagram with arrows and boxes makes execution
    > simulation and pointer debugging much clearer.

2.  Pointers allow dynamic allocation of arrays. One problem when using
    > arrays involves how big to make them at compile time. It may be
    > big enough one time, but not another. Sometimes memory gets wasted
    > when declared too big.

3.  Use vectors instead of arrays. Th e standard vector type can be
    > dynamically grown, or shrunk even, at runtime with
    > resize messages. Let this well-tested class do the work for you.

4.  Avoid memory leaks. Use the delete operator to return the memory
    > back to the free store for single variables. Use the delete\[\]
    > operator to free an array of values.

EXERCISES

1.  Write the values of the attributes supplied by this initialization:

> double x = 987.65;

Exercises

  a\. class   c\. state
  ----------- -------------
  b\. name    d\. address

1.  Declare a pointer to an int and initialize the pointer somehow.

2.  Use these statements to answer the questions that follow:

> int\* intPtr; int anInt = 123; intPtr = &anInt;

a.  What is the name of the pointer object?

b.  What is the value of \*intPtr?

c.  Without using anInt, write a statement that adds 100 to the memory
    > storing 123.

<!-- -->

1.  Write the minimum declarations and statements that declare and
    > initialize all the objects as they are shown in the diagram below.

> a

p1 p2 p3

1.  Using your code from the previous question, write the statements
    > that will have a pointer object named largestPtr pointing to the
    > largest integer no matter where it is stored among a, b, and c.

2.  Using the declarations shown, which of the following are valid
    > assignments that do not generate an error?

> int j = 456; int\* p;

  a\. p = j     g\. p = &p
  ------------- -----------------
  b\. p = &j    h\. p = 123
  c\. p = 0     i\. \*p = "abc"
  d\. j = p     j\. \*j = 123
  e\. j = 123   k\. j = &p
  f\. \*p = j   l\. \*p = \*p

1.  Write the output generated by this code:

> int \* intPtr; int anInt = 987; intPtr = &anInt;
>
> \*intPtr = \*intPtr + 111; cout << \*intPtr << " "
> << anInt;

1.  Trace the following program segment by drawing pictures of the
    > modifi ed objects:

> n1 = 123; p1 = &n1; \*p1 = \*p1 + 111;

1.  Trace the following program segment by drawing pictures of the
    > modifi ed objects:

> n2 = 999; p3 = &n2; p2 = p3;

1.  Trace the following program segment by drawing pictures of the
    > modifi ed objects:

> int \* intPtr; intPtr = p3;

**PROGRAMMING PROJECTS**

12A ENHANCE LinkedList

> Add two methods to the LinkedList class:

1.  void toString() to return a string containing all elements with 10
    > elements separated by a new line “\\n”.

2.  void insertInOrder(std::string element) to insert string elements
    > into the singly linked structure while maintaining
    > alphabetical ordering.

12B CLASS LinkedStack WITH A SINGLY LINKED STRUCTURE

> Implement class LinkedStack which allows elements to be added and
> removed in a last-in, fi rstout (LIFO) manner. Th is class must use a
> singly-linked structure to store the elements. Stacks have an
> operation called push to place elements at the “top” of the stack and
> another operation called pop to remove and return the element at the
> top of the stack. Th e only element on the stack that may be
> referenced is the one on the top. Th is means that if two elements are

Programming Projects

> pushed onto the stack, the topmost element must be popped (removed)
> from the stack before the fi rst-pushed element can be referenced.
> Here is a stack program for storing strings:
>
> \#include <iostream>
>
> \#include <string> // Needed by Visual Studio
>
> \#include "LinkedStack.h" using namespace std;
>
> int main() { LinkedStack stack; // stack of 20 strings
>
> // Use intStack stack.push("a"); stack.push("b"); stack.push("c");
> stack.push("d");
>
> cout << "d? " << stack.peek() << endl; cout <<
> "d? " << stack.pop() << endl; cout << "c? " <<
> stack.peek() << endl;
>
> cout << "isEmpty 0? " << stack.isEmpty() << endl;
> cout << "c b a? "; while(! stack.isEmpty()) { cout <<
> stack.pop() << " ";
>
> } cout << endl;
>
> cout << "isEmpty 1? " << stack.isEmpty() << endl;
>
> return 0; }
>
> Using the class LinkedStack that you generate, this program must
> compile and generate the following output:
>
> Output
>
> d? d d? d c? c isEmpty 0? 0 c b a? c b a isEmpty 1? 1
>
> LinkedStack must use a singly linked structure. It is recommended you
> keep a pointer to the top of the stack and push new elements onto the
> front. If top == nullptr, you can have top refer to a new node with
> the element. When the stack is not empty, you can add to the fi rst so
> top references the most recently added. In this case, if you have
> pushed "First" then stack.push("Second") you could use code shown here
> in pictures of memory.

12C LinkedPriorityList

> Th is project asks you to implement a collection class
> LinkedPriorityList using a singly linked structure to store a sequence
> of string objects (no templates). Th is new type will store a
> collection of elements as a zero-based indexed list where the element
> at index 0 is considered to have higher priority than the element at
> index 1. Th e element at index size()-1 has the lowest priority. An
> instance of this collection class will be able to store just one type
> of element such as <string>.
>
> Output
>
> Sleep
>
> Get groceries
>
> Study for the CS exam
>
> Complete these methods in LinkedPriorityList so it uses a singly
> linked structure to store elements. Don’t forget to add struct node in
> the same fi le as this class.
>
> // Construct an empty LinkedPriorityList
>
> LinkedPriorityList();
>
> // Return the number of elements currently in this LinkedPriorityList
> int size();
>
> // Return true if size() == 0 or false if size() > 0 bool
> isEmpty();
>
> // Insert the element at the given index.
>
> // precondition: index is on the range of 0 through size() void
> insertElementAt(int index, std::string el); // Return a reference to
> the element at the given index.

Programming Projects

> // precondition: index is on the range of 0 through size()-1
> std::string getElementAt(int index);
>
> // Remove the element at the given index.
>
> // precondition: index is on the range of 0 through size()-1 void
> removeElementAt(int index);
>
> // Swap the element located at index with the element at index+1.
>
> // Lower the priority of the element at index size()-1 has no effect.
>
> // precondition: index is on the range of 0 through size() void
> lowerPriorityOf(int index);
>
> // Swap the element located at index with the element at index-1.
>
> // An attempt to raise the priority at index 0 has no effect.
>
> // precondition: index is on the range of 0 through size() void
> raisePriorityOf(int index);
>
> // Move the element at the given index to the end of this list.
>
> // An attempt to move the last element to the last has no effect.
>
> // precondition: index is on the range of 0 through size()-1 void
> moveToLast(int index);
>
> // Move the element at the given index to the front of this list.
>
> // An attempt to move the top element to the top has no effect.
>
> // precondition: index is on the range of 0 through size()-1 void
> moveToTop(int index);
>
> To help you understand how these methods work, consider the program
> below that shows the changing list as each of the messages is sent to
> list. Recommended: implement one member function at a time, and write
> tests to ensure that it works.
>
> \#include <iostream>
>
> \#include "LinkedPriorityList.h" using namespace std;
>
> int main() {
>
> LinkedPriorityList list; list.insertElementAt(0, "a");
> list.insertElementAt(1, "b"); list.insertElementAt(2, "c");
> list.insertElementAt(3, "d");
>
> for (int i = 0; i < list.size(); i++) // a b c d cout <<
> list.getElementAt(i) << " "; cout << endl;
>
> list.insertElementAt(1, "f");
>
> for (int i = 0; i < list.size(); i++) // a f b c d cout <<
> list.getElementAt(i) << " "; cout << endl;
>
> list.removeElementAt(0);
>
> for (int i = 0; i < list.size(); i++) // f b c d cout <<
> list.getElementAt(i) << " "; cout << endl;
>
> list.lowerPriorityOf(3); // no effect list.lowerPriorityOf(0); // move
> f right list.lowerPriorityOf(1); // move f right
> list.lowerPriorityOf(2); // move f right for (int i = 0; i <
> list.size(); i++) // b c d f cout << list.getElementAt(i)
> << " "; cout << endl;
>
> list.raisePriorityOf(0); // no effect list.raisePriorityOf(2); // move
> d left list.raisePriorityOf(1); // move d left for (int i = 0; i <
> list.size(); i++) // d b c f cout << list.getElementAt(i)
> << " "; cout << endl;
>
> list.moveToLast(list.size() - 1); // no effect
>
> list.moveToLast(0); // move d from top priority to last priority for
> (int i = 0; i < list.size(); i++) // b c f d cout <<
> list.getElementAt(i) << " "; cout << endl;
>
> list.moveToTop(0); // no effect
>
> list.moveToTop(2); // move f to top priority again for (int i = 0; i
> < list.size(); i++) // f b c d cout << list.getElementAt(i)
> << " ";
>
> return 0; }

12D LinkedPriorityList<Type> THROWS EXCEPTIONS

> Change your code so it throws an exception when the index is out of
> range. To do this, fi rst add this \#include to
> PriorityList<Type>:
>
> \#include <stdexcept>
>
> Th en add an if statement to every method that takes index as a
> parameter. An exception will be thrown if the programmer supplies an
> incorrect index like -1 or an index > size(), which is a good
> thing:
>
> // Insert the element at the given index.
>
> // precondition: index is on the range of 0 through size() void
> insertElementAt(int index, Type element) { if (index < 0 || index
> > size()) { throw std::invalid\_argument(
>
> "\\ninsertElementAt: index must be 0..size()");
>
> } // . . .
