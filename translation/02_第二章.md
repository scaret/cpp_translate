# 第2章 C++基础

**前章回顾**

在第1章中，我们介绍了在实际程序开发中常见的分析、设计、实现三步走策略，并鼓励大家在编写C++代码之前先做一些分析与设计。然而，对于本书中的很多问题来说，实际上往往并没有什么具体的分析和设计可做。通常，所谓的分析可能只是“阅读问题”，而设计也可能只是”在脑海中构思一个算法“。

**本章提要**

在这一章中，我们将重点介绍如何用C++编程语言将算法转换成程序。而我们所键入的这份源代码将作为输入被传递给编译器，由编译器将该源代码转换成我们指定计算机所能理解的机器码。当然，编译器会要求源代码必须遵循某种精确的编程语言规范。因此，如果要想理解算法的伪代码是如何被转换成等效的编程语言的，我们就必须要了解组成一个程序的最小零件，并知道如何正确地将它们组建成相关的语句。另外，本章也会介绍许多对象可以执行操作。我们希望在完成本章的学习之后，你将：

* 了解如何将现有的源代码纳入到自己的程序中。
* 学会从用户那里获取数据，并能将信息显示给用户。
* 学会创建算术表达式，并能对其进行求值。
* 了解初始化、输入、赋值以及输出等在许多对象上都通用的常见操作。
* 学会用C++编程语言来解决问题。

## 2.1 C++程序的零件

在原始状态下，C++程序不过只是存储在某种文件中的一段在字符序列而已，但这种文件的命名通常会以`.cc`、`.c`、`.cp`或`.cpp`结尾（譬如`first.cc`、`first.C`或`first.cpp`），以此来表示该文件是一段c++程序。而某些编程环境往往需要或假定用户遵循这套文件命名约定，所以当我们为将某个算法转换成与之等效的C++编程语言创建相关文件时，也务必要使用这种约定的扩展名来命名文件。

而对于文件中所包含的文本，我们接下来也要引入某种C++程序的*通用格式*，这种通用格式是用来描述*语法*（即语言使用规范）的，它也需要有符合编程语言结构的写法。和本书中其他所有地方一样，这种通用格式也将遵守以下约定：

1. 以`等宽字体`呈现的元素可被原样使用。这其中既包括`int main`、`cout`、`cin`这些关键字，也包括`<<`、`>>`这样的符号。
2. 以*倾斜字体*呈现的这部分通用格式将必须由程序员来负责提供具体内容，譬如*expression*表示程序员须在该处提供一个有效的表达式。
3. 以倾斜字体呈现的实体项代表它在别的地方已被定义。

**通用格式 2.1**：*标准C++程序*

```C++
// A comment
#include-directives
using namespace std;
int main() {
     *statements*
    return 0;
}
```

在上述通用格式中，以加粗字体显示的部分只需照原样编写即可。而*statements*所在的部分表示的是一个不同语句组成的集合。语句是程序所能执行的最小独立操作单元。事实上到目前为止，本章已经介绍到几条语句了。这里需要说明的是，虽然在C++标准中不是必须的，但本书的C++程序都会以`return 0；`结尾。另外，`main`函数的主体部分将会用一对花括号`{ }`框住，每个函数都有这样一个将其中所有代码视为一个整体的结构。

在进入更细节的讨论之前，我们先来看一段语法正确的标准C++程序。请以程序的形式运行一下这段代码，它必须要有一个名为`main`的函数。（*提示：*下面的`std`是standard的缩写。）

```C++
// This program prompts for a name and prints a friendly message
#include <iostream>   // For cout, cin, and endl
#include <string>     // for the string type

using namespace std;  // Allow programmers to write cin and cout
                      // rather than std::cin and std::cout
int main() {
    string name;
    cout << "What is your name: ";
    cin >> name;

    cout << "Hello " << name;

    cout << ", I hope you're feeling well." << endl;
    return 0;
}
```

**程序会话**

```shell
What is your name: ***Casey***
Hello Casey, I hope you’re feeling well.
```

这段源代码将会被输入到编译器中，由编译器将这些源代码转换成机器码。在这过程中，编译器有可能会产生出报错或警告信息。这些错误是编译器在扫描该程序的源代码，以及该程序所有`#include`文件中的附加源代码时被检测到的。例如在上述程序，我们在`int main()`之前引入了一个名为`iostream`的文件，因此该文件中的源代码也成为了这个程序的一部分。在这里，`#include`指令的作用就是用被`#include`文件的内容替换掉该指令所在的文本。

每个C++程序通常都会用到一两个以上的由其他程序员所提供的源码文件。事实上，C++编译器本身就提供了大量的源码文件。下面，我们就来看看将其他文件中的源码加入到自己程序中的通用格式：

**通用格式 2.2**：*`#include`指令*

`#include` <*include-file*>

——或——

`#include` "*include-file*"

在这里，`#include`和尖括号`< >`或双引号`" "`的部分都只需照原样编写即可，只有*include-file*必须是已经存在了的文件名。例如，我们在程序中加入以下`#include`指令，为的就是让其提供`cout`、`cin`和`endl`这三个对象：

```C++
#include <iostream>
```

但是，这个`#include`指令实际上为我们提供的是`std::cout`、`std::cin`和`std::endl`。C++标准库（`iostream`只是它的一部分）是定义一个叫做`std`的名字空间中的，为了避免频繁重复写`std::`，我们通常会在`#include <iostream>`以及其他`#include`指令后面加上下面这行代码：

```C++
using namespace std; // Can now write cout instead of std::cout
```

另外请注意，在`< >`或`" "`之间不能有任何空格。

```C++
#include <iostream > // ERROR, space at end
#include " BankAccount.h" // ERROR, space up front
```

通常，用尖括号`< >`所`#include`的文件应该必然属于系统的一部分，我们的系统应该可以自动遭到这些文件。而被双引号`" "`所`#include`的文件则往往需要被存储到包含它们的程序所在的相同目录中。

### 2.1.1 标记：一个程序的最小零件

在继续介绍对象初始化和语句的通用格式之前，我们希望先带读者来了解一下编程语言中那些用于构建起更大型结构的最小零件。这将有助于我们：

* 更容易在编码时写出语法正确的语句。
* 更好地了解应该如何修复被编译器检出的那些错误。
* 看懂通用格式。

C++编译器读取源代码的过程，实际上就是它在逐一识别其中各种*标记（token）*的过程。标记是一个程序中最小的可识别组件，我们可以将其分成以下四类：

| 标记分类 | 具体示例 |
|----------|---------|
| 特殊符号 | `; ( ) << >>` |
| 关键字 | `return double int` |
| 标识符 | `main test2 firstName` |
| 字面常量 | `"Hello" 507 -2.1 true 'c' nullptr` |

### 2.1.2 特殊符号

*特殊符号*通常是一个由一到两个字符组成的序列，它往往代表着某一种特殊含义（有些也具有多重含义）。在这其中，有像`{`、`;`、`,`这样的用来分割其他语言标记的特殊符号。也有其他像`+`、`-`、`<<`这种属于表达式操作符的。下面列出的是C++程序中一些被使用得比较频繁的单字符和双字符的特殊符号：

```
( ) . + - / * =< >= // { } == ; << >>
```

### 2.1.3 标识符

*标识符*是我们给程序中各种事物赋予的名称，这些名称都要符合以下创建C++标识符的管理规则：

* 标识符只能以小写字母a到z、大写字母A到Z、美元符号`$`以及下划线`_`开头。
* 首字符之后可跟任意数量的大小写字母、数字（0到9)和下划线。
* 标识符区分大小写，例如`Ident`、`ident`和`iDENT`将被认为是三个不同的标识符。

**有效标识符**
| | | | | |
|-|-|-|-|-|
| `main` | `cin` | `incomeTax` |`i`| `MAX_SIZE` |
| `Maine` | `cout` | `employeeName` |`x`| `all_4_one` |
| `miSpelte` | `string` | `A1` |`n`| `$motion$` |

**无效标识符**
| | |
|-|-|
| `1A` | 不能以数字开头 |
| `miles/Hour` | `/`是不可用字符 |
| `first Name` | 不能用空白符 |
| `pre-shrunk` | `-`代表的是减法操作符 |

当然，C++有一个庞大的标准库，它们必然会占用掉一部分的标识符。例如，名为`cin`的对象是用来获取用户键盘输入的，cout也是一个标准库标识符，它是终端输出对象的名称。下面所列出的这几个都是C++标准库所占用的标识符。（*提示：*下面的第一个标识符读作“end-ell”，作用是换行。）

> endl sqrt fabs pow string vector width precision queue

程序员定义的标识符指的是创建该程序的程序员为后续的其他调用者和维护人员提供的标识符。例如`test1`、`finalExam`、`courseGrade`这些是程序员定义的，也就是我们为自己所创建的标识符，所以请务必要用有明确含义的名称来表示它们的用途。

C++语言是严格区分大小写的，大写字母与小写字母代表的是不同的事物，“A”不等同于“a”。例如，每个完整的C++程序中都必须要包含main这个标识符，但MAIN或Main则不必。另外需要注意的是，程序员们在大小写的用法上会存在着一些约定俗成，有些程序员通常会尽量避免使用大写字母，也有些程序员喜欢用大写来表示一些新的词汇。在本书中，我们将采用的是“`camelBack`”这种风格的写法，即将第一个单词之后每个单词的首字母设成大写。例如，我们将使用的是`letterGrade`，而不是`lettergrade`、`LetterGrade`或者`letter_grade`，当然，对此不同的程序员都有各自不同的风格。

### 2.1.4 关键字

*关键字*是一些具有特定用途的标识符，它们是语言标准所定义的保留字，譬如像`int`和`double`这些都属于关键字。

**C++关键字**
| | | | | |
|-|-|-|-|-|
| `break` |`do` | `for` | `operator` | `switch` |
| `case` | `double` | `if` | `return` | `typedef` |
| `char` | `else` | `int` | `sizeof` | `void` |
| `class` | `float` | `long` | `struct` | `while` |

C++区分大小写的特性也同样适用于关键字。例如`double`（这是关键字）与`Double`（这不是关键字）是不同的，C++的关键字始终为小写。

### 2.1.5 注释

*注释*是程序中用于注解的一部分文本，我们对注释通常有以下预期（可能是其中任意一种，也可能是全部）：

* 用于充当内部文档，辅助程序员读懂其他程序员所写的程序。当然，前提是这些注释确实澄清了程序中存在的歧义。
* 用于解释某段代码或某个对象的具体用途。
* 用于著名程序员的姓名和开发该程序的目的。
* 用于描述该程序中涉及到的各种元素和其他要考虑的因素。

注释可以被添加在程序中的任何地方，可以是所有C++语句的右侧，也可以自行单独一行或若干行，它们通常先以`/*`这两个特殊字符开头，最后再以`*/`收尾。

```C++
/*
A comment may
extend over
several lines
*/
```

除此之外，注释的另一种形式是在相关的文本之前加上`//`，这种注释同样既可以是自行单独一行，也可以被附加在某一行的后面：

```C++
// A complete C++ program
int main() {
    return 0; // This program returns 0 to the operating system
}
```

在本书所涉及的这些程序中，我们对单行注释通常会采用`// Comment`而不是`/* Comment */`。原因是`/*`之后一直到`*/`之前的所有代码都会被视为一段注释，只要我们不慎忘记了在注释结尾加上一个`*/`，就会意外地让一大段代码变成注释。而单行注释就很难造成这种大段代码变成注释的情况。

这里需要提醒的是，我们添加注释的目的是为了澄清和记录源代码的用途，以便让程序更容易被理解，更容易被调试（纠正错误）以及更易于维护（并在必要时做些修改）。很多时候，程序员们需要依靠这些注释来理解一些几天前、几周前、几个月前、几年前乃至于几十年前写的程序。

### 2.1.6 C++字面常量

C++编译器可以自行识别字符串类型、整数类型、布尔类型（`true`/`false`）和浮点类型的字面常量。其中，*字符串类型常量*是由双引号括起来的0个或多个字符，并且所有字符都必须在同一行以内。

```shell
"Double quotes are used to delimit string constants."
"Hello, World!"
```

除此之外，*整数类型常量*是不带小数点的数字，*浮点数类型常量*是用小数点或科学计数法书写的常量(例如$5e3 = 5 * 10^3 = 5000.0$和$1.23e-4 = 1.23 * 10^{-4} = 0.000123$)，*布尔类型常量*即`true`和`false`。下面这些C++类型及其相应的常量示例是我们在本书会经常用到的常量对象。

| 类型 | 常量示例 |
|------|------------------|
| `int`  | `0` `1` `999` `-999` `-2147483647` `2147483647` |
| `char` | `'a'` `'#'` `'9'` `'\t'`（制表符） `'\n'`（换行符）|
| `double` | `1.23` `0.5` `.5` `5.` `2.3456e9` `1e-12` |
| `bool` | `true false` |
| `string `| `"Double quoted"` `"Kim's"` `"\n"` `""`（空字符串）|

```C++
// Print a few C++ literals
#include <iostream>  // For cout and endl
using namespace std;

int main() {
    cout << 123 << endl;
    cout << 'a' << '\t' << 'm' << endl;
    cout << 1.23 << endl;
    // true prints as 1 and false as 0
    cout << true << " and " << false << endl;
    cout << "Hello \n world" << endl;

    return 0;
}
```

**程序输出**

```shell
123
a   m
1.23
1 and 0
Hello
 world
```

**自检题**

2-1 在前面的程序中，我们使用了多少特殊符号？

2-2 请列出下面的有效标识符，并解释其余标识符无效的原因。
| | |
|-|-|
| `a.  abc`  | `l.  H.P.` |
| `b.  123`  | `m.  double` |
| `c.  ABC`  | `n.  55_mph` |
| `d.  #include` | `o.  sales Tax` |
| `e.  my Age`   | `p.  main` |
| `f.  #define`  | `q.  a` |
| `g.  Abc!`     | `r.  å)` |
| `h.  identier` | `s.  ___1___` |
| `i.  (identier)` | `t.  Mile/Hour` |
| `j.  Double`     | `u.  os` |
| `k.  mispellted` | |

2-3. 请列举出两个单字符的特殊符号。

2-4. 请列举出两个双字符的特殊符号。

2-5.  请列举出两个属于标准库的标识符。

2-6.  请创建两个由程序员定义的标识符。

2-7.  对于以下标记：

`'\n'` `false` `234` `1.0` `'H'` `"'"` `-123` `1.0e+03` `"H"` `true`

a. 哪些属于有效的字符串类型常量？

b. 哪些属于有效的整数类型常量？

c. 哪些属于有效的浮点数类型常量？

d. 哪些属于有效的布尔类型常量？

e. 哪些属于有效的字符类型常量？

2-8. 以下哪些属于有效的C++注释？

a.  `// Is this a comment?`

b.  `/ / Is this a comment?`

c.  `/* Is this a comment?`

d.  `/* Is this a comment? */`

## 2.2 语句

*声明（declaration）*语句的作用是将一个或多个对象的名称引入到程序中，而*初始化（initialization）*语句的作用除了将对象的名称引入到程序中的之外，还附带着会按照程序员意图为该对象设置一个初始*值*。而程序员们会在之后对它们的当前值有兴趣或者需要修改那些值时使用到这些变量名。下面我们就来看看声明或初始化一个基本类型和复合类型变量的通用格式：

**通用格式 2.3**：*声明语句（某些类型自身会具有一个默认初始化状态）*

> *type identier* ;

**通用格式 2.4**：*初始化语句（声明一个变量并赋予它一个值）*

> *type identier* = *initial-state* ;

这里的*type*既可以是一个浮点数类型`double`，也可以是一个像`string这样的用于存储一组字符的复合类型（事实上，现有的其他复合类型还有很多）。

在下面的代码中，我们声明了一些变量。也初始化了一些变量。请注意，每一条语句都要以分号（`;`）结尾。

```C++
int credits; // credits is some random integer
double points; // > credits is some random oating point number
double GPA = 0.0; // GPA is initialized to 0.0
bool boolOne; // boolOne could be either true or false
bool boolTwo = true; // boolOne is true
string firstName; // firstName is the empty string ""
string middleName = "James"; // middleName.length() is 5
string lastName = "Potter"; // lastName.length() is 6
```

这里需要指出的是，`int`、`double`、`bool`这些基本类型在行为上与`string`其他复合类型之间有着若干的不同之处。数字类型在被声明时，它们的初始值通常是未知的，而`string`对象在没有被显式初始化的情况下也会有一个空字符串`“”`来充当其默认的初始值。

下面这张表总结了上述对象的初始状态，如你所见，其中有些对象属于未知状态。这些变量被声明了，但未被初始化。它们的值事实上就是该程序运行时其所在内存中的内容。这也就是说，这些变量在不同的程序运行期间会有不同的值。

| 变量名称 | 对象状态 |
|----------|--------|
| `credits` | 未知 |
| `points` | 未知 |
| `boolOne` | 未知 |
| `boolTwo` | `true`（可能还会打印出1）|
| `GPA` | `0.0` |
| `fistName`  | `""` |
| `middleName` | `"James"` |
| `lastName`   | `"Potter"` |

### 2.2.1 `cout`输出语句

程序与其用户之间的通信，通常是通过键盘输入和屏幕输出来完成的。虽说并不只局限于这两种方式，但在本书中，它们是我们许多编程项目的关键组成部分。

**通用格式 2.5**： *`cout`语句*

> `cout <<` *expression-1* `<<` *expression-2* , . . . ,`<<` *expression-n* `<< endl`;

在这里，对象名`cout`（读作“see-out”，是**c**ommon **out**put的简写形式）表示我们将把信息输出到控制台中。然后，从*expression-1*到*expression-n*这部分格式具体既可以是`GPA`和`firstName`这样的对象名称，也可以是`"Credits: "`和`99.5`这样的常量。接下来是操作符`<<`，它代表了数据流动的方向。最后，每一条语句都要以一个分号（`;`）结尾。下面，我们来看一些使用了`endl`这个标识符（读作“end-ell”)的合法输出语句，如你所见，该标识符的作用是换行。

```C++
cout << 99.5 << endl;
cout << "Show me literally too" << endl;
cout << "First Name: " << firstName << endl;
cout << "Credits: " << credits << endl;
```

当一条`cout`语句被执行时，其相关的表达式就被插入到了一条导向计算机屏幕的数据流中。这些表达式的输出顺序与它们在语句中出现的顺序是相同的，也就是从左向右的顺序。当它们遇到`endl`这个表达式时，就会另起一行，因此后续的输出会从新的一行开始。

```C++
cout << 'A' << " line " << true << " " << 123 << 4.56 << endl;
```

**程序输出**

```shell
A line 1 1234.56
```

**自检题**

2-9 请初始化两个用来表示数字的对象，并将它们的初始值设为-1.5。

2-10 请声明一个可以用来表示某一条街道地址的对象，并将其命名为`address`。

2-11 请编写一个完整的C++程序，用它来逐行显示你在程序中用过的所有名称。

### 2.2.2 赋值与类型转换

*赋值（Assignment）*语句的作用是设置对象的状态，它会用`=`右边表达式的值替换掉`=`左边对象中的值。

**通用格式 2.6**：*赋值语句*

> *object-name* **=** *expression*;

在这里，`expression`必须得是一个可以被存储到赋值操作符（`=`）左边对象中的值。例如，表达式产生的浮点数结果可以存储到一个数字类对象中，字符串表达式（即一组用双引号`“”`括住的字符）可以存储到字符串类型的对象中。下面就让我们再来看几个赋值语句的示例：

```C++
double aNumber = -999.9;
string aString = "Initial state";

aNumber = 456.789;
aString = "Modified state";
```

在上面这四个赋值操作被执行完之后`【译者注：原文如此，但事实上前两句执行的应该是初始化操作，在后续章节中我们应该会了解到，初始化操作调用的是对象的构造函数，而赋值操作调用的是operator=（），两者是完全不同的语法元素。】`，两个对象的状态都被修改过了，它们当前的状态如下表所示：

| 对象 | 状态 |
|-----|------|
| `aNumber` | `456.789` |
| `aString` | `"Modified State"` |

另外，`=`右边的值必须要与左边的变量类型是赋值兼容（assignment-compatibl），只有这样赋值操作才能正常执行。例如，一个`string`常量是不能被赋值给一个数字型变量的。

```C++
aNumber = "Ooooohhhh no, you can't do that"; // ERROR
```

同样的，一个`double`常量也不能被赋值给一个`string`对象。

```C++
aString = 12.34; // ERROR
```

通常情况下，编译器对上面这样的赋值语句是会报错的。但是，如果某个对象的类型可以被另一个对象的类型接受，编译器就会自动对其执行*类型转换（type conversions）*操作，这时候就没有任何警告和报错信息了，只是相关变量可能会被赋予一个意外的值。

```C++
char c = 65;      // c becomes 'A'
bool b = 0;       // b becomes false
b = 42;           // b becomes true, actually 1
int n = b;        // n becomes 1, the integer for true
n = 5.9999;       // n becomes 5 due to truncation
double x = n;     // x becomes 5.0, but prints as 5
long l = n;       // l becomes 5, int promotes to long
```

**自检题**

2-12 针对在上述代码中被初始化的变量，以下哪些赋值操作会被报错？

| | |
|-|-|
| `a.  b = -123;` | `d.  l = x;` |
| `b.  n = 123.495678;` | `e.  c = 66;` |
| `c.  x = 123;` | `f.  ui = "abcde";` |

我们需要对哪些没有意义的对象值保持警戒，因为这些值可能会带来一些不可预知的错误，我们得要确保自己定义的所有对象都经过了初始化、赋值或键盘输入的设置。另外，我们一样要对类型转换保持警戒，因为一旦转换出错，就会产生出完全不同的结果值，这种情况在无符号类型与有符号类型混合使用时经常发生，所以最好不要这样做。总而言之，如果想在程序中正确地使用一个对象，我们的操作必须兼顾以下三个特征：

* 对象必须被赋予一个经过声明或初始化的名称。
* 对象必须被声明某个特定类型的实体。
* 在某些节点上，对象必须要被赋予一个有具体意义的值。

### 2.2.3 `cin`输入语句

为了让程序具有更好的通用性（譬如现在我们要查找任意一名学生的课程成绩），其对象状态通常就需要交由键盘输入来设置。这样就可以让用户输入任何他所需的数据了，这种输入是由名为`cin`（读作“see-in”，是**c**ommon **in**put的简写形式）的输入流对象及其操作符`>>`来提供的，例如在下面的语句中，我们将两个对象的状态修改成了由用户提供的数据：

```C++
cin >> firstName;     // User must input a string
cin >> credits;       // User must input a number
```

下面我们来看一下`cin`输入语句的通用格式：

**通用格式 2.7**： *`cin`语句*

> `cin >>` *object-name* ;
>
>——或——
>
> `cin >>` *object-name-1* `>>` *object-name-2* `>>` *object-name-n*;

这里的*object-name*必须是一个可接受键盘输入值的类实体。这本书中的许多对象定义（当然，不是所有）采用的就是这种形式，我问问会用`cin`输入来定义`int`、`double`、`string`这些类型的对象。

当一条`cin`语句被执行时，程序就会暂停执行，等用户输入完相关的值并按下回车键之后再继续。如果一切顺利的话，这些被输入的值将会被转换成相对应的机器形态，并被存储为相关对象的状态。

除了回车键之外，被输入数据也会被一个或多个空格符分隔开来。这就会让程序在读取带空格符的字符串时遇到一些麻烦，譬如说，对于一个人全名和地址，我们通常会这样编写代码：

```C++
string name;
cout << "Enter your name: ";
cin >> name;
```

然后我们会与该程序进行如下会话：

```shell
Enter your name: ***Kim McPhee***
```

这时候被存入`name`的是`Kim`，而不是我们所期望的`Kim McPhee`。`Kim`后面的空格符终止了这一次的输入内容。所以，如果我们想读取一行中所有的字符（包括空格符），这里需要执行的是`getline`操作：

```C++
getline(cin, name);
```

我们也可以编写可依次输入多个对象的`cin`语句。当然，在这样做的时候，我们必须要假设用户知道如何用空格符（敲空格键）、换行符（敲回车键）或制表符（敲`TAB`键）将这些对象分隔开。下面我们来演示一下各种分隔输入数据的方式：

```C++
#include <iostream>
using namespace std;

int main() {
    int a, b, c, d;
    cout << "Enter four integers: ";

    // Just need to separate input by a space, tab, or new line.
    cin >> a >> b >> c >> d;
    cout << a << endl;
    cout << b << endl;
    cout << c << endl;
    cout << d << endl;
    return 0;
}
```

**以下是该程序三种可能的会话过程：**

| Enter four integers:  | Enter four integers: | Enter four integers: ***1*** |
|-----------------------|----------------------|------------------------------|
| 1 2 3 4               | 1 2                  |  2                           |
| 1                     |                      |  3                           |
| 2                     | 3                    |  4                           |
| 3                     |                      |  1                           |
| 4                     | 4                    |  2                           |
|                       | 1                    |  3                           |
|                       | 2                    |  4                           |
|                       | 3                    |                              |
|                       | 4                    |                              |

让这件事简单化的替代方案就是为每一次输入单独写一条`cin`语句。

## 2.3 算术表达式

本章的许多问题事实上都是在让我们编写算术表达式。算术表达式通常由运算符和操作数两部分组成。其中，*运算符*通常指的就是C++那些特殊符号`+`、`-`、`/`、`*`中的某一个。而*操作数*既可以是像之前`test1`这样的数字类对象，也可以是像`0.25`这样的数字常量。下面我们假设x是一个`double`类型的实体，那么在以下表达式的操作数就是`x`和`0.25`，运算符就是`+`。

    x + 4.5

运算符和操作数将共同决定该算术表达式的值。

算术表达式最简单的形式就单纯一个数字常量或数字类对象的名称，不过它也可以是两个操作数加一个运算符的形式（如下表所示）：

| 算术表达式的形式       | 具体示例 |
|---------------------|---------|
| *数字类对象*          | `x`     |
| *数字类常量*    | `100`或`99.5` |
| *表达式* + *表达式* | `x + 2.0` |
| *表达式* - *表达式* | `x - 2.0` |
| *表达式* * *表达式* | `x * 2.0` |
| *表达式* / *表达式* | `x / 2.0` |
| ( *表达式* )     | `(x + 2.0)` |

上面定义的这些表达式还可以有更复杂的算术表达式，例如：

```C++
1.5 * ((x - 99.5) * 1.0 / x)
```

由于算术运算符的编写通常会用到多个常量、数字类对象的名称和运算符，所以其执行规则得要符合一般性表达式求值的需要。下表中列出了五个C++算术运算符，以及它们操作数字类对象的顺序。

**二元算术运算符**

| 运算符 | 处理规则 |
|-------|---------|
| `*`、`/`、`%` | 在没有括号的情况下，乘法、除法以及取模（%）这三种运算符的求值是先于加法与减法的。换句话说，就是`*`、`/`和`%`（对`int`取模）的优先级要高于`+`和`-`，如果这些运算符在同一个表达式中出现了不止一个，则从最左边的那个开始求值。|
| `+`、`-` | 在没有括号的情况下，`+`与`-`这两种运算符的求值要在所有的`*`、`/`、`%`运算完成之后才会执行，顺序也是从左边开始。当然，括号可以覆盖掉以上这些处理规则。|

譬如，以下表达式作用在操作数上的操作应该依次是：`/`、`+`、`-`。

```C++
2.0 + 5.0 - 8.0 / 4.0 // Evaluates to 5.0
```

下面我们用括号来改变一下该表达式操作其在其操作数上的顺序。

```C++
(2.0 + 5.0 - 8.0) / 4.0;    // Evaluates to -0.25
```

在加了括号之后，`/`运算符现在是最后一个被求值的，而不是第一个。

以上这些处理规则针对的只是二元运算符。*二元运算符*的左右两侧通常各有一个操作数。下面我们来看只在右侧有操作数的*一元运算符*，先来看一个同时包含了二元运算符（`*`）和一元负值运算符的表达式(`-`)：

```C++
3.5 * -2.0 // Evaluates to -7.0
```

如你所见，一元运算符的求值要先于二元运算符（`*`)：即3.5乘以负2.0（即-2.0），结果为负7.0（即-7.0）。

当然，算术表达式通常是以对象名为操作数的，但C++对一个`double`对象的表达式进行求值时，这些对象名会被他们的状态所替代，请看下面这段代码：

```C++
double x = 1.0;
double y = 2.0;
double z = 3.0;

double answer = x + y * z / 4.0;
```

当程序运行时，被存储在变量中的值会被检索出来，我们得到的实际上是下面这个等效的表达式：

```C++
double answer = 1.0 + 2.0 * 3.0 / 4.0; // store 2.5 into answer
```

**自检题**

2-13 请对以下算术表达式进行求值：

```C++
double x = 2.5;
double y = 3.0;
```

* a.  `x * y + 3.0`
* b.  `0.5 + x / 2.0`
* c.  `1 + x * 3.0 / y`
* d.  `1.5 * (x - y)`
* e.  `y + -x`
* f.  `( x - 2) * (y - 1)`

### 2.3.1 整数算术运算

The C++ language provides several numeric types. Perhaps the two most often used are double and int. An int object represents a limited range of whole numbers. There are times when int is the correct choice over double. An int object has operations similar to double (+, \*, -, =, <<, >>), but some diff erences do exist. For example, a fractional part cannot be stored in an int object. The fractional part is lost during an assignment statement.

```C++
int anInt = 1.999; // The state of anInt is 1, not 1.999
```

The / operator has diff erent meanings for int and double operands. Whereas the result of 3.0 / 4.0 is 0.75, the result of 3 / 4 is 0. Two integer operands with the / operator have an integer result—not a fl oating-point result. So what happens? An integer divided by an integer results in the integer quotient. For example, the quotient obtained from dividing 3 by 4 is 0. This implies that the same operator (/ in this case) has a different meaning when it has two integer operands.

Another difference is that int objects have a remainder operation symbolized by the % operator. For example, the result of 18 % 4 is the integer remainder after dividing 18 by 4, which is 2. These differences are illustrated in the following program, which shows % and / operating on integer expressions and / operating on floating-point operands. In this example, the integer results describe whole hours and whole minutes rather than the fractional equivalent.

2.3: Arithmetic Expressions

```C++
// This program provides an example of int division with '/' for
// the quotient and '%' for the remainder
#include <iostream>
using namespace std;

int main() {
    // Declare objects that will be given meaningful values later
    int totalMinutes, minutes, hours;
    double fractionalHour;

    // Input
    cout << "Enter total minutes: ";
    cin >> totalMinutes;

    // Process
    fractionalHour = totalMinutes / 60.0;
    hours = totalMinutes / 60;
    minutes = totalMinutes % 60;

    // Output
    cout << totalMinutes << " minutes can be rewritten as "
         << fractionalHour << " hours " << endl;
    cout << "or as " << hours << " hours and "
         << minutes << " minutes" << endl;

    return 0;
}
```

**Dialogue**

```shell
Enter total minutes: 254
254 minutes can be rewritten as 4.23333 hours
or as 4 hours and 14 minutes
```

The preceding program indicates that even though int objects and double objects are similar, there are times when double is the more appropriate class than int, and vice versa. The double class should be specified when you need a numeric object with a decimal component. If you need whole numbers, select the int class. Also, once the class is chosen, you should consider the diff erences in some of the arithmetic operators. For example, although the +, -, /, and \* operations can be applied to double operands, the % operator may only be used with two integer operands.

**SELF-CHECK**

2-14 What value is stored in nickel?

```C++
int change = 97;
int nickel = 0;
nickel = change % 25 % 10 / 5;
```

2-15 What value is stored in nickel when change is initialized to:

| | |
|-|-|
| `a.   4` | `d.   15` |
| `b.   5` | `e.   49` |
| `c.   10`| `f.   0`  |

### 2.3.2 MIXING INTEGER AND FLOATING-POINT OPERANDS

Whenever integer and floating-point values are on opposite sides of an arithmetic operator, the integer operand is promoted to its floating-point equivalent (3 becomes 3.0, for example). Th e expression then results in a floating-point number. Th e same rule applies when one operand is an int object and the other a double.

```C++
// Display the value of an expression with a mix of operands
#include <iostream>
using namespace std;

int main() {
    int n = 10;
    double sum = 567.9;

    // n will be promoted to a double and use the oating point
    cout << (sum / n) << endl;

    return 0;
}
```

**Output**

56.79

**SELF-CHECK**

2-16 Evaluate the following expressions:

| | |
|-|-|
| `a.   5 / 9` | `d.   2 + 4 * 6 / 3` |
| `b.   5.0 / 9` | `e.  (2 + 4) * 6 / 3` |
| `c.   5 / 9.0` | `f.  5 / 2` |

### 2.3.3 CONSTANT OBJECTS

The state of any object can be, and usually is, altered during program execution. However, it is sometimes convenient to have data with values that cannot be altered during program execution. C++ provides the keyword const for this purpose. Constant objects are created by specifying and associating an identifi er with a value preceded by the keyword const. In essence, this is an object whose state cannot be changed through assignment or stream extraction operations. The general form used to initialize a constant object is a combination of an initialization preceded by the keyword const. Const objects are usually written in upper case.

**General Form 2.8** *Initializing a constant object*

> const *type* *IDENTIFIER* = *expression*;

For example, the value stored in the constant object PI is the floating-point number 3.1415926, and TAX\_RATE is 7.51%.

```C++
const double PI = 3.1415926;
const double TAX\_RATE = 0.0751;
const string PAUSE\_MESSAGE = "Press any key to continue . . .";
```

These constant objects represent values that cannot be changed while the program is executing; therefore a statement such as PI = PI \* r \* r; generates an error because PI is declared as constant. The value cannot be destroyed with an input statement such as cin &gt;&gt; PI;.

## 2.4 PROMPT THEN INPUT

The output and input operations are often used together to obtain values from the user of the program. Th e program informs the user what must be entered with an output statement and then performs an input operation to set the state of the object. Th is happens so often that this activity can be considered to be a pattern. The Prompt then Input algorithmic pattern has two activities:

1. Ask the user to enter a value (prompt).

2. Obtain the value for the object (input).

| Algorithmic Pattern | Prompt then Input |
|---------------------|-------------------|
|  **Pattern:**       | Prompt then Input |
|  **Problem:**       | The user must enter something |
|  **Outline:**       | 1.  Prompt the user for input
                        2.  Obtain the input |
|  **Code Example:**  | `cout << "Enter your first name: "; cin >> firstName;` |

Strange things can happen if the prompt is left out. The user will not know what must be entered. So whenever you require user input, make sure you prompt for it fi rst. Write the code that tells the user precisely what you want. First output the prompt, then obtain the user input.

Here is one instance of the Prompt then Input pattern:

```C++
cout << "Enter test \#1: ";
cin >> test1;
```

and another:

```C++
cout << "Enter credits: ";
cin >> credits;
```

In general, tell the user the value needed, then read it in with cin.

```C++
cout << "the prompt for the\_object: ";
cin >> the\_object;
```

The following program uses the Prompt then Input pattern four times. It also reviews operations such as object initialization, assignment, input, and output. Th is program illustrates a more general approach to computing any grade point average. By requesting input data from the user, it can be used over and over again with diff erent sets of input to produce diff erent results. Also notice the presence of the IPO pattern in the implementation.

```C++
// This program uses input statements to produce a meaningful
// result that can be used in a variety of examples
#include <iostream>  // For input and output
#include <string>    // For the string class
using namespace std;

int main() {
    // 0. Initialize some objects
    double credits = 0.0;
    double points = 0.0;
    double GPA = 0.0;
    string firstName;
    string lastName;

    // 1. Input
    cout << "Enter first name: ";
    cin >> firstName;
    cout << "Enter last name: ";
    cin >> lastName;
    cout << "Enter credits: ";
    cin >> credits;
    cout << "Enter points: ";
    cin >> points;

    // 2. Process
    GPA = points / credits;

    // 3. Output
    cout << "Name : " << firstName << " " << lastName << endl;
    cout << "Credits : " << credits << endl;
    cout << "Points : " << points << endl;
    cout << "GPA : " << GPA << endl;

    return 0;
}
```

**Dialogue**

```shell
Enter first name: Pat
Enter last name: McCormick
Enter credits: 97.5
Enter points: 323.75
Name : Pat McCormick
Credits : 97.5
Points : 323.75
GPA : 3.32051
```

Care must be taken when entering numeric data. If you enter a non-digit instead of valid numeric input, the input object cin may no longer be in a “good” state and all subsequent cin statements will be ignored.

**SELF-CHECK**

2-17 Write the value for GPA given each of the dialogues shown below.

```C++
// This program uses input statements to produce a
// meaningful result that can be used for a variety of examples
#include <iostream>  // For cin, cout, and endl
#include <string>    // For the string class
using namespace std;

int main() {
    // 0. Initialize some numeric objects
    double c1 = 0.0;
    double c2 = 0.0;
    double g1 = 0.0;
    double g2 = 0.0;
    double GPA = 0.0;
    // 1. Input
    cout << "Credits for course 1: ";
    cin >> c1;
    cout << " Grade for course 1: ";
    cin >> g1;
    cout << "Credits for course 2: ";
    cin >> c2;
    cout << " Grade for course 2: ";
    cin >> g2;
    // 2. Process
    GPA = ( (g1*c1) + (g2*c2) ) / (c1+c2);
    // 3. Output
    cout << "GPA: " << GPA << endl;
    return 0;
}
```

Dialogue 1:

```shell
Credits for course 1: 2.0
Grade for course 1: 2.0
Credits for course 2: 3.0
Grade for course 2: 4.0

a.  ________GPA
```

Dialogue 2:

```shell
Credits for course 1: 4.0
Grade for course 1: 1.5
Credits for course 2: 1.0
Grade for course 2: 3.5

a.  ________GPA
```

Dialogue 3:

```shell
Credits for course 1: 1.0
Grade for course 1: 2.0
Credits for course 2: 4.0
Grade for course 2: 3.0

a.  ________GPA
```

## 2.5 IMPLEMENTATION ERRORS AND WARNINGS

There are several types of errors and warnings that occur during the implementation phase of problem solving:

* compile time—errors that occur during compilation
* warnings—code that is risky, suggesting there may be a future error
* linktime—errors that occur when the linker cannot fi nd what it needs
* runtime—errors that occur while the program is executing
* intent—the program does what was entered, not what was intended

![图2-1](img/2-1.png)

### 2.5.1 ERRORS AND WARNINGS DETECTED AT COMPILE TIME

A programming language requires strict adherence to its own set of formal syntax rules. As you have probably noticed, it is easy to violate these syntax rules while translating algorithms into their programming language equivalents. All it takes is a missing { or ; to really foul things up. As the C++ compiler translates source code into code that can run on the computer, the compiler

* locates and reports as many errors as possible
* warns of potential problems that are syntactically legal, but might cause errors later

A compile time error occurs when the C++ compiler recognizes the violation of a syntax rule. The machine code cannot be created until all compile time errors have been removed from the program. If the machine code is not created, the linker cannot create an executable program. Many strange-looking error messages will be generated by the compiler as it reads the source code. Unfortunately, deciphering these compile time error messages takes practice, patience, and a reasonable knowledge of the C++ programming language. So in an eff ort to improve this situation, here are some examples of common compile time errors you will soon see and explanations of how they are corrected. (*Note:* Your compiler will generate diff erent error messages.)

| Error Detected by a Compiler | Incorrect Code | Corrected Code |
|------------------------------|----------------|----------------|
| Splitting a variable name | int Total Weight; | int totalWeight; |
| Misspelling a name   | integer sum = 0 ; | int sum ; |
| Omitting a semicolon | double x | double x; |
| Not closing a string | `cout << "Hello;` | `cout << "Hello";` |
| Failing to declare the variable | `cin >> testScore;` | `double testScore; cin >> testScore;` |
| Ignoring case sensitivity | `double X; X = 5.0;` | `double x; x = 5.0;` |
| Forgetting an argument    | `cout << sqrt;` | `cout << sqrt(x);`
| Using wrong type   | `cout << sqrt("12");` | `cout << sqrt(12.0);` |
| Using too many arguments | `cout << sqrt(1.2, 3);` | `cout << sqrt(1.2);` |
| Forgetting namespace std; |`// cout is unknown` | `using namespace std;` |

Compilers generate many error messages. However, it is your source code that is the source of these errors. Whenever your compiler appears to be nagging you, remember that the compiler is trying to help you correct your errors as much as possible. Th e compiler is your friend.

The following code shows several errors the compiler should eventually detect and report. Because error messages generated by compilers vary among systems, the comments here indicate the reason for the error—they are not an attempt to match compile time error messages for any particular compiler (and there are many compilers).Your system will certainly generate quite different error messages.

```C++
// This attempt at a program contains many errors--over a
// dozen. Add #include <iostream> and there are only eight.
using namespace std;

int main { // 1. No () after main.
           // 2. Every cin and cout will generate an error
           // because #include <iostream> is missing.
    int pounds;

    cout << "Begin execution" << endl // Missing ; after endl
    cout >> "Enter weight in pounds: "; // >> should be <<
    cin << pounds; // << should be >>
    cout << "In the U.K., you"; // Extra ;
         << " weigh " << (Pounds / 14) // Pounds is not declared
         << " stone. " << endl // Missing ;
    return 0; // Missing right brace }
```

Compilers can generate some rather cryptic messages. When the program shown above compiled with one particular compiler, six errors occurred (other compilers found seven and two), all reporting a type name was expected. Other systems generate a diff erent crop of errors. Another Unix compiler generated eight completely diff erent errors. Compile time error messages take some getting used to, so try to be patient and observe the location where the compile time error occurred. The error is usually in the vicinity of the line where the error was detected, although you may have to fi x preceding lines. Always remember to fi x the fi rst error fi rst. Th e error not reported until line 23 may be the result of a forgotten semicolon on line 4.

The corrected source code, without error, is given next, followed by an interactive dialogue:

```C++
// There are no compile time errors in this program
#include <iostream>
using namespace std;

int main() {
    int pounds;

    cout << "Begin execution" << endl;
    cout << "Enter your weight in pounds: ";
    cin >> pounds;
    cout << "In the U.K., "
         << "you weigh " << (pounds/14.0) << " stone." << endl;

    return 0;
}
```

**Dialogue**

```shell
Begin execution
Enter your weight in pounds: 162
In the U.K., you weigh 11.5714 stone.
```

It should also be noted that one small compile time error can result in a cascade of errors. For example, omitting { after int  main() in an otherwise error-free program caused the Clang C++ compiler to generate 11 compile time errors!

```C++
#include <iostream>   // For cin and cout
#include <string>     // For the string class
using namespace std;

int main() // <- Without the left curly brace, there were 11 errors!
    double x;
    string str;
    cout << "Enter a double: ";
    cin >> x;
    cout << "Enter a string: ";
    cin >> str;
    return 0;
}
```

**Compile time error messages from one compiler**

```shell
main.cpp:5:11: error: expected ';' after top level declarator
main.cpp:9:3: error: unknown type name 'cout'
main.cpp:9:8: error: expected unquali ed-id
main.cpp:10:3: error: unknown type name 'cin'
main.cpp:10:7: error: expected unquali ed-id
main.cpp:11:3: error: unknown type name 'cout'
main.cpp:11:8: error: expected unquali ed-id
main.cpp:12:3: error: unknown type name 'cin'
main.cpp:12:7: error: expected unquali ed-id
main.cpp:13:3: error: expected unquali ed-id
main.cpp:14:1: error: expected external declaration
```

The SunOS C++ compiler reported one error, which is more decipherable:

```shell
 "{" expected not double
```

So it is possible that fi xing the fi rst error might correct many other errors. It is also true that fi xing one error might let the compiler fi nd new ones! Try to concentrate on the fi rst error your compiler reports. Th e compiler usually, but not always, will be able to approximate the location of the error in your source code. The error may be on the line above, or many lines above.

Also, realize that all statements must be terminated by a semicolon “;”. Excluding this statement terminator, or putting it in where it doesn’t belong, causes compile time errors. Missing semicolon errors are not usually detected until the compiler has already gone past the line with the offense, so look at the statement above the location of the error.

### 2.5.2 WARNINGS GENERATED AT COMPILE TIME

Compilers also generate warnings, which are messages intended to help programmers avoid errors later on. Consider the following code:

```C++
#include <iostream>
using namespace std;

int main() {
    double x, y;
    y = 2 * x;
    cout << y << endl;
}
```

**SELF-CHECK**

2-18 What is the output of the preceding program?

The preceding program has an error, but none that the compiler will catch. Th e compiler happily translated the source code into machine code and the linker created an executable program. However, the output from two program runs were the rather inexplicable numbers 1.09087e+82 and later 1.39064e-309. With another compiler, the output was 0. Fortunately some compilers generate warnings like these:

```shell
Warning: Possible use of 'x' before de nition in main()
Warning: 'x' is used uninitialized in this function
```

The warning states that x has been used before it was defined (initialized, actually). Th is is a good warning that should not be ignored. Th e program does not initialize x. It has an unknown state  sometimes referred to as garbage. Unfortunately, not all compilers will warn you of this potential error.

This is not a violation of any C++ rule. It is legal to declare a variable without an initial value. However, this warning should not be ignored. You should read it and make sure x has an initialized state before using the object in an arithmetic expression.

This is but one example of a warning. You will see more. You will likely ignore many. However, warnings are hints that something may go wrong and the program will not be correct. If you are getting incorrect results, look to see if there are any warnings—they may be clues to the source of the error.

### 2.5.3 LINKTIME ERRORS

Computer systems use a linker to combine pieces of machine code to create executable programs. Among other things, the linker must resolve details such as locating the identifi er main in one of these files. If main is not found during the linking process, the linker generates an error that displays main is an undefi ned symbol. If this takes place, verify that your program starts with int main.

```C++
int main() {
    // . . .
}
```

Make sure that main is not typed as mane, Main, or MAIN.

Another linktime error occurs when you have two fi les with the required int main(). For example, you may soon try to have two programs in the same folder when completing programming projects. The following linktime error message indicates initials.cpp and average.cpp both had int main() functions in the same directory named src:

```shell
ld: duplicate symbol main () in ./src/initials.o and ./src/average.o
```

One solution is to not link both of them. But if you are using an integrated development environment such as Eclipse, Visual Studio, or XCode, make sure you have only one fi le in your project with the main method.

### 2.5.4 RUNTIME ERRORS

A program may execute after all compile time errors have been removed and the linker has created an executable program. But errors may still occur while the program is running. A runtime error may cause the program to terminate before it should because some event occurs that the computer cannot handle.

For example, when your program is expecting an integer, and the user enters a fl oating-point number, the input stream cin becomes  corrupted. Consider the same program run twice, the fi rst time with good input and once with “bad” input; a fl oating-point number such as 1.2 instead of an integer.

```C++
#include <iostream>
using namespace std;

int main() {
    int anInt, anotherInt;

    cout << "Enter anInt: ";
    cin >> anInt;
    cout << "anInt: " << anInt << endl;

    cout << "Enter anotherInt: ";
    cin >> anotherInt;
    cout << "anotherInt: " << anotherInt << endl;

    return 0;
}
```

With good input, the user can enter two integers:

```shell 
Enter anInt: 7
anInt is 7
Enter anotherInt: 9
anotherInt is 9
```

With non-integer input, 1.2 cannot be assigned to an int, so it is not. Th en the second input is not allowed and the user cannot even try to enter a number (the output of 0 will vary since anotherInt is undefined):

```shell
Enter anInt: 1.2
anInt: 1
Enter anotherInt: anotherInt: 0
```

### 2.5.5 INTENT ERRORS

Even when no compile time errors are found and no runtime errors occur, the program still may not execute properly. A program may run and terminate normally, but it may not be correct. Let’s make one small change to an earlier program to get an incorrect program.

    cout << "Average: " << (n / sum);

The interactive dialogue may now look like this:

```shell
Enter sum: 291
Enter n: 3
Average: 0.010309
```

Such intent errors occur when the program does what was typed, not what was intended. Unfortunately, the compiler does not locate intent errors. Th e expression n/sum is syntactically correct—the compiler just has no way of knowing that this programmer intended to write sum/n instead.

Intent errors are the most insidious and usually the most difficult to correct. Th ey may also be diffi cult to detect—the user, tester, or programmer may not know they even exist.

**SELF-CHECK**

2-19 Assuming a program is supposed to fi nd an average given the total sum and number of values in a set, then the following dialogue is generated. What clue reveals the presence of an intent error?

```shell
Enter sum: 100
Number : 4
Average : 0.04
```

2-20 Assuming the following code was used to generate the dialogue above, how is the intent error to be corrected?

```C++
cout << "Enter sum: ";
cin >> n;
cout << "Number :";
cin >> sum;
average = sum / n;

cout << "Average : " << average << endl;
```

2-21 List the type of error (compile time, runtime, linktime, or intent) or warning that exists when the last statement in the preceding program is changed to:

* a.  `cout << "Average: " << "sum / n";`
* b.  `cout << "Average: ", sum / n;`
* c.  `cout << "Average: " << sum / n`

### 2.5.6 WHEN THE SOFTWARE DOESN’T MATCH THE SPECIFICATION

Even when a process has been automated and delivered to the customer in working order according to the developers, there may still be errors. Th ere have been many instances of software working, but not doing what it was supposed to do. Th is could be from a failure to meet the problem statement, which occurs when the software developers don’t understand the customer’s problem statement. Something could have been missed. Something could have been misinterpreted. A related error occurs when the client specifi es the problem incorrectly. This could be the case when the requester isn’t sure what they want. A trivial or critical omission in specifi cation may occur, or the request may not be written clearly. Also, the requester may change their mind after problem solving has begun.

For the most part, the end-of-chapter programming projects in this textbook ask you to fulfi ll the problem specifi cation. If you think there is an omission or there is something you don’t understand, don’t hesitate to ask questions. It is better to understand the problem and know what it is that you are to trying to solve before getting to the design and implementation phases of problem solving. Although not intended, the problem may be incorrectly or incompletely specified—this does actually happen in the real world!

## CHAPTER SUMMARY

* The smallest pieces of a program (tokens) were shown to help you understand general forms and fix errors.
* Objects are entities that have a name, state (value), and operations. Output (cout &lt;&lt;) and input (cin &gt;&gt;) operations are used in concert with double and string objects to set their states. Th ere are at least three techniques for modifying the state of an object:
  * initialization with double x = 0.0;
  * input with cin &gt;&gt;
  * assignment with =
* Knowledge of existing objects aids the program development process. For example, knowing about cin, cout, string, and numeric objects such as int and double precludes the necessity of implementing many intricate operations such as input, output, addition, and multiplication. Fortunately, other programmers have already built them.
* The objects named std::cout and std::cin are so frequently used that they are automatically made available for easy screen output and keyboard input with \#include &lt;iostream&gt;. If you add using namespace std; you do not have to precede cout, cin, and endl with std:: .
* Arithmetic expressions are made up of operators +, -, \*, /, and % (remainder). A binary arithmetic operator requires two operands, which may be numeric constants such as 1 and 2.3, numeric objects, or other arithmetic expressions.
* Instances of the Prompt then Input pattern will occur in many programming projects. Use it whenever a program needs to get some input from the user.
* When / has two integer operands, the result is an integer, so 5 / 2 is 2.
* When / has at least one floating-point operand, the result is a floating-point number, so 5 / 2.0 is 2.5.
* The % operator returns the integer remainder of one integer operand divided by another, so 5 % 2 is 1.
* The % operator cannot have a floating-point argument, so 5 % 2.0 is a compile time error.
* Be careful in choosing int and double. Always use double to store numbers unless it makes sense that the object can only store integers.
* This chapter ended with a discussion of the variety of errors that occur during implementa-tion. You will continue to encounter errors. It is part of the process.
* Errors may be present because the problem statement was incorrect or incomplete.
* Intent errors eventually prove to be the most difficult to fix—they can be diffi cult to detect.

## EXERCISES

1. List three operations that may be applied to numeric types like double.
2. Describe the value(s) stored in string objects.
3. List three operations that may be applied to any string object.
4. List four types of C++ tokens and give two examples of each.
5. Which of the following are valid identifi ers?

| | |
|-|-|
|`a.    a-one`  |`g.   1_2_3` |
|`b.    R2D2`   |`h.   A_B_C` |
|`c.    registered\_voter`|`i.   all right`|
|`d.    BEGIN` |`j. 'doubleObject'` |
|`e.    1Header` |`k.   {Right} |
|`f.    $money` |`l.   Mispelt` |

6. Declare totalPoints as an object capable of storing a number. 
7. Write a statement that sets the state of totalPoints to 100.0.
8. Write the entire dialogue generated by the following program when 5.2 and 6.3 are entered at the prompt. Make sure you write the user-supplied input as well as all program output including the prompt.

```C++
#include <iostream>
using namespace std;
int main() {
    double x = 0.0;
    double y = 0.0;
    double answer = 0.0;
    cout << "Enter a number: ";
    cin >> x;
    cout << "Enter another number: ";
    cin >> y;
    answer = x * (1.0 + y);
    cout << "Answer: " << answer << endl;
    return 0;
}
```

9. Write C++ code that declares tolerance as a numeric object set to 0.001 that cannot be changed while the program is running.
10. Write a statement that displays the value of a numeric object named total.
11. Given these two object initializations, either write the value that is stored in each object or report the attempt as an error.

```C++
string aString;
double aNumber = 0.0;
```

* a.    aString = "4.5";
* b.    aNumber = "4.5";
* c.    aString = 8.9;
* d.    aNumber = 8.9;

12. With paper and pencil, write an entire C++ program that prompts for a number from 0.0 to 1.0 and stores this input value into the numeric object named relativeError. Echo the input (output the input). Th e dialogue generated by your program should look like this:

```shell
Enter relativeError \[0.0 through 1.0\]: 0.341
You entered: 0.341
```

13. Assuming x is 5.0 and y is 7.0, evaluate the following expressions:
  * a.  `x / y`
  * b.  `y / y`
  * c.  `2.0 - x * y`
  * d.  `(x*y)/(x+y)`

14. Predict the output generated by these two programs:

* a.

```C++
#include <iostream>
using namespace std;
int main() {
    double x = 1.2;
    double y = 3.4;
    cout << (x + y) << endl;
    cout << (x - y) << endl;
    cout << (x * y) << endl;
    cout << (x / y) << endl;
    return 0;
}
```

* b.

```C++
#include <iostream>
using namespace std;

int main() {
    double x = 0.5;
    double y = 2.3;
    double answer = 0.0;
    answer = x * (1 + y);
    cout << answer << endl;
    answer = x / (1 + y);
    cout << answer << endl;
    return 0;
}
```

15. What is the value of quarter when change is initialized as follows:

* a.  0
* b.  74
* c. 49
* d. 549

```C++
int change = (one of the following: 0 , 74, 49, and 549);
int quarter = change % 50 / 25;
```

16. Is this code correct?

```C++
const double EPSILON = 0.000001;
EPSILON = 999999.9;
```

17. Write C++ code that generates a runtime error and give the reason for the error.

18. At what time will the error in this code be detected?

```C++
#include <iostream>
using namespace std;
int Main() {
    cout << "Hello world";
    return 0;
}
```

19. Explain how to fi x the error in each of these lines:

* a.  `cout << "Hello world"`
* b.  `cout << "Hello world";`
* c.  `cout "Hello World";`
* d.  `cout << "Hello World;`

20. Explain the error in this attempt at a program:

```C++
int main() {
    cout << "Hello world";
    return 0;
}
```

21. Describe the phrase *intent error*.

22. Does the following code always correctly assign the average of the three doubles x, y, and z to average? double average = x + y + z / 3.0;

23. Evaluate the following expressions. Use a decimal point to distinguish integer and floating point values.

* a.  5 / 2 
* b.  5 / 2.0 
* c.  101 % 2 
* d.  5.0 / 2.0
* e.  1.0 + 2.0 - 3.0 \* 4.0
* f.  100 % 2

18. Write the output generated by the following programs:

* a.

```C++
#include <iostream>
using namespace std;
int main() {
    const int MAX = 5;
    cout << (MAX / 2.0) << endl;
    cout << (2.0 / MAX) << endl;
    cout << (2 / MAX) << endl;
    cout << (MAX / 2) << endl;
    return 0;
}
```

* b.

```C++
#include <iostream>
using namespace std;
int main() {
    int j = 14;
    int k = 3;
    cout << "Quotient: "
         << (j / k) << endl;
    cout << "Remainder: "
         << (j % k) << endl;
    return 0;
}
```

* c.

```C++
#include <iostream>
using namespace std;
#include <string>
int main() {
    const string pipe = " ¦ ";
    cout << pipe << (1 + 5.5)
         << pipe << (3 + 3 / 3)
         << pipe << (1 + 2) / (3 + 4)
         << pipe << (1 + 2 \* 3 / 4);
    return 0;
}
```

* d.

```C++
#include <iostream>
using namespace std;
int main() {
    int j = 11;
    cout << " " << (j % 2)
         << " " << (j / 2)
         << " " << ((j - j) / 2);
    return 0;
}
```

## PROGRAMMING TIPS

1. Semicolons terminate statements. Make sure you terminate statements with ;. However, do not place semicolons after \#includes and int main().

```C++
#include <iostream>  // Error found on this line
int main() ; // Error found on this line
{
```

2. Fix the fi rst error fi rst. When you compile, you may get dozens of errors. Don’t panic. Try to fi x the very first error first. That may fi x several others. Sometimes fi xing one error causes others. After fixing one error, the compiler may generate errors that went undetected before.

3. Integer arithmetic behaves unexpectedly for some students. Integer
    > division results in an integer. Th erefore 5 / 2 is 2, not the 2.5
    > your brain and calculator feel are so right.

4. The % arithmetic operator returns an int remainder. Experience shows some students never understand %, or at least they still get the wrong answers on the fi nal exam. Th e expression a % b is the integer remainder after dividing a by b.

  99 % 50 = 49           101 % 2 = 1
  99 % 50 % 25 = 24      102 % 2 = 0
  4 % 99 = 4             103 % 2 = 1

5. If you do not have the line using namespace std; you will have to prepend std:: before every occurrence of the cin, cout, and endl.

```C++
#include <iostream>   // For cout, cin, and endl
// using namespace std; Without this, prepend with std::

int main() {
    std::string name;
    std::cin >> name;
    std::cout << "Hello" << std::endl;
    std::cout << name << std::endl;
}
```

## PROGRAMMING PROJECTS

### 2A THE CLASSIC “HELLO WORLD!” PROGRAM

While designing the C language at AT&T, Dennis Ritchie suggested that a first program in any language be one that displays Hello World! Many first programs have continued this “Hello World!” tradition. Create a new fi le called hello.cpp and retype the following code as shown. Save this fi le and use the instructions particular to your setup to compile, link, and run this program.

```C++
// Programmer: Firstname Lastname
// This programs displays a simple message.
#include <iostream> // For cout
using namespace std; // Allow cout instead of std::cout
int main() {
    cout << "Hello World!" << endl;
    return 0;
}
```

### 2B EXPERIENCE ERRORS GENERATED BY THE COMPILER

One small coding error may cause the report of many errors at compile time—this can be misleading. For example, a missing semicolon may result in dozens of errors throughout a program. Remember to fi x the first error fi rst. Start by fi xing the earliest discovered error in the source code. You are now asked to observe what happens when a left curly brace is left out of a program. Carefully retype the following program exactly as shown.

```C++
// Observe how many errors occur when { is missing
#include <iostream>    // For cout
using namespace std; // To make cout known

int main() // <- Leave off {
    double x = 2.4;
    double y = 4.5;
    cout << "x: " << x << endl;
    cout << "y: " << y << endl;
    return 0;
}
```

1. Compile your source code and write the number of errors that occur.
2. Add { after int main() and compile again. Make corrections until you have no errors.
3. Now remove the \#include directive \#include &lt;iostream&gt; and compile the program. How many errors do you get?
4. Replace \#include &lt;iostream&gt; and remove the () after main. How many errors do you get?
5. Comment out using namespace std;. How many errors do you get now?
6. If necessary, edit and compile this program until there are no compile time errors. Link and run the program.

### 2C BIG INITIALS

Write a C++ program that displays your initials on the screen in large letters. Th ere are no input or process steps, only output. For example, if your initials are E. T. M., the output should look like this generated by fi ve cout statements:

```shell
EEEEE       TTTTTTT          M     M
E              T             M M M M
EEEEE          T             M  M  M
E              T             M     M
EEEEE o        T    o        M     M o
```

### 2D YODA

Write a C++ program that obtains any three strings from the user and outputs them in reverse order with one space between them. (*Hint:* There is no process step; only input followed by output.)

```shell
Enter string one: happy
Enter string two: am
Enter string three: I
I am happy
```

### 2E WEIGHTED AVERAGE

Implement and test a C++ program that will compute the course grade using this weighted scale:

| Assessment | Weight |
|------------|--------|
| Quiz average | 20% |
| Midterm      | 20% |
| Lab grade    | 35% |
| Final exam   | 25% |

One dialogue should look like this:

```shell
Enter Quiz Average: 90.0
Enter Midterm: 90.0
Enter Lab Grade: 90.0
Enter Final Exam: 90.0
Course Average = 90
```

### 2F SECONDS

Write a program that reads a value in seconds and displays the number of hours, minutes, and seconds represented by the input. Here are two sample dialogues:

```shell
Enter seconds: 32123       Enter seconds: ***61***
8:55:23                    0:1:1
```

### 2G MINIMUM COINS

Write a C++ program that prompts for an integer that represents the amount of change (in cents) to be handed back to a customer in the United States. First, display the minimum number of half dollars, quarters, dimes, nickels, and pennies that will make the correct change. (*Hint*: With increasingly longer expressions, you could use / and % to evaluate the number of each coin. Or you could calculate the total number of coins with / and the remaining change with %.) Verify that your program works correctly by running it with a variety of input. Here are two sample dialogues:

| | |
|-|-|
| Enter change \[0...99\]: ***83*** | Enter change \[0...99\]: ***14*** |
| Half(ves) : 1  | Quarter(s) : 1 |
| Dime(s) : 0 | Nickel(s) : 1 |
| Penny(ies) : 3 | Half(ves) : 0 |
| Quarter(s) : 0 | Dime(s) : 1 |
| Nickel(s) : 0 | Penny(ies) : 4 |

### 2H EINSTEIN’S NUMBER

It is said that Albert Einstein used to take great delight in baffling friends with the following puzzle. It could be repeated something like this:

* Write 1089 on a piece of paper, fold it, and hand it to another for safekeeping.
* Ask someone else to write down any three-digit number, emphasizing that the fi rst and last digits must diff er: 654 is okay, while 454 and 656 are not allowed.
* Reverse that written down number: if starting with 654, write 456.
* Compute the diff erence of the written down three digit number and its reverse: use abs(456-654) = 198
* Once this is done, reverse the new number: 198 becomes 891.
* Th en add the new number to its reverse: 198 + 891 = 1089.

If all goes as planned, observers will be amazed. Th e number written down at the start, 1089, will always be the same as the end result of this mathematical trick. Replicate this puzzle as a C++ program. Your program dialogue must look like this when the user enters 541.

```shell
Enter a 3 digit number ( first and last digits must differ): ***541***
541 -- original
145 -- reversed
396 -- difference
693 -- reverse of the difference
1089 -- difference + reverse of the difference
```

You don’t need to error check the three-digit number. Assume input is in the range of 100 to 998 where the fi rst and third digits are not the same. 101, 252, or 989 are not expected to generate 1089. (*Hint:* To find the diff erence between two numbers, use the absolute value function abs. Th e argument is an expression that subtracts two numbers. You may need to \#include &lt;cstdlib&gt;.)

```C++
#include <cstdlib>   // A new include
#include <iostream>
using namespace std;
int main() {
    // abs is a new function that can return the difference
    // between two numbers by subtracting one from the other.
    cout << abs(541 - 145) << endl; // 396
    cout << abs(145 - 541) << endl; // 396
    return 0;
}
```

### 2I TIME DIFFERENCE

Write a C++ program that takes two diff erent train departure times (where 0 is midnight, 0700 is 7:00 a.m., 1314 is 14 minutes past 1:00 p.m., and 2200 is 10 p.m.) and prints the diff erence between the two times in hours and minutes. Assume both times are on the same date and that both times are valid. For example, 1099 is not a valid time because the last two digits are minutes, which should be in the range of 00 through 59. 2401 is not valid because the hours (the fi rst two digits) must be in the range of 0 through 23 inclusive. For example, if train A departs at: 1255 and train B departs at: 1305 the difference would be 0 hours and 10 minutes. One dialogue should look like this, but run your program several times for several test cases.

```shell
Train A departs at: ***1255***
Train B departs at: ***1305***
Difference: 0 hours and 10 minutes
```
