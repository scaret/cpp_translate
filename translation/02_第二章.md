# 第2章 C++ Fundamentals

**SUMMING UP**

The first chapter introduced a real-world program development strategy of analysis, design, and implementation. You were encouraged to do some analysis and design before writing C++ code. However, many problems encountered in this textbook will not require much effort to analyze and design. Analysis may simply be “Read the problem.” Design might end up as “I can picture an algorithm in my head.”

**COMING UP**

In this chapter, the emphasis will be on translating algorithms into programs using the C++ programming language. Th e resulting source code you type is the input to the compiler. Th e compiler translates the source code into machine code that your particular computer understands. However, the compiler expects source code to follow the precise rules of the programming language. Understanding how to translate a pseudocode algorithm into its programming language equivalent requires understanding the smallest pieces of a program and how to correctly gather them together to create statements. This chapter also examines operations that can be performed on many objects. After studying this chapter, you will be able to

* understand how to include existing source code in your programs
* obtain data from the user and display information to the user
* evaluate and create arithmetic expressions
* understand that these common operations are available to many objects such as initialization, input, assignment, and output
* solve problems using the C++ programming language

## 2.1 THE PIECES OF A C++ PROGRAM

A C++ program begins as a sequence of characters stored in a file. The name of the file holding a > C++ program typically ends with either .cc, .c, .cp, or .cpp (first.cc, first.C, or first.cpp, for example). Some programming environments require or assume certain fi le-naming conventions. Therefore, when you create a file to translate an algorithm into its C++ programming language equivalent, create the file with the extension you should—or must—use.

The text contained in the fi le is introduced as the *general form* of a C++ program (below). A general form describes the *syntax*—the correct language—necessary to write legal programming language constructs. Th is general form, like all others in this textbook, follows these conventions:

1. Elements written in *monospace* are used exactly as shown. This includes certain words such as int main*,* cout*,* cin*,* and symbols such as << >>.
2. The portions of a general form written in *italic* must be supplied by the programmer—for example, *expression* means you must supply a valid expression.
3. An item in italic is defi ned somewhere else.

**General Form 2.1** *Standard C++ Program*

```C++
// A comment
#include-directives
using namespace std;
int main() {
     statements
    return 0;
}
```

The parts of a general form in boldface must be written exactly as shown. The statements part refers to a collection of different statements. A statement is the smallest standalone element that expresses some action to be carried out. Semicolons terminate statements. A few statements are described in this chapter. Although not necessary with standard C++, the last statement in the C++ programs of this textbook will be return 0;. The curly braces { and } mark the extent of the main function. A function is a construct that allows all of the code to be treated as one entity.

Before getting into the details, here is a syntactically correct standard C++ program. To run code as a program, it must have a function named main. (*Note:* std is an abbreviation for standard.)

```C++
// This program prompts for a name and prints a friendly message
#include <iostream>   // For cout, cin, and endl
#include <string>     // for the string type

using namespace std;  // Allow programmers to write cin and cout
                      // rather than std::cin and std::cout
int main() {
    string name;
    cout << "What is your name: ";
    cin >> name;

    cout << "Hello " << name;

    cout << ", I hope you're feeling well." << endl;
    return 0;
}
```

**Dialogue**

```shell
What is your name: Casey
Hello Casey, I hope you’re feeling well.
```

This source code represents input to the compiler. The compiler translates source code like this into machine code. Along the way, the compiler may generate error and warning messages. Th e errors are detected as the compiler scans the source code of the program and any \#include files that represent additional source code. For example, the file named iostream precedes the code beginning at int main() and so the source code in the file becomes part of the program.The \#include directive is conceptually replaced by the text contained in the \#included file.

Every C++ program uses more than one fi le to take advantage of the code produced by other programmers. In fact, C++ compilers are delivered with a large number of fi les. Below is the general form that adds source code from other files to your program.

General Form 2.2 *Include Directive*

\#include < *include-file* >

- or -

\#include " *include-file* "

The \#include and angle brackets &lt; &gt; or double quote marks " " must be written exactly as shown. Th e include-fi le is the name of an existing fi le. For example, the previous program contains the following \#include directive in order to furnish cout, cin, and endl:

```C++
#include <iostream>
```

However, this \#include directive actually provides std::cout, std::cin, and std::endl. The C++ standard library, of which iostream is a part, is defi ned in a namespace called std. So to avoid repetitiously writing std::, this line should accompany \#include &lt;iostream&gt; and other \#includes seen later:

```C++
using namespace std; // Can now write cout instead of std::cout
```

Care should be taken to avoid any blank spaces between the &lt; &gt; or " ".

```C++
#include <iostream > // ERROR, space at end
#include " BankAccount.h" // ERROR, space up front
```

Any included file with angle brackets &lt; &gt; must be part of the system. Your system should be able to fi nd those files automatically. However, the fi le names included within double quote marks " " may need to be stored in the same directory as the program that includes them.

### 2.1.1 TOKENS: THE SMALLEST PIECES OF A PROGRAM

Before looking at the general forms for object initializations and statements, consider the smallest pieces of the programming language that make up the larger constructs. Th is should help you 

* more easily code syntactically correct statements
* better understand how to fi x errors detected by the compiler
* understand general forms

As the C++ compiler reads the source code, it identifi es individual *tokens*. A token is the smallest recognizable component of a program. Tokens fall into four categories:

| Category | Examples |
|----------|----------|
| Special symbols | ; ( ) &lt;&lt; &gt;&gt; |
| Keywords        | return double int |
| Identifiers | main test2 firstName |
| Literals | "Hello" 507 -2.1 true 'c' nullptr |

### 2.1.2 SPECIAL SYMBOLS

A *special symbol* is a sequence of one or two characters with one or possibly many specifi c meanings. Some special symbols such as {, ;, and , separate other tokens. Other special symbols such as +, -, and  &lt;&lt; represent operators in expressions. Here is a partial list of single-character and double-character special symbols frequently seen in C++ programs:

```C++
( ) . + - / * =< >= // { } == ; << >>
```

### 2.1.3 IDENTIFIERS

*Identifiers* are names given to a variety of things. They all follow these rules that govern the creation of C++ identifiers.

* Identifi ers begin with upper- or lowercase letters a through z or A through Z, dollar sign \$, or the underscore character \_.
* The first letter may be followed by a number of upper- and lowercase letters, digits (0 through 9), and underscore characters.
* Identifi ers are case-sensitive. For example, Ident, ident, and iDENT are three different identifiers.

**Valid Identifiers**
| | | | | |
|-|-|-|-|-|
| main | cin | incomeTax |i| MAX\_SIZE |
| Maine | cout | employeeName |x| all\_4\_one |
| miSpelte | string | A1 |n| \$motion\$ |

**Invalid Identifiers**
| | |
|-|-|
| 1A | Begins with a digit |
| miles/Hour | / is unacceptable |
| first Name | The blank space is unacceptable |
| pre-shrunk | The - operator means subtraction |

C++ comes with a large number of tandard—must be part of the language—identifi ers. For example, cin is the name of an object used to obtain input from the keyboard. Another standard identifi er, cout, is the name of the object used to prompt generate output. Here are a few other standard C++ identifiers. (*Note:* The first identifier, pronounced “end-ell,” is used for end line.)

 > endl sqrt fabs pow string vector width precision queue

Programmer-defi ned identifi ers have meaning for the programmer who created the program, for others who might later use it, and for those who must maintain the program. For example, test1, finalExam, and courseGrade are programmer-defi ned. When creating your own identifiers, give them meaningful names that reveal their purposes.

C++ is case-sensitive, which means an uppercase letter is different from the same letter in lowercase; “A” is not the same as “a.” For example, every complete program must include the identifi er main. MAIN or Main won’t do. Also note that several conventions may be used for upper and lowercase letters. Some programmers prefer avoiding uppercase letters; others prefer to use uppercase letters for each new word. Th e convention used in this textbook is the “camelBack” style where each word after the fi rst has an uppercase letter. For example, you will see letterGrade rather than lettergrade, LetterGrade, or letter\_grade. Diff erent programmers use diff erent styles.

### 2.1.4 KEYWORDS

*Keywords* are identifi ers that have a specifi c purpose whose meaning is reserved by the standard language defi nition, such as the keywords double and int.

**C++ KEYWORDS**
| | | | | |
|-|-|-|-|-|
| break | do | for | operator | switch |
| case | double | if | return | typedef |
| char | else | int | sizeof | void |
| class |float | long | struct | while |

The case sensitivity of C++ applies to keywords. For example, there is a diff erence between double (a keyword) and Double (not a keyword). C++ keywords are always in lowercase.

### 2.1.5 COMMENTS

*Comments* are portions of text that annotate a program. Comments fulfill any or all of the following expectations:

* Provide internal documentation to help one programmer read another’s program—assuming those comments clarify the meaning of the program
* Explain certain code fragments or the purpose of an object
* Indicate the programmer’s name and the goal of the program
* Describe a wide variety of program elements and other considerations

Comments may be added anywhere throughout a program, including to the right of any C++ statement, on a separate line, or over several lines. They may begin with the two-character special symbol /\* when closed with \*/.

```C++
/*
A comment may
extend over
several lines
*/
```

An alternate form for comments is to use // before the text. Such a comment may appear on a line by itself or at the end of a line:

```C++
// A complete C++ program
int main() {
    return 0; // This program returns 0 to the operating system 
}
```

Within the context of the programs in this textbook, comments are most often written as one-line comments like // Comment rather than /\* Comment \*/. All code after /\* is a comment until \*/ is encountered, so a large portion of the program can accidentally be turned into a comment by forgetting \*/ at the end. The one-line comments make it more difficult to accidentally “comment out” large sections of code.

Comments are added to help clarify and document the purpose of the source code. Th e goal is to make the program more understandable, easier to debug (correct errors), and easier to maintain (change when necessary). Programmers need comments to understand programs that may have been written days, weeks, months, years, or even decades ago.

### 2.1.6 C++ LITERALS

The C++ compiler recognizes string, integer, Boolean (true/false), and floating-point literals. A *string literal* is zero or more characters enclosed within double quotes and finished on the same line:

```shell
"Double quotes are used to delimit string constants."
"Hello, World!"
```

*Integer constants* are numbers without decimal points. *Floating-point constants* are written with decimal points or using exponential notation: 5e3 = 5 \* 103 = 5000.0 and 1.23e-4 = 1.23 \* 10^-4^ = 0.000123, for example. *Boolean literals* are true and false. Here are some examples of C++ literals and the C++ types used in this textbook to store those literal objects.

| Type | Example Literals |
|------|------------------|
| int  | 0 1 999 -999 -2147483647 2147483647 |
| char | 'a' '\#' '9' '\\t' (tab) '\\n' (new line) |
| double | 1.23 0.5 .5 5. 2.3456e9 1e-12 |
| bool | true false |
| string | "Double quoted" "Kim's" "\\n" "" (empty string) |

```C++
// Print a few C++ literals
#include <iostream>  // For cout and endl using namespace std;

int main() {
    cout << 123 << endl;
    cout << 'a' << '\t' << 'm' << endl;
    cout << 1.23 << endl;
    // true prints as 1 and false as 0
    cout << true << " and " << false << endl;
    cout << "Hello \n world" << endl;

    return 0;
}
```

**Output**

```shell
123
a m
1.23
1 and 0
Hello world
```

**SELF-CHECK**

2-1 How many special symbols are there in the preceding program?

2-2 List each of the following as a valid identifi er or explain why it
is not valid.
| | |
|-|-|
| `a.  abc`  | `l.  H.P.` |
| `b.  123`  | `m.  double` |
| `c.  ABC`  | `n.  55\_mph` |
| `d.  #include` | `o.  sales Tax` |
| `e.  my Age`   | `p.  main` |
| `f.  #define`  | `q.  a` |
| `g.  Abc!`     | `r.  å)` |
| `h.  identier` | `s.  ___1___` |
| `i.  (identier)` | `t.  Mile/Hour` |
| `j.  Double`     | `u.  os` |
| `k.  mispellted` | |

2-3. List two special symbols that are one character long.

2-4.  List two special symbols that are two characters long.

2-5.  List two standard identifiers.

2-6.  Create two programmer-defined identifiers.

2-7.  Given the following tokens:

'\\n' false 234 1.0 'H' "'" -123 1.0e+03 "H" true

a. Which are valid string literals?

b. Which are valid integer literals?

c. Which are valid fl oating-point literals?

d. Which are valid Boolean literals?

e. Which are valid char literals?

2-8. Which of the following are valid C++ comments?

a.  // Is this a comment?

b.  / / Is this a comment?

c.  /\* Is this a comment?

d.  /\* Is this a comment? \*/

## 2.2 STATEMENTS

A *declaration* introduces one or more object names into a program. An *initialization* also introduces object names into a program with the additional feature of setting the initial *value* to whatever the programmer wants. Th ese variable names are used later when the programmer is interested in the current value or needs to change that value. Here are the general forms for declaring or initializing fundamental and compound types of variables:

**General Form 2.3** *Declaration (some classes have a default initial state)*

*type identier* ;

**General Form 2.4** *Initialization (declare a variable and assign it a value)*

*type identi er* = *initial-state* ;

The type may be double—to store numbers with a decimal point—or a compound type class such as string to store a collection of characters (many other compound types exist).

The following code declares some variables and initializes others. The semicolons (;) are used to terminate statements.

```C++
int credits; // credits is some random integer
double points; // > credits is some random oating point number
double GPA = 0.0; // GPA is initialized to 0.0
bool boolOne; // boolOne could be either true or false
bool boolTwo = true; // boolOne is true
string rstName; // rstName is the empty string ""
string middleName = "James"; // middleName.length() is 5
string lastName = "Potter"; // lastName.length() is 6
```

The fundamental types int, double, and bool diff er from string and other compound types in several ways. When declared, numeric types have an unknown value. However, the default initial value of string objects is the empty string "" when it is not explicitly initialized.

The following table summarizes the initial state of these objects where some have an unknown state. Th ose variables were declared, but not initialized. Th e value is whatever bits happen to be there when the program runs. Th ese variables can actually have diff erent value during diff erent program runs.

| Variable | Name Object’s State |
|----------|---------------------|
| credits | unknown |
| points | unknown |
| boolOne | unknown |
| boolTwo | true (would print as 1) |
| GPA | 0.0 |
| fistName  | "" |
| middleName | "James" |
| lastName   | "Potter" |

### 2.2.1 OUTPUT WITH cout

Programs communicate with users. Such communication is provided through, but not limited to, keyboard input and screen output. This two-way communication is a critical component of many of the programming projects in this textbook.

**General Form 2.5** *The* cout *statement*

> cout &lt;&lt; *expression-1* &lt;&lt; *expression-2* , . . . ,&lt;&lt; *expression-n* &lt;&lt; endl;

The object named cout (pronounced “see-out” and short for **c**ommon **out**put) represents where the output will go: the console. *expression-1* through *expression-n* may take the form of object names such as GPA and rstName or constants such as "Credits: " and 99.5. Th e output operator &lt;&lt; indicates the direction in which data are fl owing. Finally, a semicolon (;) terminates each statement. Here are some legal output statements that use the endl identifier (pronounced “end-ell”) to generate a new line:

```C++
cout << 99.5 << endl;
cout << "Show me literally too" << endl;
cout << "First Name: " << firstName << endl;
cout << "Credits: " << credits << endl;
```

When a cout statement is encountered, the expressions are inserted into a data stream going toward the computer screen. Th e expressions are output in the same order as they are encountered in the statement—in a left-to-right order. When the expression endl is encountered, a new line is generated, so any subsequent output starts at the beginning of a new line.

```C++
cout << 'A' << " line " << true << " " << 123 << 4.56 << endl;
```

**Output**

```shell
A line 1 1234.56
```

**SELF-CHECK**

2-9 Initialize two objects that represent numbers with an initial value of -1.5.

2-10 Declare one object named address that could store a street address.

2-11 Write a complete C++ program that displays any names you have on separate lines.

### 2.2.2 ASSIGNMENT AND TYPE CONVERSIONS

*Assignment* statements set the state of an object. Th e value of the expression to the right of = replaces whatever value was in the object to the left of =.

**General Form 2.6** *The Assignment Statement*

> *object-name* **=** *expression*;

The *expression* must be a value that can be stored by the object to the left of the assignment operator =. For example, an expression that results in a fl oating-point value can be stored in a numeric object, and a string expression (characters between double quotes " ") can be stored in a string object. Here are some other examples of assignment statements:

```C++
double aNumber = -999.9;
string aString = "Initial state";

aNumber = 456.789;
aString = "Modified state";
```

After the four assignment operations execute, the state of both objects is modifi ed and the state of these objects can be shown like this:

| Object | State |
|--------|-------|
| aNumber | 456.789 |
| aString | "Modified State" |

The value to the right of = must be assignment-compatible with the variable’s type on the left for the assignment to work correctly. For example, a string literal cannot be assigned to a numeric variable.

```C++
aNumber = "Ooooohhhh no, you can't do that"; // ERROR
```

A double literal cannot be assigned to a string object.

```C++
aString = 12.34; // ERROR
```

The compiler will report errors at both attempted assignment statements. However, type conversions happen automatically when an object of one type is used when an object of another type is expected. There are no warnings or reported errors, just unexpected values assigned to the variables.

```C++
char c = 65; // c becomes 'A'
bool b = 0; // b becomes false
b = 42; // b becomes true, actually 1
int n = b; // n becomes 1, the integer for true
n = 5.9999; // n becomes 5 due to truncation
double x = n; // x becomes 5.0, but prints as 5
long l = n; // l becomes 5, int promotes to long
```

**SELF-CHECK**

2-12 Given the variables initialized above, write the assigned value or report as an error.

| | |
|-|-|
| `a.  b = -123;` | `d.  l = x;` |
| `b.  n = 123.495678;` | `e.  c = 66;` |
| `c.  x = 123;` | `f.  ui = "abcde";` |

Be wary of a meaningless object values. Th ey can cause unpredictable errors. Make sure you defi ne all objects either through initialization, an assignment operation, or keyboard input. Also be wary of type conversions, especially when there will be a conversion error that can result in a diff erent value. Th is will occur when mixing signed and unsigned types, so don’t do that. To properly use objects in a program, all three characteristics must be considered:

* An object must be given a name with a declaration or initialization.
* An object must be declared as an instance of a specifi c type.
* At some point, an object should be given a meaningful value.

### 2.2.3 INPUT WITH cin

To make programs more general—for example, to fi nd a course grade for any student—the state of objects is often set through keyboard input. This allows the user to enter any data desired. Input happens with the input stream object named cin (pronounced “see-in” and short for **c**ommon **in**put) and the stream extraction operator &gt;&gt;. For example, the following statements modify the state of two objects with data supplied by the user:

```C++
cin >> firstName; // User must input a string
cin >> credits; // User must input a number
```

Here is the general form of the input statement with cin:

**General Form 2.7** *The* cin *statement*

> cin &gt;&gt; *object-name* ;
>
> or
>
> cin &gt;&gt; *object-name-1* &gt;&gt; *object-name-2* &gt;&gt; *object-name-n*;

The object-name must be an instance of a class whose value can be typed in at the keyboard. Th is form of input operation is defined for many but not all objects in this textbook. Input with cin is defined for the int, double, and string types.

When a cin statement is encountered, the program pauses until the user types the proper input value and presses the Enter key. If everything goes okay, the value typed by the user is converted into the proper machine representation and stored as the state of that object.

In addition to the Enter key, input data is also separated by one or more blank spaces. Th is makes it diffi cult to read in a string with blank spaces, such as a person’s full name or address. Given the following code:

```C++
string name;
cout << "Enter your name: ";
cin >> name;
```

and this dialogue:

```shell
Enter your name: Kim McPhee
```

Kim is stored into name, not Kim McPhee as one would hope. The blank space after Kim terminates the input value. To get all characters from one line even with spaces, use the getline operation:

```C++
getline(cin, name);
```

You may write the cin statement with more than one object for input. If you do, you must assume that the user knows to separate each input from the preceding one with a blank space (press the Spacebar), a new line (press Enter or Return), or a tab (press the Tab key). The following program was run several times to show the various ways input is separated.

```C++
#include <iostream>
using namespace std;

int main() {
    int a, b, c, d;
    cout << "Enter four integers: ";

    // Just need to separate input by a space, tab, or new line.
    cin >> a >> b >> c >> d;
    cout << a << endl;
    cout << b << endl;
    cout << c << endl;
    cout << d << endl;
    return 0;
}
```

**Three Possible Dialogues**

| Enter four integers:  | Enter four integers: | Enter four integers: ***1*** |
|-----------------------|----------------------|------------------------------|
| 1 2 3 4               | 1 2                  |  2                           |
| 1                     |                      |  3                           |
| 2                     | 3                    |  4                           |
| 3                     |                      |  1                           |
| 4                     | 4                    |  2                           |
|                       | 1                    |  3                           |
|                       | 2                    |  4                           |
|                       | 3                    |                              |
|                       | 4                    |                              |

A simple alternative would be to use one cin statement for each input.

## 2.3 ARITHMETIC EXPRESSIONS

Many of the problems in this chapter require you to write arithmetic expressions. Arithmetic expressions are made up of two components: operators and operands. An arithmetic *operator* is one of the C++ special symbols +, -, /, or \*. The *operands* of an arithmetic expression may be a numeric object name such as test1 or a numeric constant such as 0.25. Assuming x is an instance of the double class, the following expression has operands x and 4.5. The operator is +.

    x + 4.5

Together, the operator and operands determine the value of the arithmetic expression.

The simplest arithmetic expression is a numeric constant or numeric object name. Arithmetic expressions may also have two operands with one operator (see the table below).

| An Arithmetic Expression May Be | Example |
|---------------------------------|---------|
| *Numeric object*                | x       |
| *Numeric constant*              | 100 *or* 99.5 |
| *Expression* + *expression*     | x + 2.0 |
| *Expression* - *expression*     | x - 2.0 |
| *Expression* \* *expression*    | x \* 2.0 |
| *Expression* / *expression*     | x / 2.0 |
| ( *Expression* )                | (x + 2.0) |

The previous definition of expression also suggests that more complex arithmetic expressions are possible, such as this:

```C++
1.5 * ((x - 99.5) * 1.0 / x)
```

Since arithmetic expressions may be written with many constants, numeric object names, and operators, rules are put into force to allow a consistent evaluation of expressions. The following table lists the fi ve C++ arithmetic operators and the order in which they are applied to numeric objects.

**Binary Arithmetic Operators**

| Operators | Precedence Rule |
|-----------|-----------------|
| \* / %  | In the absence of parentheses, multiplication, division, and remainder (%), operators evaluate before addition and subtraction. In other words, \*, /, and % (for the int remainder) have precedence over + and -. If more than one of these operators appear in an expression, the leftmost operator evaluates first. |
| > + - | In the absence of parentheses, + and - evaluate after all \*, /, and % operators, with the leftmost evaluating first. Parentheses may override these precedence rules.|

The operators of the following expression are applied to the operands in this order: /, +, and lastly -.

```C++
2.0 + 5.0 - 8.0 / 4.0 // Evaluates to 5.0
```

Parentheses may alter the order in which arithmetic operators are applied to their operands.

```C++
(2.0 + 5.0 - 8.0) / 4.0 // Evaluates to -0.25
```

With parentheses, the / operator evaluates last, rather than first.

These precedence rules apply to binary operators only. A *binary operator* is one that requires one operand to the left and one operand to the right. A *unary operator* only requires one operand on the right. Consider this expression, which has the binary operator \* and the unary minus operator -.

```C++
3.5 * -2.0 // Evaluates to -7.0
```

The unary operator evaluates before the binary \* operator: 3.5 times negative 2.0 (-2.0) results in negative 7.0 (-7.0).

Arithmetic expressions usually have object names as operands. When C++ evaluates an expression with double objects, the object name is replaced with its state. Consider the following code:

```C++
double x = 1.0;
double y = 2.0;
double z = 3.0;

double answer = x + y * z / 4.0;
```

When the program is running, the values stored in the variables are retrieved to get this equivalent expression:

```C++
double answer = 1.0 + 2.0 * 3.0 / 4.0; // store 2.5 into answer
```

**SELF-CHECK**

2-13 Evaluate the following arithmetic expressions:

```C++
double x = 2.5;
double y = 3.0;
```

  a\. x \* y + 3.0       d\. 1.5 \* (x - y)
  ---------------------- -------------------------
  b\. 0.5 + x / 2.0      e\. y + -x
  c\. 1 + x \* 3.0 / y   f\. ( x - 2) \* (y - 1)

### 2.3.1 int ARITHMETIC

The C++ language provides several numeric types. Perhaps the two most often used are double and int. An int object represents a limited range of whole numbers. There are times when int is the correct choice over double. An int object has operations similar to double (+, \*, -, =, &lt;&lt;, &gt;&gt;), but some diff erences do exist. For example, a fractional part cannot be stored in an int object. The fractional part is lost during an assignment statement.

```C++
int anInt = 1.999; // The state of anInt is 1, not 1.999
```

The / operator has diff erent meanings for int and double operands. Whereas the result of 3.0 / 4.0 is 0.75, the result of 3 / 4 is 0. Two integer operands with the / operator have an integer result—not a fl oating-point result. So what happens? An integer divided by an integer results in the integer quotient. For example, the quotient obtained from dividing 3 by 4 is 0. This implies that the same operator (/ in this case) has a different meaning when it has two integer operands.

Another difference is that int objects have a remainder operation symbolized by the % operator. For example, the result of 18 % 4 is the integer remainder after dividing 18 by 4, which is 2. These differences are illustrated in the following program, which shows % and / operating on integer expressions and / operating on floating-point operands. In this example, the integer results describe whole hours and whole minutes rather than the fractional equivalent.

2.3: Arithmetic Expressions

```C++
// This program provides an example of int division with '/' for
// the quotient and '%' for the remainder
#include <iostream>
using namespace std;

int main() {
    // Declare objects that will be given meaningful values later
    int totalMinutes, minutes, hours;
    double fractionalHour;

    // Input
    cout << "Enter total minutes: ";
    cin >> totalMinutes;

    // Process
    fractionalHour = totalMinutes / 60.0;
    hours = totalMinutes / 60;
    minutes = totalMinutes % 60;

    // Output
    cout << totalMinutes << " minutes can be rewritten as "
         << fractionalHour << " hours " << endl;
    cout << "or as " << hours << " hours and "
         << minutes << " minutes" << endl;

    return 0;
}
```

**Dialogue**

```shell
Enter total minutes: 254
254 minutes can be rewritten as 4.23333 hours
or as 4 hours and 14 minutes
```

The preceding program indicates that even though int objects and double objects are similar, there are times when double is the more appropriate class than int, and vice versa. The double class should be specified when you need a numeric object with a decimal component. If you need whole numbers, select the int class. Also, once the class is chosen, you should consider the diff erences in some of the arithmetic operators. For example, although the +, -, /, and \* operations can be applied to double operands, the % operator may only be used with two integer operands.

**SELF-CHECK**

2-14 What value is stored in nickel?

```C++
int change = 97;
int nickel = 0;
nickel = change % 25 % 10 / 5;
```

2-15 What value is stored in nickel when change is initialized to:

| | |
|-|-|
| `a.   4` | `d.   15` |
| `b.   5` | `e.   49` |
| `c.   10`| `f.   0`  |

### 2.3.2 MIXING INTEGER AND FLOATING-POINT OPERANDS

Whenever integer and floating-point values are on opposite sides of an arithmetic operator, the integer operand is promoted to its floating-point equivalent (3 becomes 3.0, for example). Th e expression then results in a floating-point number. Th e same rule applies when one operand is an int object and the other a double.

```C++
// Display the value of an expression with a mix of operands
#include <iostream>
using namespace std;

int main() {
    int n = 10;
    double sum = 567.9;

    // n will be promoted to a double and use the oating point
    cout << (sum / n) << endl;

    return 0;
}
```

**Output**

56.79

**SELF-CHECK**

2-16 Evaluate the following expressions:

| | |
|-|-|
| `a.   5 / 9` | `d.   2 + 4 * 6 / 3` |
| `b.   5.0 / 9` | `e.  (2 + 4) * 6 / 3` |
| `c.   5 / 9.0` | `f.  5 / 2` |

### 2.3.3 CONSTANT OBJECTS

The state of any object can be, and usually is, altered during program execution. However, it is sometimes convenient to have data with values that cannot be altered during program execution. C++ provides the keyword const for this purpose. Constant objects are created by specifying and associating an identifi er with a value preceded by the keyword const. In essence, this is an object whose state cannot be changed through assignment or stream extraction operations. The general form used to initialize a constant object is a combination of an initialization preceded by the keyword const. Const objects are usually written in upper case.

**General Form 2.8** *Initializing a constant object*

> const *type* *IDENTIFIER* = *expression*;

For example, the value stored in the constant object PI is the floating-point number 3.1415926, and TAX\_RATE is 7.51%.

```C++
const double PI = 3.1415926;
const double TAX\_RATE = 0.0751;
const string PAUSE\_MESSAGE = "Press any key to continue . . .";
```

These constant objects represent values that cannot be changed while the program is executing; therefore a statement such as PI = PI \* r \* r; generates an error because PI is declared as constant. The value cannot be destroyed with an input statement such as cin &gt;&gt; PI;.

## 2.4 PROMPT THEN INPUT

The output and input operations are often used together to obtain values from the user of the program. Th e program informs the user what must be entered with an output statement and then performs an input operation to set the state of the object. Th is happens so often that this activity can be considered to be a pattern. The Prompt then Input algorithmic pattern has two activities:

1. Ask the user to enter a value (prompt).

2. Obtain the value for the object (input).

| Algorithmic Pattern | Prompt then Input |
|---------------------|-------------------|
|  **Pattern:**       | Prompt then Input |
|  **Problem:**       | The user must enter something |
|  **Outline:**       | 1.  Prompt the user for input
                        2.  Obtain the input |
|  **Code Example:**  | `cout << "Enter your first name: "; cin >> firstName;` |

Strange things can happen if the prompt is left out. The user will not know what must be entered. So whenever you require user input, make sure you prompt for it fi rst. Write the code that tells the user precisely what you want. First output the prompt, then obtain the user input.

Here is one instance of the Prompt then Input pattern:

```C++
cout << "Enter test \#1: ";
cin >> test1;
```

and another:

```C++
cout << "Enter credits: ";
cin >> credits;
```

In general, tell the user the value needed, then read it in with cin.

```C++
cout << "the prompt for the\_object: ";
cin >> the\_object;
```

The following program uses the Prompt then Input pattern four times. It also reviews operations such as object initialization, assignment, input, and output. Th is program illustrates a more general approach to computing any grade point average. By requesting input data from the user, it can be used over and over again with diff erent sets of input to produce diff erent results. Also notice the presence of the IPO pattern in the implementation.

```C++
// This program uses input statements to produce a meaningful
// result that can be used in a variety of examples
#include <iostream>  // For input and output
#include <string>    // For the string class
using namespace std;

int main() {
    // 0. Initialize some objects
    double credits = 0.0;
    double points = 0.0;
    double GPA = 0.0;
    string firstName;
    string lastName;

    // 1. Input
    cout << "Enter first name: ";
    cin >> firstName;
    cout << "Enter last name: ";
    cin >> lastName;
    cout << "Enter credits: ";
    cin >> credits;
    cout << "Enter points: ";
    cin >> points;

    // 2. Process
    GPA = points / credits;

    // 3. Output
    cout << "Name : " << firstName << " " << lastName << endl;
    cout << "Credits : " << credits << endl;
    cout << "Points : " << points << endl;
    cout << "GPA : " << GPA << endl;

    return 0;
}
```

**Dialogue**

```shell
Enter first name: Pat
Enter last name: McCormick
Enter credits: 97.5
Enter points: 323.75
Name : Pat McCormick
Credits : 97.5
Points : 323.75
GPA : 3.32051
```

Care must be taken when entering numeric data. If you enter a non-digit instead of valid numeric input, the input object cin may no longer be in a “good” state and all subsequent cin statements will be ignored.

**SELF-CHECK**

2-17 Write the value for GPA given each of the dialogues shown below.

```C++
// This program uses input statements to produce a
// meaningful result that can be used for a variety of examples
#include <iostream>  // For cin, cout, and endl
#include <string>    // For the string class
using namespace std;

int main() {
    // 0. Initialize some numeric objects
    double c1 = 0.0;
    double c2 = 0.0;
    double g1 = 0.0;
    double g2 = 0.0;
    double GPA = 0.0;
    // 1. Input
    cout << "Credits for course 1: ";
    cin >> c1;
    cout << " Grade for course 1: ";
    cin >> g1;
    cout << "Credits for course 2: ";
    cin >> c2;
    cout << " Grade for course 2: ";
    cin >> g2;
    // 2. Process
    GPA = ( (g1*c1) + (g2*c2) ) / (c1+c2);
    // 3. Output
    cout << "GPA: " << GPA << endl;
    return 0;
}
```

Dialogue 1:

```shell
Credits for course 1: 2.0
Grade for course 1: 2.0
Credits for course 2: 3.0
Grade for course 2: 4.0

a.  ________GPA
```

Dialogue 2:

```shell
Credits for course 1: 4.0
Grade for course 1: 1.5
Credits for course 2: 1.0
Grade for course 2: 3.5

a.  ________GPA
```

Dialogue 3:

```shell
Credits for course 1: 1.0
Grade for course 1: 2.0
Credits for course 2: 4.0
Grade for course 2: 3.0

a.  ________GPA
```

## 2.5 IMPLEMENTATION ERRORS AND WARNINGS

There are several types of errors and warnings that occur during the implementation phase of problem solving:

* compile time—errors that occur during compilation
* warnings—code that is risky, suggesting there may be a future error
* linktime—errors that occur when the linker cannot fi nd what it needs
* runtime—errors that occur while the program is executing
* intent—the program does what was entered, not what was intended

![图2-1](img/2-1.png)

### 2.5.1 ERRORS AND WARNINGS DETECTED AT COMPILE TIME

A programming language requires strict adherence to its own set of formal syntax rules. As you have probably noticed, it is easy to violate these syntax rules while translating algorithms into their programming language equivalents. All it takes is a missing { or ; to really foul things up. As the C++ compiler translates source code into code that can run on the computer, the compiler

* locates and reports as many errors as possible
* warns of potential problems that are syntactically legal, but might cause errors later

A compile time error occurs when the C++ compiler recognizes the violation of a syntax rule. The machine code cannot be created until all compile time errors have been removed from the program. If the machine code is not created, the linker cannot create an executable program. Many strange-looking error messages will be generated by the compiler as it reads the source code. Unfortunately, deciphering these compile time error messages takes practice, patience, and a reasonable knowledge of the C++ programming language. So in an eff ort to improve this situation, here are some examples of common compile time errors you will soon see and explanations of how they are corrected. (*Note:* Your compiler will generate diff erent error messages.)

| Error Detected by a Compiler | Incorrect Code | Corrected Code |
|------------------------------|----------------|----------------|
| Splitting a variable name | int Total Weight; | int totalWeight; |
| Misspelling a name   | integer sum = 0 ; | int sum ; |
| Omitting a semicolon | double x | double x; |
| Not closing a string | `cout << "Hello;` | `cout << "Hello";` |
| Failing to declare the variable | `cin >> testScore;` | `double testScore; cin >> testScore;` |
| Ignoring case sensitivity | `double X; X = 5.0;` | `double x; x = 5.0;` |
| Forgetting an argument    | `cout << sqrt;` | `cout << sqrt(x);`
| Using wrong type   | `cout << sqrt("12");` | `cout << sqrt(12.0);` |
| Using too many arguments | `cout << sqrt(1.2, 3);` | `cout << sqrt(1.2);` |
| Forgetting namespace std; |`// cout is unknown` | `using namespace std;` |

Compilers generate many error messages. However, it is your source code that is the source of these errors. Whenever your compiler appears to be nagging you, remember that the compiler is trying to help you correct your errors as much as possible. Th e compiler is your friend.

The following code shows several errors the compiler should eventually detect and report. Because error messages generated by compilers vary among systems, the comments here indicate the reason for the error—they are not an attempt to match compile time error messages for any particular compiler (and there are many compilers).Your system will certainly generate quite different error messages.

```C++
// This attempt at a program contains many errors--over a
// dozen. Add #include <iostream> and there are only eight.
using namespace std;

int main { // 1. No () after main.
           // 2. Every cin and cout will generate an error
           // because #include <iostream> is missing.
    int pounds;

    cout << "Begin execution" << endl // Missing ; after endl
    cout >> "Enter weight in pounds: "; // >> should be <<
    cin << pounds; // << should be >>
    cout << "In the U.K., you"; // Extra ;
         << " weigh " << (Pounds / 14) // Pounds is not declared
         << " stone. " << endl // Missing ;
    return 0; // Missing right brace }
```

Compilers can generate some rather cryptic messages. When the program shown above compiled with one particular compiler, six errors occurred (other compilers found seven and two), all reporting a type name was expected. Other systems generate a diff erent crop of errors. Another Unix compiler generated eight completely diff erent errors. Compile time error messages take some getting used to, so try to be patient and observe the location where the compile time error occurred. The error is usually in the vicinity of the line where the error was detected, although you may have to fi x preceding lines. Always remember to fi x the fi rst error fi rst. Th e error not reported until line 23 may be the result of a forgotten semicolon on line 4.

The corrected source code, without error, is given next, followed by an interactive dialogue:

```C++
// There are no compile time errors in this program
#include <iostream>
using namespace std;

int main() {
    int pounds;

    cout << "Begin execution" << endl;
    cout << "Enter your weight in pounds: ";
    cin >> pounds;
    cout << "In the U.K., "
         << "you weigh " << (pounds/14.0) << " stone." << endl;

    return 0;
}
```

**Dialogue**

```shell
Begin execution
Enter your weight in pounds: 162
In the U.K., you weigh 11.5714 stone.
```

It should also be noted that one small compile time error can result in a cascade of errors. For example, omitting { after int  main() in an otherwise error-free program caused the Clang C++ compiler to generate 11 compile time errors!

```C++
#include <iostream>   // For cin and cout
#include <string>     // For the string class
using namespace std;

int main() // <- Without the left curly brace, there were 11 errors!
    double x;
    string str;
    cout << "Enter a double: ";
    cin >> x;
    cout << "Enter a string: ";
    cin >> str;
    return 0;
}
```

**Compile time error messages from one compiler**

```shell
main.cpp:5:11: error: expected ';' after top level declarator
main.cpp:9:3: error: unknown type name 'cout'
main.cpp:9:8: error: expected unquali ed-id
main.cpp:10:3: error: unknown type name 'cin'
main.cpp:10:7: error: expected unquali ed-id
main.cpp:11:3: error: unknown type name 'cout'
main.cpp:11:8: error: expected unquali ed-id
main.cpp:12:3: error: unknown type name 'cin'
main.cpp:12:7: error: expected unquali ed-id
main.cpp:13:3: error: expected unquali ed-id
main.cpp:14:1: error: expected external declaration
```

The SunOS C++ compiler reported one error, which is more decipherable:

```shell
 "{" expected not double
```

So it is possible that fi xing the fi rst error might correct many other errors. It is also true that fi xing one error might let the compiler fi nd new ones! Try to concentrate on the fi rst error your compiler reports. Th e compiler usually, but not always, will be able to approximate the location of the error in your source code. The error may be on the line above, or many lines above.

Also, realize that all statements must be terminated by a semicolon “;”. Excluding this statement terminator, or putting it in where it doesn’t belong, causes compile time errors. Missing semicolon errors are not usually detected until the compiler has already gone past the line with the offense, so look at the statement above the location of the error.

### 2.5.2 WARNINGS GENERATED AT COMPILE TIME

Compilers also generate warnings, which are messages intended to help programmers avoid errors later on. Consider the following code:

```C++
#include <iostream>
using namespace std;

int main() {
    double x, y;
    y = 2 * x;
    cout << y << endl;
}
```

**SELF-CHECK**

2-18 What is the output of the preceding program?

The preceding program has an error, but none that the compiler will catch. Th e compiler happily translated the source code into machine code and the linker created an executable program. However, the output from two program runs were the rather inexplicable numbers 1.09087e+82 and later 1.39064e-309. With another compiler, the output was 0. Fortunately some compilers generate warnings like these:

```shell
Warning: Possible use of 'x' before de nition in main()
Warning: 'x' is used uninitialized in this function
```

The warning states that x has been used before it was defined (initialized, actually). Th is is a good warning that should not be ignored. Th e program does not initialize x. It has an unknown state  sometimes referred to as garbage. Unfortunately, not all compilers will warn you of this potential error.

This is not a violation of any C++ rule. It is legal to declare a variable without an initial value. However, this warning should not be ignored. You should read it and make sure x has an initialized state before using the object in an arithmetic expression.

This is but one example of a warning. You will see more. You will likely ignore many. However, warnings are hints that something may go wrong and the program will not be correct. If you are getting incorrect results, look to see if there are any warnings—they may be clues to the source of the error.

### 2.5.3 LINKTIME ERRORS

Computer systems use a linker to combine pieces of machine code to create executable programs. Among other things, the linker must resolve details such as locating the identifi er main in one of these files. If main is not found during the linking process, the linker generates an error that displays main is an undefi ned symbol. If this takes place, verify that your program starts with int main.

```C++
int main() {
    // . . .
}
```

Make sure that main is not typed as mane, Main, or MAIN.

Another linktime error occurs when you have two fi les with the required int main(). For example, you may soon try to have two programs in the same folder when completing programming projects. The following linktime error message indicates initials.cpp and average.cpp both had int main() functions in the same directory named src:

```shell
ld: duplicate symbol main () in ./src/initials.o and ./src/average.o
```

One solution is to not link both of them. But if you are using an integrated development environment such as Eclipse, Visual Studio, or XCode, make sure you have only one fi le in your project with the main method.

### 2.5.4 RUNTIME ERRORS

A program may execute after all compile time errors have been removed and the linker has created an executable program. But errors may still occur while the program is running. A runtime error may cause the program to terminate before it should because some event occurs that the computer cannot handle.

For example, when your program is expecting an integer, and the user enters a fl oating-point number, the input stream cin becomes  corrupted. Consider the same program run twice, the fi rst time with good input and once with “bad” input; a fl oating-point number such as 1.2 instead of an integer.

```C++
#include <iostream>
using namespace std;

int main() {
    int anInt, anotherInt;

    cout << "Enter anInt: ";
    cin >> anInt;
    cout << "anInt: " << anInt << endl;

    cout << "Enter anotherInt: ";
    cin >> anotherInt;
    cout << "anotherInt: " << anotherInt << endl;

    return 0;
}
```

With good input, the user can enter two integers:

```shell 
Enter anInt: 7
anInt is 7
Enter anotherInt: 9
anotherInt is 9
```

With non-integer input, 1.2 cannot be assigned to an int, so it is not. Th en the second input is not allowed and the user cannot even try to enter a number (the output of 0 will vary since anotherInt is undefined):

```shell
Enter anInt: 1.2
anInt: 1
Enter anotherInt: anotherInt: 0
```

### 2.5.5 INTENT ERRORS

Even when no compile time errors are found and no runtime errors occur, the program still may not execute properly. A program may run and terminate normally, but it may not be correct. Let’s make one small change to an earlier program to get an incorrect program.

    cout << "Average: " << (n / sum);

The interactive dialogue may now look like this:

```shell
Enter sum: 291
Enter n: 3
Average: 0.010309
```

Such intent errors occur when the program does what was typed, not what was intended. Unfortunately, the compiler does not locate intent errors. Th e expression n/sum is syntactically correct—the compiler just has no way of knowing that this programmer intended to write sum/n instead.

Intent errors are the most insidious and usually the most difficult to correct. Th ey may also be diffi cult to detect—the user, tester, or programmer may not know they even exist.

**SELF-CHECK**

2-19 Assuming a program is supposed to fi nd an average given the total sum and number of values in a set, then the following dialogue is generated. What clue reveals the presence of an intent error?

```shell
Enter sum: 100
Number : 4
Average : 0.04
```

2-20 Assuming the following code was used to generate the dialogue above, how is the intent error to be corrected?

```C++
cout << "Enter sum: ";
cin >> n;
cout << "Number :";
cin >> sum;
average = sum / n;

cout << "Average : " << average << endl;
```

2-21 List the type of error (compile time, runtime, linktime, or intent) or warning that exists when the last statement in the preceding program is changed to:

`a.  cout << "Average: " << "sum / n";`

`b.  cout << "Average: ", sum / n;`

`c.  cout << "Average: " << sum / n`

### 2.5.6 WHEN THE SOFTWARE DOESN’T MATCH THE SPECIFICATION

Even when a process has been automated and delivered to the customer in working order according to the developers, there may still be errors. Th ere have been many instances of software working, but not doing what it was supposed to do. Th is could be from a failure to meet the problem statement, which occurs when the software developers don’t understand the customer’s problem statement. Something could have been missed. Something could have been misinterpreted. A related error occurs when the client specifi es the problem incorrectly. This could be the case when the requester isn’t sure what they want. A trivial or critical omission in specifi cation may occur, or the request may not be written clearly. Also, the requester may change their mind after problem solving has begun.

For the most part, the end-of-chapter programming projects in this textbook ask you to fulfi ll the problem specifi cation. If you think there is an omission or there is something you don’t understand, don’t hesitate to ask questions. It is better to understand the problem and know what it is that you are to trying to solve before getting to the design and implementation phases of problem solving. Although not intended, the problem may be incorrectly or incompletely specified—this does actually happen in the real world!

## CHAPTER SUMMARY

* The smallest pieces of a program (tokens) were shown to help you understand general forms and fix errors.
* Objects are entities that have a name, state (value), and operations. Output (cout &lt;&lt;) and input (cin &gt;&gt;) operations are used in concert with double and string objects to set their states. Th ere are at least three techniques for modifying the state of an object:
  * initialization with double x = 0.0;
  * input with cin &gt;&gt;
  * assignment with =
* Knowledge of existing objects aids the program development process. For example, knowing about cin, cout, string, and numeric objects such as int and double precludes the necessity of implementing many intricate operations such as input, output, addition, and multiplication. Fortunately, other programmers have already built them.
* The objects named std::cout and std::cin are so frequently used that they are automatically made available for easy screen output and keyboard input with \#include &lt;iostream&gt;. If you add using namespace std; you do not have to precede cout, cin, and endl with std:: .
* Arithmetic expressions are made up of operators +, -, \*, /, and % (remainder). A binary arithmetic operator requires two operands, which may be numeric constants such as 1 and 2.3, numeric objects, or other arithmetic expressions.
* Instances of the Prompt then Input pattern will occur in many programming projects. Use it whenever a program needs to get some input from the user.
* When / has two integer operands, the result is an integer, so 5 / 2 is 2.
* When / has at least one floating-point operand, the result is a floating-point number, so 5 / 2.0 is 2.5.
* The % operator returns the integer remainder of one integer operand divided by another, so 5 % 2 is 1.
* The % operator cannot have a floating-point argument, so 5 % 2.0 is a compile time error.
* Be careful in choosing int and double. Always use double to store numbers unless it makes sense that the object can only store integers.
* This chapter ended with a discussion of the variety of errors that occur during implementa-tion. You will continue to encounter errors. It is part of the process.
* Errors may be present because the problem statement was incorrect or incomplete.
* Intent errors eventually prove to be the most difficult to fix—they can be diffi cult to detect.

## EXERCISES

1. List three operations that may be applied to numeric types like double.
2. Describe the value(s) stored in string objects.
3. List three operations that may be applied to any string object.
4. List four types of C++ tokens and give two examples of each.
5. Which of the following are valid identifi ers?

| | |
|-|-|
|`a.    a-one`  |`g.   1_2_3` |
|`b.    R2D2`   |`h.   A_B_C` |
|`c.    registered\_voter`|`i.   all right`|
|`d.    BEGIN` |`j. 'doubleObject'` |
|`e.    1Header` |`k.   {Right} |
|`f.    $money` |`l.   Mispelt` |

6. Declare totalPoints as an object capable of storing a number. 
7. Write a statement that sets the state of totalPoints to 100.0.
8. Write the entire dialogue generated by the following program when 5.2 and 6.3 are entered at the prompt. Make sure you write the user-supplied input as well as all program output including the prompt.

```C++
#include <iostream>
using namespace std;
int main() {
    double x = 0.0;
    double y = 0.0;
    double answer = 0.0;
    cout << "Enter a number: ";
    cin >> x;
    cout << "Enter another number: ";
    cin >> y;
    answer = x * (1.0 + y);
    cout << "Answer: " << answer << endl;
    return 0;
}
```

9. Write C++ code that declares tolerance as a numeric object set to 0.001 that cannot be changed while the program is running.
10. Write a statement that displays the value of a numeric object named total.
11. Given these two object initializations, either write the value that is stored in each object or report the attempt as an error.

```C++
string aString;
double aNumber = 0.0;
```

| | |
|-|-|
|`a.    aString = "4.5";` |`c.  aString = 8.9;` |
|`b.    aNumber = "4.5";` |`d.  aNumber = 8.9;` |

12. With paper and pencil, write an entire C++ program that prompts for a number from 0.0 to 1.0 and stores this input value into the numeric object named relativeError. Echo the input (output the input). Th e dialogue generated by your program should look like this:

```shell
Enter relativeError \[0.0 through 1.0\]: 0.341
You entered: 0.341
```

13. Assuming x is 5.0 and y is 7.0, evaluate the following expressions:
  * a.  `x / y`
  * b.  `y / y`
  * c.  `2.0 - x * y`
  * d.  `(x*y)/(x+y)`

14. Predict the output generated by these two programs:

* a.

```C++
#include <iostream>
using namespace std;
int main() {
    double x = 1.2;
    double y = 3.4;
    cout << (x + y) << endl;
    cout << (x - y) << endl;
    cout << (x * y) << endl;
    cout << (x / y) << endl;
    return 0;
}
```

* b.

```C++
#include <iostream>
using namespace std;

int main() {
    double x = 0.5;
    double y = 2.3;
    double answer = 0.0;
    answer = x * (1 + y);
    cout << answer << endl;
    answer = x / (1 + y);
    cout << answer << endl;
    return 0;
}
```

15. What is the value of quarter when change is initialized as follows:

* a.  0
* b.  74
* c. 49
* d. 549

```C++
int change = (one of the following: 0 , 74, 49, and 549);
int quarter = change % 50 / 25;
```

16. Is this code correct?

```C++
const double EPSILON = 0.000001;
EPSILON = 999999.9;
```

17. Write C++ code that generates a runtime error and give the reason for the error.

18. At what time will the error in this code be detected?

```C++
#include <iostream>
using namespace std;
int Main() {
    cout << "Hello world";
    return 0;
}
```

19. Explain how to fi x the error in each of these lines:

* a.  `cout << "Hello world"`
* b.  `cout << "Hello world";`
* c.  `cout "Hello World";`
* d.  `cout << "Hello World;`

20. Explain the error in this attempt at a program:

```C++
int main() {
    cout << "Hello world";
    return 0;
}
```

21. Describe the phrase *intent error*.

22. Does the following code always correctly assign the average of the three doubles x, y, and z to average? double average = x + y + z / 3.0;

23. Evaluate the following expressions. Use a decimal point to distinguish integer and floating point values.

    a.  5 / 2 d. 5.0 / 2.0

    b.  5 / 2.0 e. 1.0 + 2.0 - 3.0 \* 4.0

    c.  101 % 2 f. 100 % 2

18. Write the output generated by the following programs:

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  a.   \#include &lt;iostream&gt; using namespace std; int main() { const int MAX = 5; cout &lt;&lt; (MAX / 2.0) &lt;&lt; endl; cout &lt;&lt; (2.0 / MAX) &lt;&lt; endl; cout &lt;&lt; (2 / MAX) &lt;&lt; endl; cout &lt;&lt; (MAX / 2) &lt;&lt; endl; return 0;   c.
                                                                                                                                                                                                                                                                   
       }                                                                                                                                                                                                                                                           > \#include &lt;iostream&gt; using namespace std;
                                                                                                                                                                                                                                                                   >
                                                                                                                                                                                                                                                                   > \#include &lt;string&gt; int main() {
                                                                                                                                                                                                                                                                   >
                                                                                                                                                                                                                                                                   > const string pipe = " ¦ "; cout &lt;&lt; pipe &lt;&lt; (1 + 5.5) &lt;&lt; pipe &lt;&lt; (3 + 3 / 3)
                                                                                                                                                                                                                                                                   >
                                                                                                                                                                                                                                                                   > &lt;&lt; pipe &lt;&lt; (1 + 2) / (3 + 4)
                                                                                                                                                                                                                                                                   >
                                                                                                                                                                                                                                                                   > &lt;&lt; pipe &lt;&lt; (1 + 2 \* 3 / 4); return 0;
                                                                                                                                                                                                                                                                   >
                                                                                                                                                                                                                                                                   > }
  ---- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- -------------------------------------------------------------------------------------------------------
  b.   \#include &lt;iostream&gt; using namespace std; int main() { int j = 14; int k = 3;                                                                                                                                                                         d.
                                                                                                                                                                                                                                                                   
       cout &lt;&lt; "Quotient: "                                                                                                                                                                                                                                  > \#include &lt;iostream&gt; using namespace std; int main() { int j = 11;
                                                                                                                                                                                                                                                                   >
       &lt;&lt; (j / k) &lt;&lt; endl; cout &lt;&lt; "Remainder: " &lt;&lt; (j % k) &lt;&lt; endl; return 0;                                                                                                                                                       > cout &lt;&lt; " " &lt;&lt; (j % 2) &lt;&lt; " " &lt;&lt; (j / 2)
                                                                                                                                                                                                                                                                   >
       }                                                                                                                                                                                                                                                           > &lt;&lt; " " &lt;&lt; ((j - j) / 2); return 0;
                                                                                                                                                                                                                                                                   >
                                                                                                                                                                                                                                                                   > }
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROGRAMMING TIPS

1.  Semicolons terminate statements. Make sure you terminate statements
    > with ;. However, do not place semicolons after \#includes and
    > int main().

> \#include &lt;iostream&gt; ; // Error found on this line int main() ;
> // Error found on this line {

1.  Fix the fi rst error fi rst. When you compile, you may get dozens
    > of errors. Don’t panic. Try to fi x the very fi rst error fi rst.
    > Th at may fi x several others. Sometimes fi xing one error
    > causes others. After fi xing one error, the compiler may generate
    > errors that went undetected before.

2.  Integer arithmetic behaves unexpectedly for some students. Integer
    > division results in an integer. Th erefore 5 / 2 is 2, not the 2.5
    > your brain and calculator feel are so right.

3.  Th e % arithmetic operator returns an int remainder. Experience
    > shows some students never understand %, or at least they still get
    > the wrong answers on the fi nal exam. Th e expression a % b is the
    > integer remainder after dividing a by b.

  99 % 50 = 49           > 101 % 2 = 1
  ------------------- -- ---------------
  99 % 50 % 25 = 24      > 102 % 2 = 0
  4 % 99 = 4             > 103 % 2 = 1

1.  If you do not have the line using namespace std; you will have to
    > prepend std:: before every occurrence of the cin, cout, and endl.

> \#include &lt;iostream&gt; // For cout, cin, and endl
>
> // using namespace std; Without this, prepend with std::
>
> int main() { std::string name; std::cin &gt;&gt; name;
>
> std::cout &lt;&lt; "Hello" &lt;&lt; std::endl; std::cout &lt;&lt; name
> &lt;&lt; std::endl; }

**PROGRAMMING PROJECTS**

2A THE CLASSIC “HELLO WORLD!” PROGRAM

> While designing the C language at AT&T, Dennis Ritchie suggested that
> a fi rst program in any language be one that displays Hello World!
> Many fi rst programs have continued this “Hello World!” tradition.
> Create a new fi le called hello.cpp and retype the following code as
> shown. Save this fi le and use the instructions particular to your
> setup to compile, link, and run this program.

Programming Projects

> // Programmer: Firstname Lastname // This programs displays a simple
> message.
>
> \#include &lt;iostream&gt; // For cout
>
> using namespace std; // Allow cout instead of std::cout
>
> int main() {
>
> cout &lt;&lt; "Hello World!" &lt;&lt; endl; return 0; }

2B EXPERIENCE ERRORS GENERATED BY THE COMPILER

> One small coding error may cause the report of many errors at compile
> time—this can be misleading. For example, a missing semicolon may
> result in dozens of errors throughout a program. Remember to fi x the
> fi rst error fi rst. Start by fi xing the earliest discovered error in
> the source code. You are now asked to observe what happens when a left
> curly brace is left out of a program. Carefully retype the following
> program exactly as shown.
>
> // Observe how many errors occur when { is missing
>
> \#include &lt;iostream&gt; // For cout using namespace std; // To make
> cout known
>
> int main() // &lt;- Leave off { double x = 2.4; double y = 4.5; cout
> &lt;&lt; "x: " &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; "y: " &lt;&lt;
> y &lt;&lt; endl; return 0; }

1.  Compile your source code and write the number of errors that occur.

2.  Add { after int main() and compile again. Make corrections until you
    > have no errors.

3.  Now remove the \#include directive \#include &lt;iostream&gt; and
    > compile the program. How many errors do you get?

4.  Replace \#include &lt;iostream&gt; and remove the () after main. How
    > many errors do you get?

5.  Comment out using namespace std;. How many errors do you get now?

6.  If necessary, edit and compile this program until there are no
    > compile time errors. Link and run the program.

2C BIG INITIALS

> Write a C++ program that displays your initials on the screen in large
> letters. Th ere are no input or process steps, only output. For
> example, if your initials are E. T. M., the output should look like
> this generated by fi ve cout statements:
>
> EEEEE TTTTTTT M M
>
> E T M M M M
>
> EEEEE T M M M
>
> E T M M
>
> EEEEE o T o M M o

2D YODA

> Write a C++ program that obtains any three strings from the user and
> outputs them in reverse order with one space between them. (*Hint:* Th
> ere is no process step; only input followed by output.)
>
> Enter string one: ***happy***
>
> Enter string two: ***am***
>
> Enter string three: ***I*** I am happy

2E WEIGHTED AVERAGE

> Implement and test a C++ program that will compute the course grade
> using this weighted scale:

  *Assessment*   *Weigh*t
  -------------- ----------
  Quiz average   20%
  Midterm        20%
  Lab grade      35%
  Final exam     25%

> One dialogue should look like this:
>
> Enter Quiz Average: ***90.0***
>
> Enter Midterm: ***90.0***
>
> Enter Lab Grade: ***90.0***
>
> Enter Final Exam: ***90.0*** Course Average = 90

2F SECONDS

> Write a program that reads a value in seconds and displays the number
> of hours, minutes, and seconds represented by the input. Here are two
> sample dialogues:

Enter seconds: ***32123*** Enter seconds: ***61***

8:55:23 0:1:1

2G MINIMUM COINS

> Write a C++ program that prompts for an integer that represents the
> amount of change (in cents) to be handed back to a customer in the
> United States. First, display the minimum number of half dollars,
> quarters, dimes, nickels, and pennies that will make the correct
> change. (*Hint*: With increasingly longer expressions, you could use /
> and % to evaluate the number of each coin. Or

Programming Projects

> you could calculate the total number of coins with / and the remaining
> change with %.) Verify that your program works correctly by running it
> with a variety of input. Here are two sample dialogues:

  -------------------------------------------------------------------------------------------------------------------------------------------------
  Enter change \[0...99\]: ***83***                                       Enter change \[0...99\]: ***14***
                                                                          
  Half(ves) : 1 Quarter(s) : 1 Dime(s) : 0 Nickel(s) : 1 Penny(ies) : 3   > Half(ves) : 0 Quarter(s) : 0 Dime(s) : 1 Nickel(s) : 0 Penny(ies) : 4
  ----------------------------------------------------------------------- -------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------

2H EINSTEIN’S NUMBER

> It is said that Albert Einstein used to take great delight in baffl
> ing friends with the following puzzle. It could be repeated something
> like this:

-   Write 1089 on a piece of paper, fold it, and hand it to another
    > for safekeeping.

-   Ask someone else to write down any three-digit number, emphasizing
    > that the fi rst and last digits must diff er: 654 is okay, while
    > 454 and 656 are not allowed.

-   Reverse that written down number: if starting with 654, write 456.

-   Compute the diff erence of the written down three digit number and
    > its reverse: use

> abs(456-654) = 198

-   Once this is done, reverse the new number: 198 becomes 891.

-   Th en add the new number to its reverse: 198 + 891 = 1089.

> If all goes as planned, observers will be amazed. Th e number written
> down at the start, 1089, will always be the same as the end result of
> this mathematical trick. Replicate this puzzle as a C++ program. Your
> program dialogue must look like this when the user enters 541.
>
> Enter a 3 digit number ( rst and last digits must differ): ***541***
>
> 541 -- original
>
> 145 -- reversed
>
> 396 -- difference
>
> 693 -- reverse of the difference
>
> 1089 -- difference + reverse of the difference
>
> You don’t need to error check the three-digit number. Assume input is
> in the range of 100 to 998 where the fi rst and third digits are not
> the same. 101, 252, or 989 are not expected to generate 1089. (*Hint:*
> To fi nd the diff erence between two numbers, use the absolute value
> function abs. Th e argument is an expression that subtracts two
> numbers. You may need to \#include &lt;cstdlib&gt;.)
>
> \#include &lt;cstdlib&gt; // A new include
>
> \#include &lt;iostream&gt; using namespace std; int main() {
>
> // abs is a new function that can return the difference
>
> // between two numbers by subtracting one from the other.
>
> cout &lt;&lt; abs(541 - 145) &lt;&lt; endl; // 396 cout &lt;&lt;
> abs(145 - 541) &lt;&lt; endl; // 396 return 0; }

2I TIME DIFFERENCE

> Write a C++ program that takes two diff erent train departure times
> (where 0 is midnight, 0700 is 7:00 a.m., 1314 is 14 minutes past 1:00
> p.m., and 2200 is 10 p.m.) and prints the diff erence between the two
> times in hours and minutes. Assume both times are on the same date and
> that both times are valid. For example, 1099 is not a valid time
> because the last two digits are minutes, which should be in the range
> of 00 through 59. 2401 is not valid because the hours (the fi rst two
> digits) must be in the range of 0 through 23 inclusive. For example,
> if train A departs at: 1255 and train B departs at: 1305 the diff
> erence would be 0 hours and 10 minutes. One dialogue should look like
> this, but run your program several times for several test cases.
>
> Train A departs at: ***1255***
>
> Train B departs at: ***1305***
>
> Difference: 0 hours and 10 minutes
