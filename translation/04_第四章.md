# 第四章 自由函数的实现

**前章回顾**

C++中有许多可供所有程序员重用的自由函数，我们可以通过访问`http://www.cplusplus.com/reference`来获取这些函数的文档。在编程过程中，将相关的代码组合成一个定义明确的函数，以供日后测试并调用，已经被认为是一种非常好的实践经验，这有助于我们构建出可读性更强的程序。但C++本身不可能提供我们每个人在所有应用场景中所需要用到的函数。

**本章提要**

本章将重点介绍如何编写属于自己的函数。我们希望在完成本章的学习之后，你将掌握：

* 如何实现自由函数。
* 如何传递相关的值给你的函数，以作为它的输入。
* 如何从你的函数中返回相对值，以作为它的输出。
* 如何测试你的新函数。
* 初步理解对象与函数的所在域。

## 4.1 实现属于自己的函数

从上一章提到的那些函数（譬如`min`、`max`、`abs`、`round`和`sqrt`）可以看出，函数的定义应该是一个函数头信息加上一个语句块。

**通用格式 4.1**： *自由函数*

> *function-heading* <br>
> *block*

其中，*block*是一个以`{`开头，并以`}`结尾的语法单元，其内容主要由变量声明和执行语句等部分组成。

**通用格式 4.2**: *语句块*

> { <br>
> *object-initializations* <br>
> *statements* <br>
>}

函数的输入就是调用该函数的实参。在获取输入之后，函数会利用这些输入值计算出某个结果，然后将其返回给它的调用者。我们之前已经介绍过如何通过实参与形参关联配对的方式将值输入到函数中，下面我们来介绍如何通过返回语句将值传回给调用该函数的代码。

**通用格式 4.3**： *返回语句*

> return *expression* ;

我们可以具体示范一下将值返回给调用方代码的做法：

```C++
int minOf3(int a, int b, int c) {
    // post: Return the smallest value amongst the 3 arguments
    return min(a, min(b, c));
}
```

当程序执行到返回语句时，`return`后面的表达式将会实际替换掉调用方代码调用该函数的位置，以作为程序控制权返回的地方。接下来，我们来实现一个名为`f`的函数$f(x) = 2x^2−1$。需要提醒的是，这个函数的编码必须写在调用它的函数之前，也就是说，函数`f`必须位于调用它的`main`函数之前。

```C++
#include <iostream>          // For cout
#include <cmath>             // For pow
using namespace std;

double f(double x) { // post: Return 2 * x * x - 1
    double result;
    result = 2 \* pow(x, 2) - 1.0;
    return result;
}

int main() {
    double x, y;
    cout << "Input x: ";
    cin >> x;
    // Call function f:
    y = f(x);
    cout << "f(" << x << ") = " << y << endl;
    return 0;
}
```

**程序会话**

```shell
Input x: ***1.01***
f(1.01) = 1.0402
```

**自检题**

4-1 请根据之前示例中实现的$f(x) = 2x^2−1$，写出下列函数调用的返回值，如果调用出错，请说明出错原因。

* a. `f(0.0)`
* b. `f(-2.0)`
* c. `f(3)`
* d. `f(1, 2)`
* e. `f()`
* f. `f(5.8)`

在接下来的这个示例中，函数`serviceCharge`所声明的返回值类型是`double`，因此调用`serviceCharge`函数的地方将会被替换成某个`double`值，而该值则取决于其调用实参的值。

```C++
// Call serviceCharge to determine a bank debit
#include <iostream>
using namespace std;

const double MONTHLY_FEE = 5.00;

double serviceCharge(int checks, int ATMs) {
    // pre: checks >= 0 and ATM >= 0
    // post: Return a banking fee based on local rules
    double result;

    result = 0.25 * checks + 0.10 * ATMs + MONTHLY\_FEE;
    return result;
}

int main() {
    // 0. Initialize objects
    int checks;
    int ATMs;
    double fee; // Stores the function return result

    // 1. Input
    cout << "Checks this month? ";
    cin >> checks;
    cout << "ATMs this month? ";
    cin >> ATMs;

    // 2. Process
    fee = serviceCharge(checks, ATMs); //Call to serviceCharge

    // 3. Output
    cout << "Fee: " << fee << endl;

    return 0;
}
```

**程序会话**

```shell
Checks this month? ***17***
ATMs this month? ***9***
Fee: 10.15
```

Here is what happens when the preceding program runs:

1. The user is asked to supply input for the number of checks and ATM transactions.
2. The values of the arguments (17 and 9) are assigned to the parameters of serviceCharge (checks = 17 and ATMs = 9). These particular values will be used by the function to return the proper monthly bank fee.
3. The statements in serviceCharge execute.
4. The return is encountered in serviceCharge.
5. The function call serviceCharge(checks, ATMs) in main is replaced by the returned value of 10.15.
6. The function’s return value is assigned to fee.
7. The fee is displayed.

### 4.1.1 TEST DRIVERS

When a function requires arguments, it is not unusual to have the same variable name declared in two different places. Consider the previous program that declares checks and ATMs in main and also as parameters within the function serviceCharge. The objects declared in main are used to obtain user input. The parameters declared in serviceCharge obtain input from main. Although they have the same names, they are different variables.

Sometimes the duplication of parameter names in main is not required. In the next program, you’ll see there is no user input, so the duplicated objects are not necessary. Instead, the arguments used to test the function are constants. Rather than being assigned to another object, the program simply displays the return results. Th e only purpose of this program is to test the function—to verify that the return values are what was expected. Th is is a good thing to do before the function becomes incorporated into a larger program. In fact, many of the programming problems ask you to carry out this form of testing.

```C++
// The main function makes several calls to test a new function

#include <iostream>
using namespace std;

const double MONTHLY_FEE = 5.00;

double serviceCharge(int checks, int ATMs) {
    // pre: checks >= 0 and ATM >= 0
    // post: Return a banking fee based on local rules
    double result;
    result = 0.25 * checks + 0.10 * ATMs + MONTHLY_FEE;
    return result;
}

int main() {
    // Test drive serviceCharge          // Sample problems:
    cout << serviceCharge(0, 0) << endl; // 5.0
    cout << serviceCharge(1, 0) << endl; // 5.25
    cout << serviceCharge(0, 1) << endl; // 5.1
    cout << serviceCharge(1, 1) << endl; // 5.35
    return 0;
}
```

**Output**

```shell
5
5.25
5.1
5.35
```

This version of main is called a test driver. A *test driver* is a program with the sole purpose of testing a new function. Functions like serviceCharge, sqrt, and pow are intended to be small parts of much bigger programs. Th erefore all functions should be thoroughly tested before they are reused. The four sample problems shown above were predicted and documented in comments. Th is has been a successful  test of the serviceCharge function.

### 4.1.2 FUNCTIONS WITH ONLY A RETURN STATEMENT

Some functions are so simple, they may contain only a return statement.

```C++
double serviceCharge(int checks, int ATMs) {
    // pre: checks >= 0 and ATM >= 0
    // post: Return a banking fee based on local rules
    return 0.25 * checks + 0.10 * ATMs + MONTHLY_FEE;
}
```

However, this textbook will often use the following convention in addition to the above shortcut (one return statement):

1. Declare a local variable named result to be the same type as the function’s return type.
2. Store the desired value in result.
3. Return result.

This is extra work for simple functions. However, this pattern will help when the processing gets more complex, beginning in Chapter 7, “Selection.”

Also, the extra two lines of code are likely to prevent you from making a very common mistake. Perhaps because other languages use this technique to return values or perhaps because it simply appears to be the right thing to do, it is common to try to assign a value to the function name. This is a compile time error. You can only assign values to variables.

```C++
double serviceCharge(int checks, int ATMs) {
    // You cannot assign a value to a function name
    serviceCharge = 0.25 * checks + 0.10 * ATMs + 5.00; // ERROR
    return serviceCharge; // ERROR, attempt to return function
}
```

If you do make this common mistake, the compiler will tell you. Fix the error by placing an expression of the correct type, double, after the return.

**SELF-CHECK**

4-2 Given the following function f1, what value is returned with f1(9.0)?

```C++
double f1(double x) {
    // pre: x is zero or positive, but not 1.0
    // post: Return f(x) = (square root of x) / ( x - 1.0 )
    return sqrt(x)/(x - 1.0);
}
```

4-3 Does the function call f1(-1.5) satisfy the previous function’s precondition? What happens during a call to f1 with a negative number for an argument?

4-4 Describe how to fi x the error in each function.

* a
    ```C++
    double f1(int j);{
        return 2.5 * j;
    }
    ```
* b
    ```C++
    double f2(int) {
        return 2.5 * j;
    }
    ```
* c
    ```C++
    double f3(int x) {
        return 2.5 * j;
    }
    ```
* d
    ```C++
    double f4(double x) {
        return 2.5 * x;
    }
    ```
* e
    ```C++
    double f5(double x) {
        return double;        ;
    }
    ```
* f
    ```C++
    int f6(string s) {
        return s;
    }
    ```

4-5 Write a function times3 that returns a value that is three times greater than the argument (times3(2.0) should return 6.0).

## 4.2 ANALYSIS, DESIGN, AND IMPLEMENTATION

Rather than writing a program, consider a problem that implements a function that may be a very small part of a large program. It may represent just one step of an algorithm, but it is frequently called.

*Problem:* Compute the distance between two points.

### 4.2.1 ANALYSIS

Recall that the analysis phase of program development involves determining input and output. Also recall that while developing computer-based solutions to problems involving the IPO algorithmic pattern, the developer determines the output that must be sent to the user and also determines the input required from the user. Replace the word *user* with *client* in the preceding sentence, and the IPO pattern can be applied again to assist the design of functions. Except now the output from the function is expressed in the return statement and the input is expressed in terms of the argument/parameter associations. Here is a generalized IPO algorithm as it relates to functions instead of programs.

**IPO Pattern Applied to Functions**

* Input: Input values to the function via argument/parameter associations.
* Process: Compute the result to be returned.
* Output: Return the result.

Sample problems are a good way to confi rm understanding of a problem. Sample problems also provide expected results that can be compared to program output during program testing. It is a good idea to develop sample problems for new functions. This will help you decide what the function needs as input and, therefore, the number and class of parameters to write in the function heading. Th e sample problems also provide the expected output of the test driver. 

Four doubles are required to compute the distance between two points ($x_1$, $y_1$) and ($x_2$, $y_2$) using this formula:

$$distance = \sqrt{{(x_1 - x_2})^2 + {(y_1 - y_2)}^2}$$

Here are some predicted outputs for a few sets of values for $x_1$, $y_1$, $x_2$, and $y_2$.

**Sample Problems**

| $x_1$ | $y_1$ | $x_2$ | $y_2$ | Distance |
|-------|-------|-------|-------|----------|
| 1.0   | 1.0   | 2.0   | 2.0   | 1.414    |
| 0.0   | 0.0   | 3.0   | 4.0   | 5        |
| -5.7  | 2.5   | 3.3   | –4.7  | 11.5256  |
| 0.0   | 0.0   | 0.0   | 0.0   | 0.0      |

The IPO pattern is now applied to functions as follows:

* Input: Input two points at the function call ($x_1$, $y_1$) and ($x_2$, $y_2$)
* Process: Evaluate $\sqrt{{(x_1 - x_2})^2 + {(y_1 - y_2)}^2}$
* Output: Return the result

### 4.2.2 DESIGN

The designer must decide how many and what class of parameters are required for a function. In this example, four values are needed to represent the two input points (x1, y1, x2, and y2). Th e best class of parameters is double to allow points such as 5.62 and -9.864. The best return type is double. With the square root function involved, double helps return precise answers. A good function name is distance—it describes what the function does. This leads to a function heading with a return type of double, a function name of distance, and four descriptively named double parameters.

```C++
double distance(double x1, double y1, double x2, double y2)
// post: Return distance between two points (x1, y1) and (x2, y2)
```

Now, within the body of the function (the block), the parameters x1, y1, x2, and y2 can be used in the distance formula to compute the result.

```C++
result = sqrt(pow((x1 - x2), 2) + pow((y1 - y2), 2));
```

### 4.2.3 IMPLEMENTATION

The following program puts this all together with a main function written exclusively to test the function (a test driver):

```C++
// Call distance four times
#include <iostream> // For cout
#include <cmath> // For sqrt and pow
using namespace std;

double distance(double x1, double y1, double x2, double y2) {
    // post: Return the distance between any two points
    double result;
    result = sqrt(pow((x1 - x2), 2) + pow((y1 - y2), 2));

    return result;
}

int main() {
    // Test drive the distance function
    cout << "(1.0, 1.0) (2.0, 2.0): "
         << distance(1.0, 1.0, 2.0, 2.0) << endl;
    cout << "(0.0, 0.0) (3.0, 4.0): "
         << distance(0.0, 0.0, 3.0, 4.0) << endl;
    cout << "(-5.7,2.5) (3.3,-4.7): "
         << distance(-5.7,2.5, 3.3,-4.7) << endl;
    cout << "(0.0, 0.0) (0.0, 0.0): "
         << distance(0.0, 0.0, 0.0, 0.0) << endl; 
    return 0;
}
```

**Output**

```shell
(1.0, 1.0) (2.0, 2.0): 1.41421
(0.0, 0.0) (3.0, 4.0): 5
(-5.7,2.5) (3.3,-4.7): 11.5256
(0.0, 0.0) (0.0, 0.0): 0
```

Argument/parameter associations are analogous to program input. For example, in the second call to distance, the four values are first copied as input to the function distance.

```C++
double distance(x1,  y1,  x2,  y2)
                 ↑    ↑    ↑    ↑  
       distance(0.0, 0.0, 3.0, 4.0)
```

Control then transfers to the function where the parameters are used to compute the distance between the two points represented by those arguments. Here is the step-by-step computation:

```C++
sqrt(pow((x1  -  x2), 2) + pow((y1  -  y2), 2))
sqrt(pow((0.0 - 3.0), 2) + pow((0.0 - 4.0), 2))
sqrt(pow((  -3.0   ), 2) + pow((  -4.0   ), 2))
sqrt(           9.0      +         16.0       )
sqrt(                  25.0                   )
                        5.0                   )
```

The four arguments become input to the function as the system copies the value of each argument to its associated parameter. This particular mode of argument parameter association is known as *pass by value* because the values are passed to the function. When a function requires input of small objects such as double or int, write the function heading with value parameters of this form:

> *class-name identier*

### 4.2.4 TESTING

It is a good idea to test functions individually. The previous program did just that. It didn’t do anything else. The only purpose for this particular program was to call distance with diff erent sets of arguments and display the return results. Notice the similarity of the four calls to distance and the sample problems. The arguments are the input to the function. The return result should match the expected results.

It is recommended that you test new functions with a test driver.

### 4.2.5 SCOPE OF IDENTIFIERS

The *scope* of an identifi er is the part of a program from which an identifier can be referenced. The scope of an identifi er extends from the point of the identifi er’s declaration to the end of the block in which it is declared. Recall that a block is delimited by the left and right braces, { and }. For example, the scope of local in the following program is the function one. This local, declared in one, cannot be referenced from outside the block in which it was declared, including main.

```C++
// Illustrate the scope of an object
#include <iostream>
using namespace std;

const int maxValue = 9999;

void one() {
    int local = -1;
    // The scope of local is this function
    cout << local << endl;
    // maxValue is known after its declaration including here:
    cout << maxValue << endl;
}

int main() {
    // The scope of local is limited to one() so this is an error:
    local = 5;
    // Function one() is known everywhere after its declaration
    one();
    // maxValue is known everywhere after its declaration
    cout << maxValue << endl;
    return 0;
}
```

When a variable is declared outside of a block—as in the case of maxValue—its scope begins at the point of declaration and extends to the end of the fi le. Identifi ers declared in a block can be referenced only from within that block. Th ese are *local* identifiers. Identifi ers declared outside of a block (such as maxValue) are said to be global. *Global identifi ers* may be referenced from any subsequent part of the fi le after its declaration, unless that identifier is declared again (redeclared) within another block. In this case, the identifi er that was declared first becomes hidden from the block in which it is redeclared. Since many blocks often exist within one program, determining the scope of an object can be somewhat complicated. For example, try to predict the output of the following program, which includes three diff erent declarations of the int variable identier:

```C++
// This program is a tedious test of your ability to
// determine which of the three int variables named
// identier are being referenced at any given point.
#include <iostream>
using namespace std;

const int identier = 1; // Global variable

void one() {
    // This is a reference to the global identier
    cout << "identier in one(): " << identier << endl;
}

void two() {
    int identi er = 2; // local to two()
    cout << "identier in two(): " << identier << endl;
}

int main() {
    int identier = 3; // local to main()
    one();
    two();
    cout << "identier in main(): " << identier << endl;
    return 0;
}
```

**Output**

```shell
identier in one(): 1
identier in two(): 2
identier in main(): 3
```

When the function one is called, the global const int identier = 1 is referenced. Th is global identi er can be referenced from within any function that does not declare another identifi er named identi er. Therefore, the identi er that was declared fi rst and initialized to 1 is known (can be referenced) from one even though it was not declared inside one. But when a reference is made to identier in function two, the global identi er is hidden because of the local identi er. To this point in program execution, one has caused the output 0, and two has caused 2 to be displayed. The final statement in main references the identier local to main—this identi er is initialized as 3.

Typically, a function will have one or more variables declared at the beginning of the block. These variables are said to be local to the function because they may be referenced only from within the function. The same protection applies to the parameters of a function. Parameters are local variable declarations declared inside ( and ), rather than inside the function block. Parameters are assigned values passed to the function. Parameters can only be used inside the function block. The restriction provides safekeeping for the local objects so they are not accidentally altered from some other portion of a program.

```C++
void f1(double x) {
    int local = 0;
    str = "A"; // Error attempting to reference main's local str
}

int main() {
    string str; // str is local to main
    x = 5.0; // Error attempting to reference f1's parameter x
    local = 1;
    // Error attempting to reference f1's local return 0;
}
```

**SELF-CHECK**

4-6 Use the partial program shown below to determine the functions from which each of the following identifiers may be referenced. cin and cout are initialized in iostream so they are known after #include
 <iostream>.

```C++
// cout b cin MAX c f1 a d f2 main e
#include <iostream>
using namespace std;

const int MAX = 999;

void f1(int a) {
    int b;
}

void f2(double c) {
    double d;
}

int main() {
    int e;
    return 0;
}
```

4-7 Name two things that may be declared local to a function.

4-8 If a variable is declared outside of a function, from where may it be referenced?

### 4.2.6 SCOPE OF FUNCTION NAMES

Now what about function names? After all, they too are identifiers. What is their scope? Like cin and cout, the scope of functions in an included fi le like cmath also extends to the end of their own file and any fi le with #include <cmath>. So functions such as sqrt, pow, ceil, and fabs may be called from within any block unless the function name is re-declared to be something else.

### 4.2.7 GLOBAL IDENTIFIERS

The problems presented so far are not relatively complex. They are certainly not large. You have probably been working pretty much on your own. However, when programs get large with a team, practice caution with scope.

Global identifiers are known everywhere after they are declared. This opens them up for accidental alteration from anywhere in a very large program. It is diffi cult to ensure that no one will accidentally modify an object at the wrong time. So try to get in the habit of using local objects everywhere possible. This means you use parameters between ( and ) and objects between { and }. For example, main declares localX and localY locally.

```C++
int main() {
    double localX, localY;
    // . . .
}
```

If you need to move data between functions, pass them as arguments. This means you must declare parameters rather than having some global x.

```C++
double f(double x) { // x is local to f
    double result; // result is local to f
    // Do something with x . . .
}
```

If you need a value in many places throughout a program, make it const.

```C++
#include <iostream>
using namespace std;

const int MAXIMUM_ENTRIES = 100; // ... a large program with many functions may follow
```

On the other hand, C++ often uses global identifi ers. Consider the fact that after including <iostream>, cout is known everywhere, assuming using namespace std; is written before cout is referenced (left column following) or cout is qualified with std:: (right column).

```C++
#include <iostream>
using namespace std;

void f() {
    cout << "In f\\n";
}

void g() {
    cout << "In g\\n";
}

int main() {
    f();
    g();
    cout << "In main\\n";
    return 0;
}
```

```C++
#include <iostream>
// Equivalent code with std::
void f() {
    std::cout << "In f\\n";
}

void g() {
    std::cout << "In g\\n";
}

int main() {
    f();
    g();
    std::cout << "In main\\n";
    return 0;
}
```

In effect, using namespace std; makes cout a global identifier. Is this okay? Well, a lot of computer scientists believe so. There is usually only one console, so any output to cout will go to the same console, no matter which function sends output to it.

## 4.3 void FUNCTIONS & REFERENCE PARAMETERS

The keyword void is used as the return type of functions that do not return anything. Instead of returning values back to the client, void functions are often employed to modify the state of the object(s) passed to them. Th is section shows a void function called swap, which modifies two arguments. A function must use a reference parameter—with & added—to modify the state of the object(s) in the function call. Here is the general form.

**General Form 4.4** *Reference Parameter*

> *class-name* & *identier*

**Examples of reference parameters in function headings**

```C++
void swap(double & parameterOne, double & parameterTwo) void
changeFormat(ostream & cout)
```

A change to a reference parameter (with &) also modifies the associated argument. Th e parameter name is a reference to—memory location of—the associated argument.

Although parameters typically obtain input from the caller, they can sometimes establish a stronger connection between argument and parameter. In this first example of reference parameter usage, the swap function must modify two objects. Since only one value can be returned through a return statement, the function requires something besides the return statement to communicate more than one value back to the caller. Th is is accomplished when the special symbol & is placed before the parameter name in the function heading. Instead of receiving a copy of the argument, the function receives the memory location or reference to that argument.

When a change is made to a reference parameter, it will change the same object referenced by the argument. Th is is because the parameter and the argument are pointing to the same object in memory. For example, in the following program, when the swap function alters the parameters parmOne and parmTwo, the arguments argOne and argTwo are also pointing to that same modifi ed object:

```C++
// Notice the reference symbol & is in front of parmOne
// and parmTwo. Now a change to parmOne or parmTwo alters
// the associated object that is the argument's value.

#include <iostream>
using namespace std;

// Swap the values of any two int arguments.
// The & lets any change to the parameter alter it argument
void swap(int & parmOne, int & parmTwo) {
    int temp = parmOne;
    parmOne = parmTwo; // Change argument argOne in main
    parmTwo = temp;    // Change argument argTwo in main
}

int main() {
    int argOne = 89; // argOne argTwo
    int argTwo = 76;

    cout << argOne << " " << argTwo << endl; // 89 76
    swap(argOne, argTwo);
    cout << argOne << " " << argTwo << endl; // 76 89

    return 0;
}
```

**Output**

```shell
  89             76
  76             89
```

If the ampersands (&) are removed from the program above, no change is made to the arguments in main. In this case, the values of argOne and argTwo would be passed by value, not by reference. Without the reference symbol &, the values of parmOne and parmTwo are changed locally, within swap only. Th e values of the associated arguments in main are unaff ected because they are diff erent objects.

The following fi gures illustrate the diff erence between reference and value parameters.

**Reference parameters:** *argument and parameter reference the same object*

```C++
parmOne = address of argOne and parmTwo = address of argTwo

void swap(int & parmOne, int & parmTwo) {
    parmOne
    parmTwo 89-  76  parmOne points to the memory location of argOne and then changes contents from 89           76-  89  to 76 in swap. This affects the same object pointed to by argOne.

}

int main() {
    argOne
    argTwo           parmTwo points to the memory location of argTwo and then changes contents from 76                    to 89 in swap. Th is affects the same object pointed to by argTwo.

}
```

**Value parameters:** *a change to the parameter does not change the associated argument*

```C++
parmOne = 89 (value of argOne) and parmTwo = 76(value of argTwo)

void swap(int parmOne, int parmTwo) {
    parmOne   89- 76    parmTwo Since values are passed to the swap function, when the
              76- 89    swap occurs locally, it does not aff ect the variables in a 
                        different function.

}

int main() { 
    argOne    89
    argTwo    76
                 Values in main are not aff ected when their values are
                “passed by value”.
}
```

Because a change to a reference parameter changes the argument, the argument must be a variable. Using a literal value or larger expression results in a compile time error.

Values in main are not aff ected when their values are

```C++
swap(89, 76); // Error: Argument must be a variable
```

**SELF-CHECK**

4-9 Write the values of arg1 and arg2 at the moment when return 0; executes.

* a.
    ```C++
    #include <iostream>
    using namespace std;
    void changeOr(int a, int b) {
        a = a * 2 + 1;
        b.  = 123;
    }

    int main() {
        int arg1 = 5;
        int arg2 = 5; changeOr(arg1, arg2); // arg1 ____ arg2 _____
        return 0;
    }
    ```

* b.
    ```C++
    #include <iostream>
    using namespace std;
    void changeOr(int & a, int & b) {
        a = a * 2 + 1;
        b = 123;
    }

    int main() {
        int arg1 = 5;
        int arg2 = 5;
        changeOr(arg1, arg2); // arg1 ____ arg2 ____
        return 0;
    }
    ```

## 4.4 CONST REFERENCE PARAMETERS

You have now seen two of the three parameter passing modes in C++:

1. value parameters—for passing the values of small objects such as int
2. reference parameters—to allow a function to modify the state of one or more arguments
3. const & (reference) parameters—for safety and effi ciency

A const reference parameter is typically used to pass a “big” object that is not to be modifi ed by the function. A big object is one that requires a lot of memory, a very large string for example. To understand why programmers pass large objects by const reference, consider what happens when arguments are passed into functions.

When passed by value, the entire object is copied into another variable of the same size in the function, which requires twice the memory. For reference parameters, the address of the object is copied to the function, which is only four bytes of memory. In this case, the argument and the parameter reference the same object. For const & parameters, the address of the object is copied to the function, again only four extra bytes of memory needed. With const, any attempt to modify the parameter in the function will be flagged as an error by the compiler. Th e const prevents accidental changes to the argument. The programmer adds const to avoid the bug of unknown modifi cation of an object in a diff erent scope.

| Pass by Value int f1(int j) | Pass by Reference int f2(string & b) | Pass by const Reference void f3(const int & n) |
|------------------------------|-------------------------------|-------------------------------|-----------------|
| Grab enough memory to store the entire object and copy all bytes to the function. A change to the parameter has no effect on the argument. | Use four bytes of memory to store the address of the object and copy that address to the function. Use this when you need to modify the argument. It’s effi cient too. | const means the argument cannot be changed. Any attempt to change n results in a compile time error. Use this for effi ciency and safety. |
| f1 ***cannot*** modify the argument’s state. | f2 ***can*** modify the argument’s state. | f3 function ***cannot*** modify the argument’s state. Th is is efficient. |

There are two reasons to use const reference parameters. The first is efficiency—the program executes more quickly. The other consideration is better memory utilization—less memory is required to store the large object in the function. For example, passing a small object such as int by value only requires the function to allocate and then copy four bytes of memory. By contrast, one large object passed by value could require thousands of bytes. Th e program might exhaust available memory.

Additionally, every single byte of an argument passed by value will be copied to the function. The computer has to do a lot of unnecessary work. The program might run noticeably slower. Here are two alternatives to make any program more efficient in terms of space (saves memory) and time (runs faster):

1. Pass big objects by reference—effi cient but somewhat dangerous.
2. Pass big objects by const reference—effi cient *and* safe.

The second option is recommended. The program now has much less work to do. When passed by values, the program must then wait until every single byte is copied from the caller to the function. If passed by const & reference, only four bytes are required while the safety of value parameters (cannot change the state of the argument) remains intact. Of course, if you are passing an argument to a function in order to modify the state, you must pass it by reference with &.

Attempts to modify objects passed by const reference result in compile time errors. Using const is an antibugging technique that will let the compiler tell us about accidental attempts to modify the const parameter. Any function that does not modify the object may still be called—string’s length function, discussed in the next chapter, for example. However, the compiler will fl ag any attempt to call functions such as string’s insert function because as the name implies, insert adds things to a string to modify the state of the string object. You cannot assign a new value to a const parameter either.

```C++
void addSomeStuff(const string & str) {
    cout << str.length() << endl; // Okay
    str.insert(5, "xtra"); // ERROR: can not modify a const parameter
    str = "new string"; // ERROR: Can not assign to a const parameter
}
```

However, when using value parameters only, you get no such error message. The argument’s object simply does not change.

| Changing x in f does not change y in the main function | This code results in a compile time error such as “cannot modify a const object” |
|--------------------------------| ------------------------------------|
| | |

```C++
#include <iostream>
using namespace std;
double f(double x) {
    double result;
    // This does not modify y
    x = x – 1.5;
    result = 2 * x;
    return result;
}
int main() {         // Output:
                        // 8
    double y = 5.0;  // y: 5
    cout << f(y) << endl;
    cout << "y: " << y << endl;
    return 0;
}
```

```C++
#include <iostream> using namespace std;
double f(const double & x) {
    double result;
    // An error. Good!
    x = x – 1.5;
    result = 2 * x;
    return result;
}

int main() {
    double y = 5.0;
    cout << f(y) << endl;
    cout << "y: " << y << endl;
    return 0;
}                                                                                                    ```
```

It should be noted that only a few objects will be passed by const reference until later. So you will only occasionally see a big object passed by const reference in the next several chapters. Also, value parameters will be more common than reference parameters.

## CHAPTER SUMMARY

* Functions perform some well-defi ned services and can have two-way communication through argument/parameter associations and the return statement. Th e client code supplies input values to the function as arguments. Th e result is returned via the return statement.
* There are several new implementation issues related to functions such as the scope of identi-fi ers:
  * All identifi ers must be declared before they can be referenced.
  * The scope of an object is limited to the block where it is declared.
  * Some identifi ers are not declared within a block. In this case, they are global identifi -ers. Examples of global identifi ers include function sqrt after \#include <cmath>, and the global object std::cout after \#include <iostream>.
  * The scope of a parameter is limited to its function.
  * The scope of a function begins at the function heading and continues to the end of its fi le, or the end of the fi le that included the function.
* There are many details to remember when using argument/parameter associations.
  * The number of arguments used in a function call must match the number of param-eters declared in the function heading.
  * The void return type precedes the function name when no value is to be returned. You cannot return anything from a void function.
  * When one value is to be returned from a function, a non-void return type must begin the function heading. Th e return statement must also be included in the function block. Th e expression in the return statement should be the same class as the return type.
  * Sometimes a function needs input—that is what parameters are for. Sometimes a function must return something—that is what the return statement is for. Sometimes a function needs to modify objects in the client code—that’s what reference parameters are for.
  * The argument used in a function call should usually be the same class as its associated parameter. There are exceptions; for example, an int argument may be assigned to a double parameter with type conversion.
  * Parameters intended only to receive copies of the argument values (input parameters) should be declared as value parameters without &.
  * Reference parameters (with &) must be used if the intention is to modify the associated argument—a change to a reference parameter alters the object reference by the argument. A change to a value parameter does not.
  * const reference parameters are used to pass large objects. Instead of consuming extra bytes of memory and copying that memory, the address is copied—because of &. However, the safety of value parameters is ensured by making the parameter const.

## EXERCISES

1. How many statements may be written in a block delimited by { }?

2. Which function is called fi rst when a C++ program executes?

3. May a function be called more than once?

4. Write the output generated by the following program:
    ```C++
    #include <iostream>
    using namespace std;
    double f2(double x, double y) {
        return 2 * x - y;
    }

    int main() {
        cout << f2(1, 2.5) << endl;
        cout << f2(-4.5, -3) << endl;
        cout << f2(5, -2) << endl;
        return 0; 
    }
    ```
5. Write the output generated by the following function:
    ```C++
    #include <iostream>
    #include <cmath>
    using namespace std;

    double mystery(double p) {
        return pow(p, 3) - 1;
    }

    int main() {
        double a = 3.0;
        cout << mystery( a) << endl;
        cout << mystery(4.0) << endl;
        cout << mystery( -2) << endl;
        return 0;
    }
    ```
6. Write a function double sumOf3 that returns the sum of any three doubles. For example, sumOf3(1.5, 2.2, 3.7) should return 7.4.

7. Write a function int maxOf4 that returns the largest of the four integer arguments. For example, maxOf4(99, 2, 99, -4) should return 99.

8. What is the scope of these identifi ers being referenced in the following code?
    * a. std
    * b. cin
    * c. MAX
    * d. aaa
    * e. string
    * f. f
    * g. result
    * h. s
    * i. cout

    ```C++
    #include <iostream>
    #include <cmath>
    using namespace std;

    const double MAX = 2.0;

    double f(double aaa) {
        double result;
        result = pow(3.0, aaa);
        return result;
    }

    int main() {
        string s = "a string";
        cout << f(MAX);
        return 0;
    }
    ```

9. Will a change to a value parameter modify the associated argument?

10. Will a change to a reference parameter modify the associated argument?

11. Write the output generated by this program:
    ```C++
    #include <iostream>
    using namespace std;

    void changeArgs(double & x, double & y) {
        x = x - 1.1;
        y = y + 2.2;
    }

    int main() {
        double a = 3.3;
        double b = 4.4;

        cout << a << " " << b << endl;
        changeArgs(a, b);
        cout << a << " " << b << endl;
        changeArgs(a, b);
        cout << a << " " << b << endl;
        return 0;
    }
    ```

## PROGRAMMING TIPS

1. Here are some common mistakes made when writing functions:
   * Placing the semicolon at the end of a function heading:
    ```C++
    string move(int n) ; // ERROR
    { // many errors agged here. Remove ; from line above
    }
    ```
    * Assigning a value to the function name:
    ```C++
    double f(double x) {
        f = 2 * x; // ERROR: Can not assign value to function
        return f;  // ERROR: Can not return a function name
    }
    ```
    The solution: Declare a local object, assign it the value, and return it. Or, in the case of simple functions, simply return the expression:
    ```C++
    double f(double x) {
        return 2 * x;
    }
    ```
    or do this when there is more going on inside the function:
    ```C++
    double f(double x) {
        double result;
        result = 2 * x;
        return result;
    }
    ```
    * Failing to return a value from a non-void function:
    ```C++
    double f2(double x) {
        double result;
        result = 2 * x;
        // ERROR: f2 must return a number
    }
    ```
    * Returning a value from a void function:
    ```C++
    void foo(double x) {
        return 2 * x; // ERROR
    }
    ```
2. There are several ways that functions communicate with each other:
    * The caller can send values and objects to a function by value.
    * The caller sends objects as arguments to a function by reference when the function is de-signed to change the arguments.
    * The caller sends objects as arguments to a function by const reference to save time and memory when the function is not supposed to change the arguments.
    * The caller gets values back from a function via the return statement.
    * The caller gets values back from a function by having the function change arguments associ-ated with reference parameters changed in the function.
3. If you want two or more values back from a function, use reference parameters. Th e return statement returns only one thing. If you need more than one thing back from a function, use one or more reference parameters in addition to a return statement.

## PROGRAMMING PROJECTS

### 4A SUM THREE

Write the function sumThree that returns the sum of three double arguments.

```C++
// Test drive sumThree
int main() {
    cout << sumThree(1.1, 2.2, 3.3) << endl; // 6.6 cout
         << sumThree(-1, -2, 3) << endl;     // 0
    return 0;
}
```

### 4B ROUNDING TO `n` DECIMAL PLACES

Write a function named round that returns the value of its double argument rounded to the number of decimal places specifi ed as the second argument.

```C++
// Test drive round
int main() {
    // Arguments: number to round (-2.9), decimal places (0)
    cout << round(-2.9, 0) << endl; // -3
    cout << round(-2.59, 1) << endl; // -2.6
    cout << round(0.0059, 2) << endl; // 0.01
    cout << round(1.23467, 3) << endl; // 1.235
    cout << round(9.999999, 4) << endl; // 10
    return 0;
}
```

### 4C PAYMENT

The payment on a loan is a function of the interest rate, the number of payments (periods), and the amount borrowed. Pass these three values as arguments to a function payment that returns the loan payment. The function heading is provided for you along with a test driver. Round your answer to two decimal places (see Section 3.2). See if your answers match an online mortgage calculator.

```C++
#include <iostream> // For the cout object
#include <cmath> // For pow, which you de nitely need here
using namespace std;

double payment(double amtBorrowed, double interestRate, int numPeriods) {
    // TODO: Complete this function
}

int main() { // Test drive payment

    // 6.0 needs to be divided by 100 and then by 12 to become a monthly
    // interest rate, The number of years (30) also needs to multiplied

    // by 12. The following test cases represent a monthly payment.
    cout << payment(185000.00, 6.0/100.0/12, 30\*12) << endl;
    cout << payment(185000.00, 5.0/100.0/12, 30\*12) << endl;
    cout << payment(185000.00, 4.0/100.0/12, 30\*12) << endl;

    return 0;
}
```

Here is the formula used to calculate payments on a loan given the amount borrowed, interest rate for one period, and the number of periods:

$$ Payment = Amount * Rate * \frac{{(Rate + 1)}^{Months}}{{(Rate + 1)}^{Months}-1} $$

### 4D POPULATION GROWTH PREDICTION

According to **http://www.census.gov/popclock/**, at the time of this writing the population growth in the United States can be predicted as follows:

One birth every *8 seconds*

One death every *13 seconds*

One international migrant (net) every *40 seconds*

Write a function that predicts the population for any number of days into the future when also given the current population. Th e following test driver must compile and generate the output shown in comments:

```C++
int main() {
    cout << populationPrediction (320000000, 0) << endl; // 320000000

    // One and two day growth:
    cout << populationPrediction(320000000, 1) << endl; // 320006314
    cout << populationPrediction(320000000, 2) << endl; // 320012628

    // One and two year growth
    cout << populationPrediction(320000000, 365) << endl; // 322304554
    cout << populationPrediction(320000000, 2\*365) << endl; // 324609108

    return 0;
}
```

Once the function has been tested, write a complete program that prompts the user for the current population and the days into the future using a dialog that looks just like this:

```shell
Predict population growth given the current population and days into the future

Current population? 320000000
Day into the future? ***365***
```

In 365 days, the population should grow by 2304554 to become 322304554

### 4E QUADRATIC FORMULA

The quadratic formula (below) uses the `a`, `b`, and `c` from quadratic equations of the form $ax^2 + bx + c$ to find both roots.

$$ x = \frac{-b + \sqrt{b^2 - 4ac}}{2a} $$

For example, the two real roots of *x*^2^ + 3*x* − 4 are 1 and −4 as indicated by this dialog and the plotting of this function:

```shell
Enter a b and c coef cients of a quadratic equation: ***1 3 -4***

roots: 1 and -4

1x^2 + 3x + -4 when x is 1 should be 0
This should be 0 or very close? 0

1x^2 + 3x + -4 when x is -4 should be 0
This should be 0 or very close? 0
```

![4-1](img/4-1.png)

You are asked to complete and test these three functions as described in the comments:

```C++
// Given the 3 coef cients, compute the two roots that
// are made accessible as reference parameters. Assignment to
// root1 and root2 also change the associated arguments.
void ndBothRoots(double a, double b, double c,
                    double & root1, double & root2)

// Evaluate any quadratic equation given the 3 coef cients
// and the root in question. This function should return 0.0,
// but something close to 0.0 like -6.66134e-16 is okay.
// This function could return nan if b^2 – 4ac < 0 or a is 0.
double evaluate(double a, double b, double c, double root)

// Generate the requested dialog using the two functions above.
int main()
```

To avoid the roots being not a number (nan) when there is a negative square root, complex numbers could be used. However, if the roots are not real, the return result is allowed to be nan (or -1.\#IND in Visual Studio as of this writing). Th e quadratic equation 3*x*^2^ + 4*x* + 2 has no real roots. Th is program run indicates there are no real roots since nan is returned with 3, 4, and 2 input for a, b, and c respectively:

```shell
Enter a b and c coef cients of a quadratic equation: ***3 4 2***

roots: nan and nan

3x^2 + 4x + 2 when x is nan should be 0
This should be 0 or very close? nan

3x^2 + 4x + 2 when x is nan should be 0
This should be 0 or very close? nan
```

