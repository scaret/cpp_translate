# 第四章 自由函数的实现

**前章回顾**

C++中有许多可供所有程序员重用的自由函数，我们可以通过访问`http://www.cplusplus.com/reference`来获取这些函数的文档。在编程过程中，将相关的代码组合成一个定义明确的函数，以供日后测试并调用，已经被认为是一种非常好的实践经验，这有助于我们构建出可读性更强的程序。但C++本身不可能提供我们每个人在所有应用场景中所需要用到的函数。

**本章提要**

本章将重点介绍如何编写属于自己的函数。我们希望在完成本章的学习之后，你将掌握：

* 如何实现自由函数。
* 如何传递相关的值给你的函数，以作为它的输入。
* 如何从你的函数中返回相对值，以作为它的输出。
* 如何测试你的新函数。
* 初步理解对象与函数的所在域。

## 4.1 实现属于自己的函数

从上一章提到的那些函数（譬如`min`、`max`、`abs`、`round`和`sqrt`）可以看出，函数的定义应该是一个函数头信息加上一个语句块。

**通用格式 4.1**： *自由函数*

> *function-heading* <br>
> *block*

其中，*block*是一个以`{`开头，并以`}`结尾的语法单元，其内容主要由变量声明和执行语句等部分组成。

**通用格式 4.2**: *语句块*

> { <br>
> *object-initializations* <br>
> *statements* <br>
>}

函数的输入就是调用该函数的实参。在获取输入之后，函数会利用这些输入值计算出某个结果，然后将其返回给它的调用者。我们之前已经介绍过如何通过实参与形参关联配对的方式将值输入到函数中，下面我们来介绍如何通过返回语句将值传回给调用该函数的代码。

**通用格式 4.3**： *返回语句*

> return *expression* ;

我们可以具体示范一下将值返回给调用方代码的做法：

```C++
int minOf3(int a, int b, int c) {
    // post: Return the smallest value amongst the 3 arguments
    return min(a, min(b, c));
}
```

当程序执行到返回语句时，`return`后面的表达式将会实际替换掉调用方代码调用该函数的位置，以作为程序控制权返回的地方。接下来，我们来实现一个名为`f`的函数$f(x) = 2x^2−1$。需要提醒的是，这个函数的编码必须写在调用它的函数之前，也就是说，函数`f`必须位于调用它的`main`函数之前。

```C++
#include <iostream>          // For cout
#include <cmath>             // For pow
using namespace std;

double f(double x) { // post: Return 2 * x * x - 1
    double result;
    result = 2 \* pow(x, 2) - 1.0;
    return result;
}

int main() {
    double x, y;
    cout << "Input x: ";
    cin >> x;
    // Call function f:
    y = f(x);
    cout << "f(" << x << ") = " << y << endl;
    return 0;
}
```

**程序会话**

```shell
Input x: ***1.01***
f(1.01) = 1.0402
```

**自检题**

4-1 请根据之前示例中实现的$f(x) = 2x^2−1$，写出下列函数调用的返回值，如果调用出错，请说明出错原因。

* a. `f(0.0)`
* b. `f(-2.0)`
* c. `f(3)`
* d. `f(1, 2)`
* e. `f()`
* f. `f(5.8)`

在接下来的这个示例中，函数`serviceCharge`所声明的返回值类型是`double`，因此调用`serviceCharge`函数的地方将会被替换成某个`double`值，而该值则取决于其调用实参的值。

```C++
// Call serviceCharge to determine a bank debit
#include <iostream>
using namespace std;

const double MONTHLY_FEE = 5.00;

double serviceCharge(int checks, int ATMs) {
    // pre: checks >= 0 and ATM >= 0
    // post: Return a banking fee based on local rules
    double result;

    result = 0.25 * checks + 0.10 * ATMs + MONTHLY_FEE;
    return result;
}

int main() {
    // 0. Initialize objects
    int checks;
    int ATMs;
    double fee; // Stores the function return result

    // 1. Input
    cout << "Checks this month? ";
    cin >> checks;
    cout << "ATMs this month? ";
    cin >> ATMs;

    // 2. Process
    fee = serviceCharge(checks, ATMs); //Call to serviceCharge

    // 3. Output
    cout << "Fee: " << fee << endl;

    return 0;
}
```

**程序会话**

```shell
Checks this month? ***17***
ATMs this month? ***9***
Fee: 10.15
```

如你所见。上述程序在运行过程中发生了以下事情：

1. 用户被要求输入自己使用支票和ATM进行交易的次数。
2. 调用实参的值（即17和9）被传递给了`serviceCharge`函数的形参（即`checks = 17`和`ATMs = 9`），该函数将根据这些被指定的值来返回当前月需支付的银行手续费。
3. `serviceCharge`函数中的语句都会被执行。
4. `serviceCharge`函数最终会遇到`return`关键字。
5. `main`函数中的函数调用`serviceCharge(checks, ATMs)`将会被替换成该函数返回的值10.15。
6. 函数的返回值将会被赋值给`fee`。
7. `fee`会被输出显示。

### 4.1.1 测试驱动程序

当我们需要用实参调用函数时，在两个不同的地方声明相同变量名声明的情况并不罕见。以之前的程序为例，`main`函数中声明的`checks`和`ATMs`同时也是`serviceCharge`函数的形参。`main`函数中声明的对象是用来获取用户输入的，而`serviceCharge`函数声明的形参则用来获取来自`main`函数的输入。尽管它们使用了相同的变量名，但它们是不同的变量。

当然，有时候我们也不需要在形参上复制`main`函数中的同名对象。在下面的程序中，我们将会看到这回没有用户输入操作了，自然也 就没有对象需要复制。取而代之的是，这会我们用来测试函数的实参是一些常量，而且这次也不再需要将返回值赋值给另一个对象了，程序会直接显示返回结果。这段程序唯一的功能就是测试函数——验证其返回值是否符合预期。在将该函数应用到更大的程序中之前，做一些这样的测试是一件好事。事实上，许多编程问题都需要我们进行这种形式的测试。

```C++
// The main function makes several calls to test a new function

#include <iostream>
using namespace std;

const double MONTHLY_FEE = 5.00;

double serviceCharge(int checks, int ATMs) {
    // pre: checks >= 0 and ATM >= 0
    // post: Return a banking fee based on local rules
    double result;
    result = 0.25 * checks + 0.10 * ATMs + MONTHLY_FEE;
    return result;
}

int main() {
    // Test drive serviceCharge          // Sample problems:
    cout << serviceCharge(0, 0) << endl; // 5.0
    cout << serviceCharge(1, 0) << endl; // 5.25
    cout << serviceCharge(0, 1) << endl; // 5.1
    cout << serviceCharge(1, 1) << endl; // 5.35
    return 0;
}
```

**程序输出**

```shell
5
5.25
5.1
5.35
```

这个版本的`main`函数叫做*测试驱动程序（test driver）*，这是一种专门用于测试新函数的程序。譬如，像`serviceCharge`、`sqrt`和`pow`这些函数通常都只是较大型程序中的一小部分，因此在它们被重用之前全都应该经过全面性的测试。另外，对于上面所呈现的四个样本问题。我们都在对应的注释中注明了自己的预期值。如你所见，对于`serviceCharge`函数来说这是一个成功的测试程序。

### 4.1.2 只有一条返回语句的函数

有时候我们会看到一些极其简单的函数，它们可能只有一条返回语句。譬如：

```C++
double serviceCharge(int checks, int ATMs) {
    // pre: checks >= 0 and ATM >= 0
    // post: Return a banking fee based on local rules
    return 0.25 * checks + 0.10 * ATMs + MONTHLY_FEE;
}
```

但除了上面这种极其简单（即只包含一条返回语句）的函数外，本书在定义函数时都将遵守以下约定：

1. 我们会声明一个名为`result`的局部变量，并且它的类型与函数定义的返回类型相同。
2. 然后将最终所需的值存储到变量`result`中。
3. 最后返回`result`。

虽然，这种约定在简单函数中会显得有些多余。但在第7章“选择操作”之后，这种模式将会非常有助于我们面对那些日益复杂的处理操作。

除此之外，看似多余的这两行代码有时还能避免一个非常常见的错误。这或许是因为其他编程语言在技术上支持这样做，或许是因为想当然，总之我们常常会试图将一个值赋值给函数名，这会导致编译时错误，因为只有变量才能被赋值。

```C++
double serviceCharge(int checks, int ATMs) {
    // You cannot assign a value to a function name
    serviceCharge = 0.25 * checks + 0.10 * ATMs + 5.00; // ERROR
    return serviceCharge; // ERROR, attempt to return function
}
```

当然，如果你真的犯了这个常见的错误，编译器会告知你的。我们只需要在表达式中加上正确的返回值类型`double`就可以修复这个错误，然后就可以返回这个函数了。

**自检题**

4-2 请根据下面给出的函数`f1`，写出`f1(9.0)`这个调用的返回值。

```C++
double f1(double x) {
    // pre: x is zero or positive, but not 1.0
    // post: Return f(x) = (square root of x) / ( x - 1.0 )
    return sqrt(x)/(x - 1.0);
}
```

4-3 `f1(-1.5)`这个函数调用是否满足上述函数的前置条件？使用负数做实参调用`f1`函数会发生什么情况？

4-4 请分别说明下列函数中错误的修复方法。

* a
    ```C++
    double f1(int j);{
        return 2.5 * j;
    }
    ```
* b
    ```C++
    double f2(int) {
        return 2.5 * j;
    }
    ```
* c
    ```C++
    double f3(int x) {
        return 2.5 * j;
    }
    ```
* d
    ```C++
    double f4(double x) {
        return 2.5 * x;
    }
    ```
* e
    ```C++
    double f5(double x) {
        return double;        ;
    }
    ```
* f
    ```C++
    int f6(string s) {
        return s;
    }
    ```

4-5 请编写一个名为`times3`的函数，该函数的功能是返回一个三倍于其实参的值（譬如`times3(2.0)`应该返回6.0）。

## 4.2 分析、设计与实现

与编写程序相比，实现函数所需要考虑的问题只是一个大型程序中的一小部分。它可能只是某个算法中的一个步骤，只不过经常会被调用罢了。

*问题：* 计算出两点之间的距离。

### 4.2.1 分析

还记得吗？我们在程序开发的分析阶段会涉及到如何确定输入与输出，另外还有用计算机解决问题时常涉及的IPO算法模式。也就是说，开发者必须得先确定哪些是必须要发送给用户的输出，哪些是用户所需要提供的输入。在函数的设计中，我们只需要将之前的*用户*替换成*客户端*，IPO模式一样是可以适用的。除此之外，函数的输出现在变成了函数的返回语句，而输入则变成了函数实参与形参的关联配对。下面，我们来描述一个适用于函数而不是程序的通用IPO算法模式。

**适用于函数的IPO模式**

* 输入：经由实参与形参之间的关联配对动作将相关值输入给函数。
* 处理：计算出待返回的结果。
* 输出：返回结果。

问题样例是我们确定自己是否已经理解目标问题是一个好方法。而且在程序测试过程中，这些样例所提供的预期结果也可以被拿来与程序的输出进行比对。同样地，为新函数开发一组问题样例也是一个很好的主意，我们可以通过这些样例来确定函数所需的输入。也就是要在函数头信息中写明的形参类型及其数量。当然，问题样例也为我们的测试驱动程序提供了预期的输出值。

根据以下公式可以看出，想要计算出（$x_1$, $y_1$）与（$x_2$, $y_2$）这两点之间的距离，我们需要四个`double`类型的值：

$$distance = \sqrt{{(x_1 - x_2})^2 + {(y_1 - y_2)}^2}$$

下面是几组$x_1$、$y_1$、$x_2$、$y_2$的值以及预估的输出。

**问题样例**

| $x_1$ | $y_1$ | $x_2$ | $y_2$ | Distance |
|-------|-------|-------|-------|----------|
| 1.0   | 1.0   | 2.0   | 2.0   | 1.414    |
| 0.0   | 0.0   | 3.0   | 4.0   | 5        |
| -5.7  | 2.5   | 3.3   | –4.7  | 11.5256  |
| 0.0   | 0.0   | 0.0   | 0.0   | 0.0      |

接下来，我们要将IPO模式应用到该函数中去：

* 输入：我们会以（$x_1$，$y_1$）和（$x_2$，$y_2$）这两点为参数来调用函数。
* 处理：按照$\sqrt{{(x_1 - x_2})^2 + {(y_1 - y_2)}^2}$这个运算公式来进行求值。
* 输出：返回计算结果。

### 4.2.2 设计

作为设计者，我们必须要确定函数需要多少参数以及这些参数的类型。在当前这个示例中，我们需要四个值来表示两个点（分别命名为`x1`、`y1`、`x2`、`y2`）。这些形参最合适的类型应该是`double`（即5.62、-9.864这样的值）。另外，函数返回值最合适的类型也是`double`，因为我们的计算将涉及到平方根函数，`double`类型有助于返回较为精确的答案。最后，该函数将被命名为`distance`，这个函数名很清晰地说明了这个函数的功能。总结一下，这个函数的头信息应该是：返回值类型为`double`、函数名为`distance`、四个具有描述性名称的`double`类型的形参。具体如下：

```C++
double distance(double x1, double y1, double x2, double y2)
// post: Return distance between two points (x1, y1) and (x2, y2)
```

接下来，在函数体内（即之前提到的语句块），我们要将`x1`、`y1`、`x2`、`y2`这四个形参代入距离计算公式，计算出结果：

```C++
result = sqrt(pow((x1 - x2), 2) + pow((y1 - y2), 2));
```

### 4.2.3 实现

在下面的程序中，除了上述所有内容的实现，我们还专门为其编写了一个用作测试函数的`main`函数（即测试驱动程序）：

```C++
// Call distance four times
#include <iostream>    // For cout
#include <cmath>       // For sqrt and pow
using namespace std;

double distance(double x1, double y1, double x2, double y2) {
    // post: Return the distance between any two points
    double result;
    result = sqrt(pow((x1 - x2), 2) + pow((y1 - y2), 2));

    return result;
}

int main() {
    // Test drive the distance function
    cout << "(1.0, 1.0) (2.0, 2.0): "
         << distance(1.0, 1.0, 2.0, 2.0) << endl;
    cout << "(0.0, 0.0) (3.0, 4.0): "
         << distance(0.0, 0.0, 3.0, 4.0) << endl;
    cout << "(-5.7,2.5) (3.3,-4.7): "
         << distance(-5.7,2.5, 3.3,-4.7) << endl;
    cout << "(0.0, 0.0) (0.0, 0.0): "
         << distance(0.0, 0.0, 0.0, 0.0) << endl; 
    return 0;
}
```

**程序输出**

```shell
(1.0, 1.0) (2.0, 2.0): 1.41421
(0.0, 0.0) (3.0, 4.0): 5
(-5.7,2.5) (3.3,-4.7): 11.5256
(0.0, 0.0) (0.0, 0.0): 0
```

实参与形参之间的关联配对操作与程序的输入操作非常类似。以上述代码中对`distance`函数的第二次调用为例，作为输入，以下四个值会这样被复制给`distance`函数：

```C++
double distance(x1,  y1,  x2,  y2)
                 ↑    ↑    ↑    ↑  
       distance(0.0, 0.0, 3.0, 4.0)
```

接下来，控制权就被移交给了函数，它将会利用其形参计算出实参所表示的那两点之间的距离，以下是它的计算步骤：

```C++
sqrt(pow((x1  -  x2), 2) + pow((y1  -  y2), 2))
sqrt(pow((0.0 - 3.0), 2) + pow((0.0 - 4.0), 2))
sqrt(pow((  -3.0   ), 2) + pow((  -4.0   ), 2))
sqrt(           9.0      +         16.0       )
sqrt(                  25.0                   )
                        5.0                   )
```

这四个实参可以成为函数的输入，是因为系统会负责将四个实参的值复制给其各自所关联的形参。这种实参与形参之间的关联操作模式我们称之为*值传递（pass by value）*，因为传递到函数中的都是变量的值。当一个函数需要以`double`、`int`这样的小型对象输入时，函数头信息中的形参必须要写成以下这种形式：

> *class-name identier*

### 4.2.4 测试

对函数进行分别测试是一个不错的想法。我们在上述程序中就是这样做的。该程序没有做别的，就是使用了几组不同的实参调用了目标函数，并输出显示了它的返回结果。请注意一下这四个调用与问题样例之间的比对。实参是函数的输入，返回结果应该与其预期结果相匹配。

建议你们也要用一个测试驱动程序来测试自己的新函数。

### 4.2.5 标识符的域

标识符的*域（scope）*指的是程序中可以引用到该标识符的那个部分。通常情况下，一个标识符的域会从它被声明之处开始，一直延续到该声明所在的语句块结束为止。还记得吗？语句块是以一对左右大括号`{ }`区隔开的语法单元。例如在下面的程序中，`local`的域应该就是`one`函数。这个`local`变量是在`one`函数中被声明的，其语句块以外的地方是无法引用该标识符的，包括`main`函数。

```C++
// Illustrate the scope of an object
#include <iostream>
using namespace std;

const int maxValue = 9999;

void one() {
    int local = -1;
    // The scope of local is this function
    cout << local << endl;
    // maxValue is known after its declaration including here:
    cout << maxValue << endl;
}

int main() {
    // The scope of local is limited to one() so this is an error:
    local = 5;
    // Function one() is known everywhere after its declaration
    one();
    // maxValue is known everywhere after its declaration
    cout << maxValue << endl;
    return 0;
}
```

当变量被声明在语句块之外时（譬如上面的`maxValue`），该变量的域就会从其被声明之处开始，一直延续到该文件的末尾。声明在语句块内的标识符只能在该语句块内被引用，这些标识符被称之为*局部*标识符。而声明在语句块之外的标识符（像`maxValue`这样的）则被称之为*全局*标识符，全局标识符可以被其在文件中被声明的位置之后的任意部分引用，除非另有语句块也声明了这个标识符（也就是该标识符被重新声明了）。在后一种情况中，先声明的标识符黑被后来的重新声明隐藏。由于同一个程序中会存在多个语句块，所以确定一个对象的域有时候会是件复杂的事。例如在下面的程序中，我们声明了三个不同的int变量`identier`，你可以试着猜测一下它会输出什么:

```C++
// This program is a tedious test of your ability to
// determine which of the three int variables named
// identier are being referenced at any given point.
#include <iostream>
using namespace std;

const int identier = 1; // Global variable

void one() {
    // This is a reference to the global identier
    cout << "identier in one(): " << identier << endl;
}

void two() {
    int identier = 2; // local to two()
    cout << "identier in two(): " << identier << endl;
}

int main() {
    int identier = 3; // local to main()
    one();
    two();
    cout << "identier in main(): " << identier << endl;
    return 0;
}
```

**程序输出**

```shell
identier in one(): 1
identier in two(): 2
identier in main(): 3
```

如你所见，当函数`one`被调用时，它引用的是全局声明`global const int identier = 1`。这个全局的`identier`可以在所有没有另行声明`identier`这个标识符名的函数中被引用。因此，`one`函数尽管自身内部并没有声明`identier`。但它可以引用第一个被声明的，初始值为1的`identier`。 但在函数`two`引用`identier`这个标识符时，由于全局的`identier`就被局部的`identier`隐藏掉了，当程序出现执行到此处时，函数`one`的输出是1，函数`two`的输出是2。同样地，`main`函数最后一条语句所引用的`identier`也应该是`main`声明的局部`identier`，其初始值为3。

通常情况下，函数都会在其语句块开头声明一个或多个变量。这些变量都属于局部变量，因为它们只能在该函数内部被引用。同样的限制也被引用到了函数的形参上。函数的形参是一种声明在`( )`之间的局部变量，它并不位于函数的语句块内。这种限制为局部变量提供了一种安全保护，能确保其不会意外地被程序的其它部分修改。

```C++
void f1(double x) {
    int local = 0;
    str = "A"; // Error attempting to reference main's local str
}

int main() {
    string str; // str is local to main
    x = 5.0; // Error attempting to reference f1's parameter x
    local = 1;
    // Error attempting to reference f1's local return 0;
}
```

**自检题**

4-6 请根据下面给出的部分程序，判断这些函数是否可引用以下标识符。其中，`cin`和`cout`的初始化在`iostream`文件中已经完成，因此在`#include <iostream>`之后，也都属于已知标识符了。

```C++
// cout b cin MAX c f1 a d f2 main e
#include <iostream>
using namespace std;

const int MAX = 999;

void f1(int a) {
    int b;
}

void f2(double c) {
    double d;
}

int main() {
    int e;
    return 0;
}
```

4-7 请命名一下函数中可以被声明为局部变量的两种东西。

4-8 如果一个变量被声明在了一个函数之外，在哪些地方可以引用它？

### 4.2.6 函数名的域

Now what about function names? After all, they too are identifiers. What is their scope? Like cin and cout, the scope of functions in an included fi le like cmath also extends to the end of their own file and any fi le with #include <cmath>. So functions such as sqrt, pow, ceil, and fabs may be called from within any block unless the function name is re-declared to be something else.

### 4.2.7 GLOBAL IDENTIFIERS

The problems presented so far are not relatively complex. They are certainly not large. You have probably been working pretty much on your own. However, when programs get large with a team, practice caution with scope.

Global identifiers are known everywhere after they are declared. This opens them up for accidental alteration from anywhere in a very large program. It is diffi cult to ensure that no one will accidentally modify an object at the wrong time. So try to get in the habit of using local objects everywhere possible. This means you use parameters between ( and ) and objects between { and }. For example, main declares localX and localY locally.

```C++
int main() {
    double localX, localY;
    // . . .
}
```

If you need to move data between functions, pass them as arguments. This means you must declare parameters rather than having some global x.

```C++
double f(double x) { // x is local to f
    double result; // result is local to f
    // Do something with x . . .
}
```

If you need a value in many places throughout a program, make it const.

```C++
#include <iostream>
using namespace std;

const int MAXIMUM_ENTRIES = 100; // ... a large program with many functions may follow
```

On the other hand, C++ often uses global identifi ers. Consider the fact that after including <iostream>, cout is known everywhere, assuming using namespace std; is written before cout is referenced (left column following) or cout is qualified with std:: (right column).

```C++
#include <iostream>
using namespace std;

void f() {
    cout << "In f\\n";
}

void g() {
    cout << "In g\\n";
}

int main() {
    f();
    g();
    cout << "In main\\n";
    return 0;
}
```

```C++
#include <iostream>
// Equivalent code with std::
void f() {
    std::cout << "In f\\n";
}

void g() {
    std::cout << "In g\\n";
}

int main() {
    f();
    g();
    std::cout << "In main\\n";
    return 0;
}
```

In effect, using namespace std; makes cout a global identifier. Is this okay? Well, a lot of computer scientists believe so. There is usually only one console, so any output to cout will go to the same console, no matter which function sends output to it.

## 4.3 void FUNCTIONS & REFERENCE PARAMETERS

The keyword void is used as the return type of functions that do not return anything. Instead of returning values back to the client, void functions are often employed to modify the state of the object(s) passed to them. Th is section shows a void function called swap, which modifies two arguments. A function must use a reference parameter—with & added—to modify the state of the object(s) in the function call. Here is the general form.

**General Form 4.4** *Reference Parameter*

> *class-name* & *identier*

**Examples of reference parameters in function headings**

```C++
void swap(double & parameterOne, double & parameterTwo) void
changeFormat(ostream & cout)
```

A change to a reference parameter (with &) also modifies the associated argument. Th e parameter name is a reference to—memory location of—the associated argument.

Although parameters typically obtain input from the caller, they can sometimes establish a stronger connection between argument and parameter. In this first example of reference parameter usage, the swap function must modify two objects. Since only one value can be returned through a return statement, the function requires something besides the return statement to communicate more than one value back to the caller. Th is is accomplished when the special symbol & is placed before the parameter name in the function heading. Instead of receiving a copy of the argument, the function receives the memory location or reference to that argument.

When a change is made to a reference parameter, it will change the same object referenced by the argument. Th is is because the parameter and the argument are pointing to the same object in memory. For example, in the following program, when the swap function alters the parameters parmOne and parmTwo, the arguments argOne and argTwo are also pointing to that same modifi ed object:

```C++
// Notice the reference symbol & is in front of parmOne
// and parmTwo. Now a change to parmOne or parmTwo alters
// the associated object that is the argument's value.

#include <iostream>
using namespace std;

// Swap the values of any two int arguments.
// The & lets any change to the parameter alter it argument
void swap(int & parmOne, int & parmTwo) {
    int temp = parmOne;
    parmOne = parmTwo; // Change argument argOne in main
    parmTwo = temp;    // Change argument argTwo in main
}

int main() {
    int argOne = 89; // argOne argTwo
    int argTwo = 76;

    cout << argOne << " " << argTwo << endl; // 89 76
    swap(argOne, argTwo);
    cout << argOne << " " << argTwo << endl; // 76 89

    return 0;
}
```

**Output**

```shell
  89             76
  76             89
```

If the ampersands (&) are removed from the program above, no change is made to the arguments in main. In this case, the values of argOne and argTwo would be passed by value, not by reference. Without the reference symbol &, the values of parmOne and parmTwo are changed locally, within swap only. Th e values of the associated arguments in main are unaff ected because they are diff erent objects.

The following fi gures illustrate the diff erence between reference and value parameters.

**Reference parameters:** *argument and parameter reference the same object*

```C++
parmOne = address of argOne and parmTwo = address of argTwo

void swap(int & parmOne, int & parmTwo) {
    parmOne
    parmTwo 89-  76  parmOne points to the memory location of argOne and then changes contents from 89           76-  89  to 76 in swap. This affects the same object pointed to by argOne.

}

int main() {
    argOne
    argTwo           parmTwo points to the memory location of argTwo and then changes contents from 76                    to 89 in swap. Th is affects the same object pointed to by argTwo.

}
```

**Value parameters:** *a change to the parameter does not change the associated argument*

```C++
parmOne = 89 (value of argOne) and parmTwo = 76(value of argTwo)

void swap(int parmOne, int parmTwo) {
    parmOne   89- 76    parmTwo Since values are passed to the swap function, when the
              76- 89    swap occurs locally, it does not aff ect the variables in a 
                        different function.

}

int main() { 
    argOne    89
    argTwo    76
                Values in main are not aff ected when their values are
                “passed by value”.
}
```

Because a change to a reference parameter changes the argument, the argument must be a variable. Using a literal value or larger expression results in a compile time error.

Values in main are not aff ected when their values are

```C++
swap(89, 76); // Error: Argument must be a variable
```

**SELF-CHECK**

4-9 Write the values of arg1 and arg2 at the moment when return 0; executes.

* a.
    ```C++
    #include <iostream>
    using namespace std;
    void changeOr(int a, int b) {
        a = a * 2 + 1;
        b.  = 123;
    }

    int main() {
        int arg1 = 5;
        int arg2 = 5; changeOr(arg1, arg2); // arg1 ____ arg2 _____
        return 0;
    }
    ```

* b.
    ```C++
    #include <iostream>
    using namespace std;
    void changeOr(int & a, int & b) {
        a = a * 2 + 1;
        b = 123;
    }

    int main() {
        int arg1 = 5;
        int arg2 = 5;
        changeOr(arg1, arg2); // arg1 ____ arg2 ____
        return 0;
    }
    ```

## 4.4 CONST REFERENCE PARAMETERS

You have now seen two of the three parameter passing modes in C++:

1. value parameters—for passing the values of small objects such as int
2. reference parameters—to allow a function to modify the state of one or more arguments
3. const & (reference) parameters—for safety and effi ciency

A const reference parameter is typically used to pass a “big” object that is not to be modifi ed by the function. A big object is one that requires a lot of memory, a very large string for example. To understand why programmers pass large objects by const reference, consider what happens when arguments are passed into functions.

When passed by value, the entire object is copied into another variable of the same size in the function, which requires twice the memory. For reference parameters, the address of the object is copied to the function, which is only four bytes of memory. In this case, the argument and the parameter reference the same object. For const & parameters, the address of the object is copied to the function, again only four extra bytes of memory needed. With const, any attempt to modify the parameter in the function will be flagged as an error by the compiler. Th e const prevents accidental changes to the argument. The programmer adds const to avoid the bug of unknown modifi cation of an object in a diff erent scope.

| Pass by Value int f1(int j) | Pass by Reference int f2(string & b) | Pass by const Reference void f3(const int & n) |
|------------------------------|-------------------------------|-------------------------------|-----------------|
| Grab enough memory to store the entire object and copy all bytes to the function. A change to the parameter has no effect on the argument. | Use four bytes of memory to store the address of the object and copy that address to the function. Use this when you need to modify the argument. It’s effi cient too. | const means the argument cannot be changed. Any attempt to change n results in a compile time error. Use this for effi ciency and safety. |
| f1 ***cannot*** modify the argument’s state. | f2 ***can*** modify the argument’s state. | f3 function ***cannot*** modify the argument’s state. Th is is efficient. |

There are two reasons to use const reference parameters. The first is efficiency—the program executes more quickly. The other consideration is better memory utilization—less memory is required to store the large object in the function. For example, passing a small object such as int by value only requires the function to allocate and then copy four bytes of memory. By contrast, one large object passed by value could require thousands of bytes. Th e program might exhaust available memory.

Additionally, every single byte of an argument passed by value will be copied to the function. The computer has to do a lot of unnecessary work. The program might run noticeably slower. Here are two alternatives to make any program more efficient in terms of space (saves memory) and time (runs faster):

1. Pass big objects by reference—effi cient but somewhat dangerous.
2. Pass big objects by const reference—effi cient *and* safe.

The second option is recommended. The program now has much less work to do. When passed by values, the program must then wait until every single byte is copied from the caller to the function. If passed by const & reference, only four bytes are required while the safety of value parameters (cannot change the state of the argument) remains intact. Of course, if you are passing an argument to a function in order to modify the state, you must pass it by reference with &.

Attempts to modify objects passed by const reference result in compile time errors. Using const is an antibugging technique that will let the compiler tell us about accidental attempts to modify the const parameter. Any function that does not modify the object may still be called—string’s length function, discussed in the next chapter, for example. However, the compiler will fl ag any attempt to call functions such as string’s insert function because as the name implies, insert adds things to a string to modify the state of the string object. You cannot assign a new value to a const parameter either.

```C++
void addSomeStuff(const string & str) {
    cout << str.length() << endl; // Okay
    str.insert(5, "xtra"); // ERROR: can not modify a const parameter
    str = "new string"; // ERROR: Can not assign to a const parameter
}
```

However, when using value parameters only, you get no such error message. The argument’s object simply does not change.

| Changing x in f does not change y in the main function | This code results in a compile time error such as “cannot modify a const object” |
|--------------------------------| ------------------------------------|
| | |

```C++
#include <iostream>
using namespace std;
double f(double x) {
    double result;
    // This does not modify y
    x = x – 1.5;
    result = 2 * x;
    return result;
}
int main() {         // Output:
                        // 8
    double y = 5.0;  // y: 5
    cout << f(y) << endl;
    cout << "y: " << y << endl;
    return 0;
}
```

```C++
#include <iostream> using namespace std;
double f(const double & x) {
    double result;
    // An error. Good!
    x = x – 1.5;
    result = 2 * x;
    return result;
}

int main() {
    double y = 5.0;
    cout << f(y) << endl;
    cout << "y: " << y << endl;
    return 0;
}                                                                                                    ```
```

It should be noted that only a few objects will be passed by const reference until later. So you will only occasionally see a big object passed by const reference in the next several chapters. Also, value parameters will be more common than reference parameters.

## CHAPTER SUMMARY

* Functions perform some well-defi ned services and can have two-way communication through argument/parameter associations and the return statement. Th e client code supplies input values to the function as arguments. Th e result is returned via the return statement.
* There are several new implementation issues related to functions such as the scope of identi-fi ers:
  * All identifi ers must be declared before they can be referenced.
  * The scope of an object is limited to the block where it is declared.
  * Some identifi ers are not declared within a block. In this case, they are global identifi -ers. Examples of global identifi ers include function sqrt after \#include <cmath>, and the global object std::cout after \#include <iostream>.
  * The scope of a parameter is limited to its function.
  * The scope of a function begins at the function heading and continues to the end of its fi le, or the end of the fi le that included the function.
* There are many details to remember when using argument/parameter associations.
  * The number of arguments used in a function call must match the number of param-eters declared in the function heading.
  * The void return type precedes the function name when no value is to be returned. You cannot return anything from a void function.
  * When one value is to be returned from a function, a non-void return type must begin the function heading. Th e return statement must also be included in the function block. Th e expression in the return statement should be the same class as the return type.
  * Sometimes a function needs input—that is what parameters are for. Sometimes a function must return something—that is what the return statement is for. Sometimes a function needs to modify objects in the client code—that’s what reference parameters are for.
  * The argument used in a function call should usually be the same class as its associated parameter. There are exceptions; for example, an int argument may be assigned to a double parameter with type conversion.
  * Parameters intended only to receive copies of the argument values (input parameters) should be declared as value parameters without &.
  * Reference parameters (with &) must be used if the intention is to modify the associated argument—a change to a reference parameter alters the object reference by the argument. A change to a value parameter does not.
  * const reference parameters are used to pass large objects. Instead of consuming extra bytes of memory and copying that memory, the address is copied—because of &. However, the safety of value parameters is ensured by making the parameter const.

## EXERCISES

1. How many statements may be written in a block delimited by { }?

2. Which function is called fi rst when a C++ program executes?

3. May a function be called more than once?

4. Write the output generated by the following program:
    ```C++
    #include <iostream>
    using namespace std;
    double f2(double x, double y) {
        return 2 * x - y;
    }

    int main() {
        cout << f2(1, 2.5) << endl;
        cout << f2(-4.5, -3) << endl;
        cout << f2(5, -2) << endl;
        return 0; 
    }
    ```
5. Write the output generated by the following function:
    ```C++
    #include <iostream>
    #include <cmath>
    using namespace std;

    double mystery(double p) {
        return pow(p, 3) - 1;
    }

    int main() {
        double a = 3.0;
        cout << mystery( a) << endl;
        cout << mystery(4.0) << endl;
        cout << mystery( -2) << endl;
        return 0;
    }
    ```
6. Write a function double sumOf3 that returns the sum of any three doubles. For example, sumOf3(1.5, 2.2, 3.7) should return 7.4.

7. Write a function int maxOf4 that returns the largest of the four integer arguments. For example, maxOf4(99, 2, 99, -4) should return 99.

8. What is the scope of these identifi ers being referenced in the following code?
    * a. std
    * b. cin
    * c. MAX
    * d. aaa
    * e. string
    * f. f
    * g. result
    * h. s
    * i. cout

    ```C++
    #include <iostream>
    #include <cmath>
    using namespace std;

    const double MAX = 2.0;

    double f(double aaa) {
        double result;
        result = pow(3.0, aaa);
        return result;
    }

    int main() {
        string s = "a string";
        cout << f(MAX);
        return 0;
    }
    ```

9. Will a change to a value parameter modify the associated argument?

10. Will a change to a reference parameter modify the associated argument?

11. Write the output generated by this program:
    ```C++
    #include <iostream>
    using namespace std;

    void changeArgs(double & x, double & y) {
        x = x - 1.1;
        y = y + 2.2;
    }

    int main() {
        double a = 3.3;
        double b = 4.4;

        cout << a << " " << b << endl;
        changeArgs(a, b);
        cout << a << " " << b << endl;
        changeArgs(a, b);
        cout << a << " " << b << endl;
        return 0;
    }
    ```

## PROGRAMMING TIPS

1. Here are some common mistakes made when writing functions:
   * Placing the semicolon at the end of a function heading:
    ```C++
    string move(int n) ; // ERROR
    { // many errors agged here. Remove ; from line above
    }
    ```
    * Assigning a value to the function name:
    ```C++
    double f(double x) {
        f = 2 * x; // ERROR: Can not assign value to function
        return f;  // ERROR: Can not return a function name
    }
    ```
    The solution: Declare a local object, assign it the value, and return it. Or, in the case of simple functions, simply return the expression:
    ```C++
    double f(double x) {
        return 2 * x;
    }
    ```
    or do this when there is more going on inside the function:
    ```C++
    double f(double x) {
        double result;
        result = 2 * x;
        return result;
    }
    ```
    * Failing to return a value from a non-void function:
    ```C++
    double f2(double x) {
        double result;
        result = 2 * x;
        // ERROR: f2 must return a number
    }
    ```
    * Returning a value from a void function:
    ```C++
    void foo(double x) {
        return 2 * x; // ERROR
    }
    ```
2. There are several ways that functions communicate with each other:
    * The caller can send values and objects to a function by value.
    * The caller sends objects as arguments to a function by reference when the function is de-signed to change the arguments.
    * The caller sends objects as arguments to a function by const reference to save time and memory when the function is not supposed to change the arguments.
    * The caller gets values back from a function via the return statement.
    * The caller gets values back from a function by having the function change arguments associ-ated with reference parameters changed in the function.
3. If you want two or more values back from a function, use reference parameters. Th e return statement returns only one thing. If you need more than one thing back from a function, use one or more reference parameters in addition to a return statement.

## PROGRAMMING PROJECTS

### 4A SUM THREE

Write the function sumThree that returns the sum of three double arguments.

```C++
// Test drive sumThree
int main() {
    cout << sumThree(1.1, 2.2, 3.3) << endl; // 6.6 cout
         << sumThree(-1, -2, 3) << endl;     // 0
    return 0;
}
```

### 4B ROUNDING TO `n` DECIMAL PLACES

Write a function named round that returns the value of its double argument rounded to the number of decimal places specifi ed as the second argument.

```C++
// Test drive round
int main() {
    // Arguments: number to round (-2.9), decimal places (0)
    cout << round(-2.9, 0) << endl; // -3
    cout << round(-2.59, 1) << endl; // -2.6
    cout << round(0.0059, 2) << endl; // 0.01
    cout << round(1.23467, 3) << endl; // 1.235
    cout << round(9.999999, 4) << endl; // 10
    return 0;
}
```

### 4C PAYMENT

The payment on a loan is a function of the interest rate, the number of payments (periods), and the amount borrowed. Pass these three values as arguments to a function payment that returns the loan payment. The function heading is provided for you along with a test driver. Round your answer to two decimal places (see Section 3.2). See if your answers match an online mortgage calculator.

```C++
#include <iostream> // For the cout object
#include <cmath> // For pow, which you de nitely need here
using namespace std;

double payment(double amtBorrowed, double interestRate, int numPeriods) {
    // TODO: Complete this function
}

int main() { // Test drive payment

    // 6.0 needs to be divided by 100 and then by 12 to become a monthly
    // interest rate, The number of years (30) also needs to multiplied

    // by 12. The following test cases represent a monthly payment.
    cout << payment(185000.00, 6.0/100.0/12, 30\*12) << endl;
    cout << payment(185000.00, 5.0/100.0/12, 30\*12) << endl;
    cout << payment(185000.00, 4.0/100.0/12, 30\*12) << endl;

    return 0;
}
```

Here is the formula used to calculate payments on a loan given the amount borrowed, interest rate for one period, and the number of periods:

$$ Payment = Amount * Rate * \frac{{(Rate + 1)}^{Months}}{{(Rate + 1)}^{Months}-1} $$

### 4D POPULATION GROWTH PREDICTION

According to **http://www.census.gov/popclock/**, at the time of this writing the population growth in the United States can be predicted as follows:

One birth every *8 seconds*

One death every *13 seconds*

One international migrant (net) every *40 seconds*

Write a function that predicts the population for any number of days into the future when also given the current population. Th e following test driver must compile and generate the output shown in comments:

```C++
int main() {
    cout << populationPrediction (320000000, 0) << endl; // 320000000

    // One and two day growth:
    cout << populationPrediction(320000000, 1) << endl; // 320006314
    cout << populationPrediction(320000000, 2) << endl; // 320012628

    // One and two year growth
    cout << populationPrediction(320000000, 365) << endl; // 322304554
    cout << populationPrediction(320000000, 2\*365) << endl; // 324609108

    return 0;
}
```

Once the function has been tested, write a complete program that prompts the user for the current population and the days into the future using a dialog that looks just like this:

```shell
Predict population growth given the current population and days into the future

Current population? 320000000
Day into the future? ***365***
```

In 365 days, the population should grow by 2304554 to become 322304554

### 4E QUADRATIC FORMULA

The quadratic formula (below) uses the `a`, `b`, and `c` from quadratic equations of the form $ax^2 + bx + c$ to find both roots.

$$ x = \frac{-b + \sqrt{b^2 - 4ac}}{2a} $$

For example, the two real roots of *x*^2^ + 3*x* − 4 are 1 and −4 as indicated by this dialog and the plotting of this function:

```shell
Enter a b and c coef cients of a quadratic equation: ***1 3 -4***

roots: 1 and -4

1x^2 + 3x + -4 when x is 1 should be 0
This should be 0 or very close? 0

1x^2 + 3x + -4 when x is -4 should be 0
This should be 0 or very close? 0
```

![4-1](img/4-1.png)

You are asked to complete and test these three functions as described in the comments:

```C++
// Given the 3 coef cients, compute the two roots that
// are made accessible as reference parameters. Assignment to
// root1 and root2 also change the associated arguments.
void ndBothRoots(double a, double b, double c,
                    double & root1, double & root2)

// Evaluate any quadratic equation given the 3 coef cients
// and the root in question. This function should return 0.0,
// but something close to 0.0 like -6.66134e-16 is okay.
// This function could return nan if b^2 – 4ac < 0 or a is 0.
double evaluate(double a, double b, double c, double root)

// Generate the requested dialog using the two functions above.
int main()
```

To avoid the roots being not a number (nan) when there is a negative square root, complex numbers could be used. However, if the roots are not real, the return result is allowed to be nan (or -1.\#IND in Visual Studio as of this writing). Th e quadratic equation 3*x*^2^ + 4*x* + 2 has no real roots. Th is program run indicates there are no real roots since nan is returned with 3, 4, and 2 input for a, b, and c respectively:

```shell
Enter a b and c coef cients of a quadratic equation: ***3 4 2***

roots: nan and nan

3x^2 + 4x + 2 when x is nan should be 0
This should be 0 or very close? nan

3x^2 + 4x + 2 when x is nan should be 0
This should be 0 or very close? nan
```
