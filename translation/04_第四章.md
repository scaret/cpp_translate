**C H A P T E R F O U R**

Implementing Free Functions

SUMMING UP

> C++ has many free functions that any programmer can reuse. Th ese
> documented functions can be found at
> **http://www.cplusplus.com/reference**. It is considered good practice
> to compose code into well-defi ned functions, test them, and then call
> them from our programs. Th is makes for more readable programs.
> However, C++ does not provide all functions needed by everyone in all
> situations.

COMING UP

> Th is chapter shows how to write your own functions. After studying
> this chapter, you will be able to

-   implement free functions

-   pass values to your functions as input

-   return values from your functions as output

-   test your new functions

-   begin to understand the scope of objects and functions

4.1 IMPLEMENTING YOUR OWN FUNCTIONS

> Functions, such as those presented in the previous chapter like min,
> max, abs, round, and sqrt, are defi ned as a function heading followed
> by a block.
>
> General Form 4.1 *Free Function*
>
> *function-heading block *
>
> A block begins with { and ends with }. It contains components such as
> variable declarations and executable statements.
>
> 77
>
> General Form 4.2 *Block*
>
> { *object-initializations*
>
> *statements*
>
> }
>
> Functions get their input via the arguments in the function call. Th e
> function uses these input values to compute a result, which is then
> returned to the caller. You have seen how arguments are associated
> with parameters to get input into the function. Functions communicate
> values to the calling code through the return statement.
>
> General Form 4.3 *Return Statement*
>
> return *expression* ;

Example of returning a value back to the calling code:

> int minOf3(int a, int b, int c) {
>
> // post: Return the smallest value amongst the 3 arguments return
> min(a, min(b, c)); }
>
> When the return statement is encountered, the expression that follows
> return replaces the function call in the client code as program
> control returns to the place where the function was called. Th e
> following function named f implements the function *f* (*x*) =
> 2*x*^2^−1. Notice that the function must be coded before it can be
> called—the entire function f is located before the call to it from
> main.
>
> \#include &lt;iostream&gt; // For cout
>
> \#include &lt;cmath&gt; // For pow using namespace std;
>
> double f(double x) { // post: Return 2 \* x \* x - 1 double result;
> result = 2 \* pow(x, 2) - 1.0; return result; }
>
> int main() { double x, y; cout &lt;&lt; "Input x: "; cin &gt;&gt; x;
>
> // Call function f:
>
> y = f(x);
>
> cout &lt;&lt; "f(" &lt;&lt; x &lt;&lt; ") = " &lt;&lt; y &lt;&lt;
> endl; return 0;
>
> }

4.1: Implementing Your Own Functions

> Dialogue
>
> Input x: ***1.01*** f(1.01) = 1.0402

SELF-CHECK

> 4-1 What value is returned for each of these function calls? If there
> is an error, explain it. Use *f* (*x*) = 2*x*^2^−1 from the previous
> example.

  a\. f(0.0)    d\. f(1, 2)
  ------------- -------------
  b\. f(-2.0)   e\. f()
  c\. f(3)      f\. f(5.8)

> In the next example, the function serviceCharge is declared with the
> double return type. Th e call to serviceCharge is replaced by a double
> value that depends on the values of the arguments.
>
> // Call serviceCharge to determine a bank debit
>
> \#include &lt;iostream&gt; using namespace std; const double
> MONTHLY\_FEE = 5.00;
>
> double serviceCharge(int checks, int ATMs) {
>
> // pre: checks &gt;= 0 and ATM &gt;= 0
>
> // post: Return a banking fee based on local rules double result;
>
> result = 0.25 \* checks + 0.10 \* ATMs + MONTHLY\_FEE; return result;
>
> int main() {
>
> // 0. Initialize objects int checks; int ATMs;
>
> double fee; // Stores the function return result
>
> // 1. Input
>
> cout &lt;&lt; "Checks this month? "; cin &gt;&gt; checks;
>
> cout &lt;&lt; "ATMs this month? "; cin &gt;&gt; ATMs;
>
> // 2. Process
>
> fee = serviceCharge(checks, ATMs); //Call to serviceCharge
>
> // 3. Output
>
> cout &lt;&lt; "Fee: " &lt;&lt; fee &lt;&lt; endl;
>
> return 0; }
>
> Dialogue
>
> Checks this month? ***17***
>
> ATMs this month? ***9*** Fee: 10.15
>
> Here is what happens when the preceding program runs:

1.  Th e user is asked to supply input for the number of checks and
    > ATM transactions.

2.  Th e values of the arguments (17 and 9) are assigned to the
    > parameters of serviceCharge (checks = 17 and ATMs = 9). Th ese
    > particular values will be used by the function to return the
    > proper monthly bank fee.

3.  Th e statements in serviceCharge execute.

4.  Th e return is encountered in serviceCharge.

5.  Th e function call serviceCharge(checks, ATMs) in main is replaced
    > by the returned value of 10.15.

6.  Th e function’s return value is assigned to fee.

7.  Th e fee is displayed.

4.1.1 TEST DRIVERS

> When a function requires arguments, it is not unusual to have the same
> variable name declared in two diff erent places. Consider the previous
> program that declares checks and ATMs in main and also as parameters
> within the function serviceCharge. Th e objects declared in main are
> used to obtain user input. Th e parameters declared in serviceCharge
> obtain input from main. Although they have the same names, they are
> diff erent variables.
>
> Sometimes the duplication of parameter names in main is not required.
> In the next program, you’ll see there is no user input, so the
> duplicated objects are not necessary. Instead, the arguments used to
> test the function are constants. Rather than being assigned to another
> object, the program simply displays the return results. Th e only
> purpose of this program is to test the function—to verify that the
> return values are what was expected. Th is is a good thing to do
> before the function becomes incorporated into a larger program. In
> fact, many of the programming problems ask you to carry out this form
> of testing.

4.1: Implementing Your Own Functions

> // The main function makes several calls to test a new function
>
> \#include &lt;iostream&gt; using namespace std; const double
> MONTHLY\_FEE = 5.00;
>
> double serviceCharge(int checks, int ATMs) {
>
> // pre: checks &gt;= 0 and ATM &gt;= 0
>
> // post: Return a banking fee based on local rules double result;
>
> result = 0.25 \* checks + 0.10 \* ATMs + MONTHLY\_FEE; return result;
> }
>
> int main() {
>
> // Test drive serviceCharge // Sample problems:
>
> cout &lt;&lt; serviceCharge(0, 0) &lt;&lt; endl; // 5.0 cout &lt;&lt;
> serviceCharge(1, 0) &lt;&lt; endl; // 5.25 cout &lt;&lt;
> serviceCharge(0, 1) &lt;&lt; endl; // 5.1 cout &lt;&lt;
> serviceCharge(1, 1) &lt;&lt; endl; // 5.35 return 0; }
>
> Output
>
> 5
>
> 5.25 5.1
>
> 5.35
>
> Th is version of main is called a test driver. A *test driver* is a
> program with the sole purpose of testing a new function. Functions
> like serviceCharge, sqrt, and pow are intended to be small parts of
> much bigger programs. Th erefore all functions should be thoroughly
> tested before they are reused. Th e four sample problems shown above
> were predicted and documented in comments. Th is has been a successful
> test of the serviceCharge function.

4.1.2 FUNCTIONS WITH ONLY A RETURN STATEMENT

> Some functions are so simple, they may contain only a return
> statement.
>
> double serviceCharge(int checks, int ATMs) {
>
> // pre: checks &gt;= 0 and ATM &gt;= 0
>
> // post: Return a banking fee based on local rules return 0.25 \*
> checks + 0.10 \* ATMs + MONTHLY\_FEE; }
>
> However, this textbook will often use the following convention in
> addition to the above shortcut (one return statement):

1.  Declare a local variable named result to be the same type as the
    > function’s return type.

2.  Store the desired value in result.

3.  Return result.

> Th is is extra work for simple functions. However, this pattern will
> help when the processing gets more complex, beginning in Chapter 7,
> “Selection.”
>
> Also, the extra two lines of code are likely to prevent you from
> making a very common mistake. Perhaps because other languages use this
> technique to return values or perhaps because it simply appears to be
> the right thing to do, it is common to try to assign a value to the
> function name. Th is is a compile time error. You can only assign
> values to variables.
>
> double serviceCharge(int checks, int ATMs) {
>
> // You cannot assign a value to a function name serviceCharge = 0.25
> \* checks + 0.10 \* ATMs + 5.00; // ERROR return serviceCharge; //
> ERROR, attempt to return function }
>
> If you do make this common mistake, the compiler will tell you. Fix
> the error by placing an expression of the correct type, double, after
> the return.

SELF-CHECK

4-2 Given the following function f1, what value is returned with
f1(9.0)?

> double f1(double x) {
>
> // pre: x is zero or positive, but not 1.0
>
> // post: Return f(x) = (square root of x) / ( x - 1.0 ) return
> sqrt(x)/(x - 1.0);
>
> }
>
> 4-3 Does the function call f1(-1.5) satisfy the previous function’s
> precondition? What happens during a call to f1 with a negative number
> for an argument?

4-4 Describe how to fi x the error in each function.

a.  double f1(int j);{ d. double f4(double x){ return 2.5 \* j; f4 =
    > 2.5 \* x;

} }

a.  double f2(int) { e. double f5(double x) { return 2.5 \* j; return
    > double;

} }

a.  double f3(int x) { f. int f6(string s) { return 2.5 \* j; return s;

} }

> 4-5 Write a function times3 that returns a value that is three times
> greater than the argument (times3(2.0) should return 6.0).

4.2 ANALYSIS, DESIGN, AND IMPLEMENTATION

> Rather than writing a program, consider a problem that implements a
> function that may be a very small part of a large program. It may
> represent just one step of an algorithm, but it is frequently called.
>
> *Problem:* Compute the distance between two points.

4.2.1 ANALYSIS

> Recall that the analysis phase of program development involves
> determining input and output. Also recall that while developing
> computer-based solutions to problems involving the IPO algorithmic
> pattern, the developer determines the output that must be sent to the
> user and also determines the input required from the user. Replace the
> word *user* with *client* in the preceding sentence, and the IPO
> pattern can be applied again to assist the design of functions. Except
> now the output from the function is expressed in the return statement
> and the input is expressed in terms of the argument/parameter
> associations. Here is a generalized IPO algorithm as it relates to
> functions instead of programs.
>
> IPO Pattern Applied to Functions
>
> Input: Input values to the function via argument/parameter
> associations.
>
> Process: Compute the result to be returned.
>
> Output: Return the result.
>
> Sample problems are a good way to confi rm understanding of a problem.
> Sample problems also provide expected results that can be compared to
> program output during program testing. It is a good idea to develop
> sample problems for new functions. Th is will help you decide what the
> function needs as input and, therefore, the number and class of
> parameters to write in the function heading. Th e sample problems also
> provide the expected output of the test driver. Four doubles are
> required to compute the distance between two points (*x*~1~, *y*~1~)
> and (*x*~2~, *y*~2~) using this formula:

*distance =* ( *x*~1~ *– x*~2~)^2^ + ( *y*~1~ *– y*~2~)^2^

> Here are some predicted outputs for a few sets of values for *x*~1~,
> *y*~1~, *x*~2~, and *y*~2~.
>
> Sample Problems

  1.0    1.0   2.0   2.0    > 1.414
  ------ ----- ----- ------ -----------
  0.0    0.0   3.0   4.0    > 5
  -5.7   2.5   3.3   –4.7   > 11.5256
  0.0    0.0   0.0   0.0    > 0.0

> Th e IPO pattern is now applied to functions as follows:

Input: Input two points at the function call (*x*~1~, *y*~1~) and
(*x*~2~, *y*~2~)

Process: Evaluate ( *x*~1~ *– x*~2~)^2^ + ( *y*~1~ *– y*~2~)^2^

Output: Return the result

4.2.2 DESIGN

> Th e designer must decide how many and what class of parameters are
> required for a function. In this example, four values are needed to
> represent the two input points (x1, y1, x2, and y2). Th e best class
> of parameters is double to allow points such as 5.62 and -9.864. Th e
> best return type is double. With the square root function involved,
> double helps return precise answers. A good function name is
> distance—it describes what the function does. Th is leads to a
> function heading with a return type of double, a function name of
> distance, and four descriptively named double parameters.
>
> double distance(double x1, double y1, double x2, double y2) // post:
> Return distance between two points (x1, y1) and (x2, y2)
>
> Now, within the body of the function (the block), the parameters x1,
> y1, x2, and y2 can be used in the distance formula to compute the
> result.
>
> result = sqrt(pow((x1 - x2), 2) + pow((y1 - y2), 2));

4.2.3 IMPLEMENTATION

> Th e following program puts this all together with a main function
> written exclusively to test the function (a test driver):
>
> // Call distance four times
>
> \#include &lt;iostream&gt; // For cout
>
> \#include &lt;cmath&gt; // For sqrt and pow using namespace std;
>
> double distance(double x1, double y1, double x2, double y2) {
>
> // post: Return the distance between any two points double result;
>
> result = sqrt(pow((x1 - x2), 2) + pow((y1 - y2), 2));
>
> return result; }
>
> int main() {
>
> // Test drive the distance function cout &lt;&lt; "(1.0, 1.0) (2.0,
> 2.0): "
>
> &lt;&lt; distance(1.0, 1.0, 2.0, 2.0) &lt;&lt; endl; cout &lt;&lt;
> "(0.0, 0.0) (3.0, 4.0): "
>
> &lt;&lt; distance(0.0, 0.0, 3.0, 4.0) &lt;&lt; endl; cout &lt;&lt;
> "(-5.7,2.5) (3.3,-4.7): "
>
> &lt;&lt; distance(-5.7,2.5, 3.3,-4.7) &lt;&lt; endl; cout &lt;&lt;
> "(0.0, 0.0) (0.0, 0.0): "
>
> &lt;&lt; distance(0.0, 0.0, 0.0, 0.0) &lt;&lt; endl; return 0; }
>
> Output
>
> (1.0, 1.0) (2.0, 2.0): 1.41421
>
> (0.0, 0.0) (3.0, 4.0): 5
>
> (-5.7,2.5) (3.3,-4.7): 11.5256
>
> (0.0, 0.0) (0.0, 0.0): 0
>
> Argument/parameter associations are analogous to program input. For
> example, in the second call to distance, the four values are fi rst
> copied as input to the function distance.
>
> double distance(x1, y1, x2, y2)
>
> distance(0.0, 0.0, 3.0, 4.0)
>
> Control then transfers to the function where the parameters are used
> to compute the distance between the two points represented by those
> arguments. Here is the step-by-step computation:
>
> sqrt(pow((x1 - x2), 2) + pow((y1 - y2), 2)) sqrt(pow((0.0-3.0), 2) +
> pow((0.0-4.0), 2)) sqrt(pow(( -3.0 ), 2) + pow(( -4.0 ), 2)) sqrt( 9.0
> + 16.0 ) sqrt( 25.0 ) 5.0
>
> Th e four arguments become input to the function as the system copies
> the value of each argument to its associated parameter. Th is
> particular mode of argument parameter association is known as *pass by
> value* because the values are passed to the function. When a function
> requires input of small objects such as double or int, write the
> function heading with value parameters of this form:
>
> *class-name identi er*

4.2.4 TESTING

> It is a good idea to test functions individually. Th e previous
> program did just that. It didn’t do anything else. Th e only purpose
> for this particular program was to call distance with diff erent sets
> of arguments and display the return results. Notice the similarity of
> the four calls to distance and the sample problems. Th e arguments are
> the input to the function. Th e return result should match the
> expected results.

It is recommended that you test new functions with a test driver.

4.2.5 SCOPE OF IDENTIFIERS

> Th e *scope* of an identifi er is the part of a program from which an
> identifi er can be referenced. Th e scope of an identifi er extends
> from the point of the identifi er’s declaration to the end of the
> block in which it is declared. Recall that a block is delimited by the
> left and right braces, { and }. For example, the scope of local in the
> following program is the function one. Th is local, declared in one,
> cannot be referenced from outside the block in which it was declared,
> including main.
>
> // Illustrate the scope of an object
>
> \#include &lt;iostream&gt; using namespace std; const int maxValue =
> 9999;
>
> void one() { int local = -1;
>
> // The scope of local is this function cout &lt;&lt; local &lt;&lt;
> endl;
>
> // maxValue is known after its declaration including here: cout
> &lt;&lt; maxValue &lt;&lt; endl; }
>
> int main() {
>
> // The scope of local is limited to one() so this is an error: local =
> 5;
>
> // Function one() is known everywhere after its declaration one();
>
> // maxValue is known everywhere after its declaration cout &lt;&lt;
> maxValue &lt;&lt; endl; return 0; }
>
> When a variable is declared outside of a block—as in the case of
> maxValue—its scope begins at the point of declaration and extends to
> the end of the fi le. Identifi ers declared in a block can be
> referenced only from within that block. Th ese are *local* identifi
> ers. Identifi ers declared outside of a block (such as maxValue) are
> said to be global. *Global identifi ers* may be referenced from any
> subsequent part of the fi le after its declaration, unless that
> identifi er is declared again (redeclared) within another block. In
> this case, the identifi er that was declared fi rst becomes hidden
> from the block in which it is redeclared. Since many blocks often
> exist within one program, determining the scope of an object can be
> somewhat complicated. For example, try to predict the output of the
> following program, which includes three diff erent declarations of the
> int variable identi er:
>
> // This program is a tedious test of your ability to
>
> // determine which of the three int variables named // identi er are
> being referenced at any given point.
>
> \#include &lt;iostream&gt; using namespace std; const int identi er =
> 1; // Global variable
>
> void one() {
>
> // This is a reference to the global identi er cout &lt;&lt; "identi
> er in one(): " &lt;&lt; identi er &lt;&lt; endl;
>
> }
>
> void two() {
>
> int identi er = 2; // local to two()
>
> cout &lt;&lt; "identi er in two(): " &lt;&lt; identi er &lt;&lt; endl;
>
> }
>
> int main() { int identi er = 3; // local to main() one(); two(); cout
> &lt;&lt; "identi er in main(): " &lt;&lt; identi er &lt;&lt; endl;
> return 0; }
>
> Output
>
> identi er in one(): 1 identi er in two(): 2 identi er in main(): 3
>
> When the function one is called, the global const int identi er = 1 is
> referenced. Th is global identi er can be referenced from within any
> function that does not declare another identifi er named identi er. Th
> erefore, the identi er that was declared fi rst and initialized to 1
> is known (can be referenced) from one even though it was not declared
> inside one. But when a reference is made to identi er in function two,
> the global identi er is hidden because of the local identi er. To this
> point in program execution, one has caused the output 0, and two has
> caused 2 to be displayed. Th e fi nal statement in main references the
> identi er local to main—this identi er is initialized as 3.
>
> Typically, a function will have one or more variables declared at the
> beginning of the block. Th ese variables are said to be local to the
> function because they may be referenced only from within the function.
> Th e same protection applies to the parameters of a function.
> Parameters are local variable declarations declared inside ( and ),
> rather than inside the function block. Parameters are assigned values
> passed to the function. Parameters can only be used inside the func-
>
> tion block. Th e restriction provides safekeeping for the local
> objects so they are not accidentally altered from some other portion
> of a program.
>
> void f1(double x) { int local = 0;
>
> str = "A"; // Error attempting to reference main's local str }
>
> int main() {
>
> string str; // str is local to main
>
> x = 5.0; // Error attempting to reference f1's parameter x local = 1;
> // Error attempting to reference f1's local return 0; }

SELF-CHECK

> 4-6 Use the partial program shown below to determine the functions
> from which each of the following identifi ers may be referenced. cin
> and cout are initialized in iostream so they are known after \#include
> &lt;iostream&gt;.
>
> // cout b cin MAX c f1 a d f2 main e
>
> \#include &lt;iostream&gt; using namespace std; const int MAX = 999;
>
> void f1(int a) {
>
> int b;
>
> }
>
> void f2(double c) {
>
> double d;
>
> }
>
> int main() { int e;
>
> return 0;
>
> }

4-7 Name two things that may be declared local to a function.

4-8 If a variable is declared outside of a function, from where may it
be referenced?

4.2.6 SCOPE OF FUNCTION NAMES

> Now what about function names? After all, they too are identifi ers.
> What is their scope? Like cin and cout, the scope of functions in an
> included fi le like cmath also extends to the end of their own fi le
> and any fi le with \#include&lt;cmath&gt;. So functions such as sqrt,
> pow, ceil, and fabs may be called from within any block unless the
> function name is re-declared to be something else.

4.2.7 GLOBAL IDENTIFIERS

> Th e problems presented so far are not relatively complex. Th ey are
> certainly not large. You have probably been working pretty much on
> your own. However, when programs get large with a team, practice
> caution with scope.
>
> Global identifi ers are known everywhere after they are declared. Th
> is opens them up for accidental alteration from anywhere in a very
> large program. It is diffi cult to ensure that no one will
> accidentally modify an object at the wrong time. So try to get in the
> habit of using local objects everywhere possible. Th is means you use
> parameters between ( and ) and objects between { and }. For example,
> main declares localX and localY locally.
>
> int main() { double localX, localY;
>
> // . . .
>
> }
>
> If you need to move data between functions, pass them as arguments. Th
> is means you must declare parameters rather than having some global x.
>
> double f(double x) { // x is local to f double result; // result is
> local to f
>
> // Do something with x . . .
>
> }
>
> If you need a value in many places throughout a program, make it
> const.
>
> \#include &lt;iostream&gt; using namespace std; const int
> MAXIMUM\_ENTRIES = 100; // ... a large program with many functions may
> follow

On the other hand, C++ often uses global identifi ers. Consider the fact
that after including

> &lt;iostream&gt;, cout is known everywhere, assuming using namespace
> std; is written before cout is referenced (left column following) or
> cout is qualifi ed with std:: (right column).

\#include &lt;iostream&gt; using namespace std;

void f() { cout &lt;&lt; "In f\\n"; }

void g() { cout &lt;&lt; "In g\\n"; }

int main() { f(); g(); cout &lt;&lt; "In main\\n"; return 0; }

\#include &lt;iostream&gt;

// Equivalent code with std:: void f() { std::cout &lt;&lt; "In f\\n"; }

void g() { std::cout &lt;&lt; "In g\\n"; }

int main() { f(); g(); std::cout &lt;&lt; "In main\\n"; return 0;

}

> In eff ect, using namespace std; makes cout a global identifi er. Is
> this okay? Well, a lot of computer scientists believe so. Th ere is
> usually only one console, so any output to cout will go to the same
> console, no matter which function sends output to it.

4.3 void FUNCTIONS & REFERENCE PARAMETERS

> Th e keyword void is used as the return type of functions that do not
> return anything. Instead of returning values back to the client, void
> functions are often employed to modify the state of the object(s)
> passed to them. Th is section shows a void function called swap, which
> modifi es two arguments. A function must use a reference
> parameter—with & added—to modify the state of the object(s) in the
> function call. Here is the general form.
>
> General Form 4.4 *Reference Parameter*
>
> *class-name* & *identi er*
>
> Examples of reference parameters in function headings
>
> void swap(double & parameterOne, double & parameterTwo) void
> changeFormat(ostream & cout)
>
> A change to a reference parameter (with &) also modifi es the
> associated argument. Th e parameter name is a reference to—memory
> location of—the associated argument.
>
> Although parameters typically obtain input from the caller, they can
> sometimes establish a stronger connection between argument and
> parameter. In this fi rst example of reference parameter usage, the
> swap function must modify two objects. Since only one value can be
> returned

4.3: void Functions & Reference Parameters

> through a return statement, the function requires something besides
> the return statement to communicate more than one value back to the
> caller. Th is is accomplished when the special symbol & is placed
> before the parameter name in the function heading. Instead of
> receiving a copy of the argument, the function receives the memory
> location or reference to that argument.
>
> When a change is made to a reference parameter, it will change the
> same object referenced by the argument. Th is is because the parameter
> and the argument are pointing to the same object in memory. For
> example, in the following program, when the swap function alters the
> parameters parmOne and parmTwo, the arguments argOne and argTwo are
> also pointing to that same modifi ed object:
>
> // Notice the reference symbol & is in front of parmOne
>
> // and parmTwo. Now a change to parmOne or parmTwo alters // the
> associated object that is the argument's value.
>
> \#include &lt;iostream&gt; using namespace std;
>
> // Swap the values of any two int arguments.
>
> // The & lets any change to the parameter alter it argument void
> swap(int & parmOne, int & parmTwo) { int temp = parmOne;
>
> parmOne = parmTwo; // Change argument argOne in main parmTwo = temp;
> // Change argument argTwo in main }
>
> int main() {
>
> int argOne = 89; // argOne argTwo int argTwo = 76;
>
> cout &lt;&lt; argOne &lt;&lt; " " &lt;&lt; argTwo &lt;&lt; endl; // 89
> 76 swap(argOne, argTwo); cout &lt;&lt; argOne &lt;&lt; " " &lt;&lt;
> argTwo &lt;&lt; endl; // 76 89
>
> return 0; }

  > **Output**   
  -------------- ----
  89             76
  76             89

> If the ampersands (&) are removed from the program above, no change is
> made to the arguments in main. In this case, the values of argOne and
> argTwo would be passed by value, not by reference. Without the
> reference symbol &, the values of parmOne and parmTwo are changed
> locally, within swap only. Th e values of the associated arguments in
> main are unaff ected because they are diff erent objects.

Th e following fi gures illustrate the diff erence between reference and
value parameters.

**Reference parameters:** *argument and parameter reference the same
object* parmOne = address of argOne and parmTwo = address of argTwo

> void swap(int & parmOne, int & parmTwo) { parmOne
>
> parmTwo ~~89~~ 76 parmOne points to the memory location of argOne and
>
> } then changes contents from 89 to 76 in swap. Th is af-
>
> int main() { 76 89 fects the same object pointed to by argOne.
>
> argOne argTwo

} parmTwo points to the memory location of argTwo and

> then changes contents from 76 to 89 in swap. Th is affects the same
> object pointed to by argTwo.

**Value parameters:** *a change to the parameter does not change the
associated argument* parmOne = 89 (value of argOne) and parmTwo = 76
(value of argTwo)

> void swap(int parmOne, int parmTwo) {

parmOne ~~89~~ 76

parmTwo Since values are passed to the swap function, when the

> 76 89
>
> }

swap occurs locally, it does not aff ect the variables in a

int main() { ^89^ diff erent function.

> argOne
>
> 76
>
> argTwo

} Values in main are not aff ected when their values are

> “passed by value”.
>
> Because a change to a reference parameter changes the argument, the
> argument must be a variable. Using a literal value or larger
> expression results in a compile time error.
>
> swap(89, 76); // Error: Argument must be a variable

SELF-CHECK

> 4-9 Write the values of arg1 and arg2 at the moment when return 0;
> executes.

a.  \#include &lt;iostream&gt; using namespace std; void changeOr(int a,
    int b) { a = a \* 2 + 1;

    b.  = 123;

> }
>
> int main() { int arg1 = 5;

4.4: const Reference Parameters

> int arg2 = 5; changeOr(arg1, arg2); // arg1 \_\_\_\_ arg2 \_\_\_\_\_
> return 0;

}

a.  \#include &lt;iostream&gt; using namespace std; void changeOr(int &
    a, int & b) { a = a \* 2 + 1;

    b.  = 123;

> }
>
> int main() { int arg1 = 5; int arg2 = 5; changeOr(arg1, arg2); // arg1
> \_\_\_\_ arg2 \_\_\_\_
>
> return 0;
>
> }

4.4 CONST REFERENCE PARAMETERS

> You have now seen two of the three parameter passing modes in C++:

1.  value parameters—for passing the values of small objects such as int

2.  reference parameters—to allow a function to modify the state of one
    > or more arguments

3.  const & (reference) parameters—for safety and effi ciency

> A const reference parameter is typically used to pass a “big” object
> that is not to be modifi ed by the function. A big object is one that
> requires a lot of memory, a very large string for example. To
> understand why programmers pass large objects by const reference,
> consider what happens when arguments are passed into functions.
>
> When passed by value, the entire object is copied into another
> variable of the same size in the function, which requires twice the
> memory. For reference parameters, the address of the object is copied
> to the function, which is only four bytes of memory. In this case, the
> argument and the parameter reference the same object. For const &
> parameters, the address of the object is copied to the function, again
> only four extra bytes of memory needed. With const, any attempt to
> modify the parameter in the function will be fl agged as an error by
> the compiler. Th e const prevents accidental changes to the argument.
> Th e programmer adds const to avoid the bug of unknown modifi cation
> of an object in a diff erent scope.

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  **Pass by Value int f1(int j)**                                                                                            **Pass by Reference int f2(string & b)**                                                                                                                                 **Pass by const Reference void f3(const int & n)**
  -------------------------------------------------------------------------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ -------------------------------------------------------------------------------------------------------------------------------------------
  Grab enough memory                                                                                                         Use four bytes of memory to store the address of the object and copy that address to the function. Use this when you need to modify the argument. It’s effi cient too.   const means the argument cannot be changed. Any attempt to change n results in a compile time error. Use this for effi ciency and safety.
                                                                                                                                                                                                                                                                                                      
  to store the entire object and copy all bytes to the function. A change to the parameter has no eff ect on the argument.                                                                                                                                                                            

  f1 ***cannot*** modify the argument’s state.                                                                               f2 ***can*** modify the argument’s state.                                                                                                                                f3 function ***cannot*** modify the argument’s state. Th is is effi cient.
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

> Th ere are two reasons to use const reference parameters. Th e fi rst
> is effi ciency—the program executes more quickly. Th e other
> consideration is better memory utilization—less memory is required to
> store the large object in the function. For example, passing a small
> object such as int by value only requires the function to allocate and
> then copy four bytes of memory. By contrast, one large object passed
> by value could require thousands of bytes. Th e program might exhaust
> available memory.
>
> Additionally, every single byte of an argument passed by value will be
> copied to the function. Th e computer has to do a lot of unnecessary
> work. Th e program might run noticeably slower. Here are two
> alternatives to make any program more effi cient in terms of space
> (saves memory) and time (runs faster):

1.  Pass big objects by reference—effi cient but somewhat dangerous.

2.  Pass big objects by const reference—effi cient *and* safe.

> Th e second option is recommended. Th e program now has much less work
> to do. When passed by values, the program must then wait until every
> single byte is copied from the caller to the function. If passed by
> const & reference, only four bytes are required while the safety of
> value parameters (cannot change the state of the argument) remains
> intact. Of course, if you are passing an argument to a function in
> order to modify the state, you must pass it by reference with &.
>
> Attempts to modify objects passed by const reference result in compile
> time errors. Using const is an antibugging technique that will let the
> compiler tell us about accidental attempts to modify the const
> parameter. Any function that does not modify the object may still be
> called—string’s length function, discussed in the next chapter, for
> example. However, the compiler will fl ag any attempt to call
> functions such as string’s insert function because as the name
> implies, insert adds things to a string to modify the state of the
> string object. You cannot assign a new value to a const parameter
> either.

Chapter Summary

> void addSomeStuff(**const** string **&** str) { cout &lt;&lt;
> str.length() &lt;&lt; endl; // Okay
>
> str.insert(5, "xtra"); // ERROR: can not modify a const parameter str
> = "new string"; // ERROR: Can not assign to a const parameter }
>
> However, when using value parameters only, you get no such error
> message. Th e argument’s object simply does not change.

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  **Changing** **x** **in** **f** **does not change** **y** **in the main function**                                         **Th is code results in a compile time error such as** **“cannot modify a const object”**
  -------------------------------------------------------------------------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------------
  > \#include &lt;iostream&gt; using namespace std;                                                                          \#include &lt;iostream&gt; using namespace std;
  >                                                                                                                          
  > double f(double x) { double result;                                                                                      double f(const double & x) { double result;
  >                                                                                                                          
  > // This does not modify y x = x – 1.5; result = 2 \* x; return result; }                                                 // An error. Good!
  >                                                                                                                          
  > int main() { // Output:                                                                                                  x = x – 1.5; result = 2 \* x; return result; }
  >                                                                                                                          
  > // 8 double y = 5.0; // y: 5 cout &lt;&lt; f(y) &lt;&lt; endl; cout &lt;&lt; "y: " &lt;&lt; y &lt;&lt; endl; return 0;   int main() { double y = 5.0; cout &lt;&lt; f(y) &lt;&lt; endl; cout &lt;&lt; "y: " &lt;&lt; y &lt;&lt; endl; return 0;
  >                                                                                                                          
  > }                                                                                                                        }
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

> It should be noted that only a few objects will be passed by const
> reference until later. So you will only occasionally see a big object
> passed by const reference in the next several chapters. Also, value
> parameters will be more common than reference parameters.

CHAPTER SUMMARY

-   Functions perform some well-defi ned services and can have two-way
    > communication through argument/parameter associations and the
    > return statement. Th e client code supplies input values to the
    > function as arguments. Th e result is returned via the
    > return statement.

-   Th ere are several new implementation issues related to functions
    > such as the scope of identi-fi ers:

-   All identifi ers must be declared before they can be referenced.

-   Th e scope of an object is limited to the block where it
    > is declared.

-   Some identifi ers are not declared within a block. In this case,
    > they are global identifi -ers. Examples of global identifi ers
    > include function sqrt after \#include &lt;cmath&gt;, and the
    > global object std::cout after \#include &lt;iostream&gt;.

-   Th e scope of a parameter is limited to its function.

-   Th e scope of a function begins at the function heading and
    > continues to the end of its fi le, or the end of the fi le that
    > included the function.

-   Th ere are many details to remember when using
    > argument/parameter associations.

-   Th e number of arguments used in a function call must match the
    > number of param-eters declared in the function heading.

-   Th e void return type precedes the function name when no value is to
    > be returned. You cannot return anything from a void function.

-   When one value is to be returned from a function, a non-void return
    > type must begin the function heading. Th e return statement must
    > also be included in the function block. Th e expression in the
    > return statement should be the same class as the return type.

-   Sometimes a function needs input—that is what parameters are for.
    > Sometimes a function must return something—that is what the return
    > statement is for. Sometimes a function needs to modify objects in
    > the client code—that’s what reference parameters are for.

-   Th e argument used in a function call should usually be the same
    > class as its associated parameter. Th ere are exceptions; for
    > example, an int argument may be assigned to a double parameter
    > with type conversion.

-   Parameters intended only to receive copies of the argument values
    > (input parameters) should be declared as value parameters
    > without &.

-   Reference parameters (with &) must be used if the intention is to
    > modify the associated argument—a change to a reference parameter
    > alters the object reference by the argument. A change to a value
    > parameter does not.

-   const reference parameters are used to pass large objects. Instead
    > of consuming extra bytes of memory and copying that memory, the
    > address is copied—because of &. However, the safety of value
    > parameters is ensured by making the parameter const.

EXERCISES

1.  How many statements may be written in a block delimited by { }?

2.  Which function is called fi rst when a C++ program executes?

3.  May a function be called more than once?

4.  Write the output generated by the following program:

> \#include &lt;iostream&gt; using namespace std;

4.1: Implementing Your Own Functions

> double f2(double x, double y) { return 2 \* x - y; }
>
> int main() {
>
> cout &lt;&lt; f2(1, 2.5) &lt;&lt; endl; cout &lt;&lt; f2(-4.5, -3)
> &lt;&lt; endl; cout &lt;&lt; f2(5, -2) &lt;&lt; endl; return 0; }
>
> 5\. Write the output generated by the following function:
>
> \#include &lt;iostream&gt;
>
> \#include &lt;cmath&gt; using namespace std;
>
> double mystery(double p) { return pow(p, 3) - 1; }
>
> int main() { double a = 3.0; cout &lt;&lt; mystery( a) &lt;&lt; endl;
> cout &lt;&lt; mystery(4.0) &lt;&lt; endl; cout &lt;&lt; mystery( -2)
> &lt;&lt; endl; return 0; }

6.  Write a function double sumOf3 that returns the sum of any
    > three doubles. For example, sumOf3(1.5, 2.2, 3.7) should
    > return 7.4.

7.  Write a function int maxOf4 that returns the largest of the four
    > integer arguments. For example, maxOf4(99, 2, 99, -4) should
    > return 99.

8.  What is the scope of these identifi ers being referenced in the
    > following code?

  a\. std      f.   f
  --------- -- ---- --------
  b\. cin      g.   result
  c\. MAX      h.   s
  d\. aaa      i.   cout

> e\. string
>
> \#include &lt;iostream&gt;
>
> \#include &lt;cmath&gt; using namespace std; const double MAX = 2.0;
>
> double f(double aaa) { double result; result = pow(3.0, aaa); return
> result; }
>
> int main() { string s = "a string"; cout &lt;&lt; f(MAX); return 0; }

9.  Will a change to a value parameter modify the associated argument?

10. Will a change to a reference parameter modify the associated
    > argument?

11. Write the output generated by this program:

> \#include &lt;iostream&gt; using namespace std;
>
> void changeArgs(double & x, double & y) { x = x - 1.1; y = y + 2.2; }
>
> int main() { double a = 3.3; double b = 4.4;
>
> cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl; changeArgs(a,
> b); cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;
> changeArgs(a, b); cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt;
> endl; return 0; }

PROGRAMMING TIPS

1.  Here are some common mistakes made when writing functions:

    -   Placing the semicolon at the end of a function heading:

> string move(int n) ; // ERROR
>
> { // many errors agged here. Remove ; from line above }

Programming Tips

-   Assigning a value to the function name:

> double f(double x) {
>
> f = 2 \* x; // ERROR: Can not assign value to function return f; //
> ERROR: Can not return a function name }
>
> Th e solution: Declare a local object, assign it the value, and return
> it. Or, in the case of simple functions, simply return the expression:
>
> double f(double x) { return 2 \* x; } or do this when there is more
> going on inside the function:
>
> double f(double x) { double result; result = 2 \* x; return result; }

-   Failing to return a value from a non-void function:

> double f2(double x) { double result; result = 2 \* x;
>
> // ERROR: f2 must return a number
>
> }

-   Returning a value from a void function:

> void foo(double x) { return 2 \* x; // ERROR }

1.  Th ere are several ways that functions communicate with each other:

    -   Th e caller can send values and objects to a function by value.

    -   Th e caller sends objects as arguments to a function by
        > reference when the function is de-signed to change
        > the arguments.

    -   Th e caller sends objects as arguments to a function by const
        > reference to save time and memory when the function is not
        > supposed to change the arguments.

    -   Th e caller gets values back from a function via the
        > return statement.

    -   Th e caller gets values back from a function by having the
        > function change arguments associ-ated with reference
        > parameters changed in the function.

2.  If you want two or more values back from a function, use
    > reference parameters. Th e return statement returns only
    > one thing. If you need more than one thing back from a function,
    > use one or more reference parameters in addition to a
    > return statement.

**PROGRAMMING PROJECTS**

4A SUM THREE

> Write the function sumThree that returns the sum of three double
> arguments.
>
> // Test drive sumThree int main() {
>
> cout &lt;&lt; sumThree(1.1, 2.2, 3.3) &lt;&lt; endl; // 6.6 cout
> &lt;&lt; sumThree(-1, -2, 3) &lt;&lt; endl; // 0 return 0; }

4B ROUNDING TO ~n~ DECIMAL PLACES

> Write a function named round that returns the value of its double
> argument rounded to the number of decimal places specifi ed as the
> second argument.
>
> // Test drive round int main() {
>
> // Arguments: number to round (-2.9), decimal places (0) cout &lt;&lt;
> round(-2.9, 0) &lt;&lt; endl; // -3 cout &lt;&lt; round(-2.59, 1)
> &lt;&lt; endl; // -2.6 cout &lt;&lt; round(0.0059, 2) &lt;&lt; endl;
> // 0.01 cout &lt;&lt; round(1.23467, 3) &lt;&lt; endl; // 1.235 cout
> &lt;&lt; round(9.999999, 4) &lt;&lt; endl; // 10 return 0; }

4C PAYMENT

> Th e payment on a loan is a function of the interest rate, the number
> of payments (periods), and the amount borrowed. Pass these three
> values as arguments to a function payment that returns the loan
> payment. Th e function heading is provided for you along with a test
> driver. Round your answer to two decimal places (see Section 3.2). See
> if your answers match an online mortgage calculator.
>
> \#include &lt;iostream&gt; // For the cout object
>
> \#include &lt;cmath&gt; // For pow, which you de nitely need here
> using namespace std;
>
> double payment(double amtBorrowed, double interestRate, int
> numPeriods) {
>
> // TODO: Complete this function
>
> } int main() { // Test drive payment
>
> // 6.0 needs to be divided by 100 and then by 12 to become a monthly
>
> // interest rate, The number of years (30) also needs to multiplied

Programming Projects

> // by 12. The following test cases represent a monthly payment.
>
> cout &lt;&lt; payment(185000.00, 6.0/100.0/12, 30\*12) &lt;&lt; endl;
> cout &lt;&lt; payment(185000.00, 5.0/100.0/12, 30\*12) &lt;&lt; endl;
> cout &lt;&lt; payment(185000.00, 4.0/100.0/12, 30\*12) &lt;&lt; endl;
>
> return 0; }
>
> Here is the formula used to calculate payments on a loan given the
> amount borrowed, interest rate for one period, and the number of
> periods:
>
> (*Rate* 1)*^Months^*
>
> *Payment = Amount* × *Rate* ×
>
> (*Rate* 1)![](media/image2.png){width="0.42986111111111114in"
> height="0.13333333333333333in"}

4D POPULATION GROWTH PREDICTION

> According to **http://www.census.gov/popclock/**, at the time of this
> writing the population growth in the United States can be predicted as
> follows:

One birth every *8 seconds*

One death every *13 seconds*

One international migrant (net) every *40 seconds*

> Write a function that predicts the population for any number of days
> into the future when also given the current population. Th e following
> test driver must compile and generate the output shown in comments:
>
> int main() {
>
> cout &lt;&lt; populationPrediction (320000000, 0) &lt;&lt; endl; //
> 320000000
>
> // One and two day growth:
>
> cout &lt;&lt; populationPrediction(320000000, 1) &lt;&lt; endl; //
> 320006314 cout &lt;&lt; populationPrediction(320000000, 2) &lt;&lt;
> endl; // 320012628
>
> // One and two year growth
>
> cout &lt;&lt; populationPrediction(320000000, 365) &lt;&lt; endl; //
> 322304554 cout &lt;&lt; populationPrediction(320000000, 2\*365)
> &lt;&lt; endl; // 324609108
>
> return 0; }
>
> Once the function has been tested, write a complete program that
> prompts the user for the current population and the days into the
> future using a dialog that looks just like this:
>
> Predict population growth given the current population and days into
> the future
>
> Current population? 320000000
>
> Day into the future? ***365***
>
> In 365 days, the population should grow by 2304554 to become 322304554

4E QUADRATIC FORMULA

> Th e quadratic formula (below) uses the *a*, *b*, and *c* from
> quadratic equations of the form *ax*^2^ + *bx* + *c* to fi nd both
> roots.

*x* = **-b b^2^ – 4ac**

> 2*a*
>
> For example, the two real roots of *x*^2^ + 3*x* − 4 are 1 and −4 as
> indicated by this dialog and the plotting of this function:
>
> Enter a b and c coef cients of a quadratic equation: ***1 3 -4***
> roots: 1 and -4
>
> 1x\^2 + 3x + -4 when x is 1 should be 0
>
> This should be 0 or very close? 0
>
> 1x\^2 + 3x + -4 when x is -4 should be 0
>
> This should be 0 or very close? 0
>
> You are asked to complete and test these three functions as described
> in the comments:
>
> // Given the 3 coef cients, compute the two roots that
>
> // are made accessible as reference parameters. Assignment to
>
> // root1 and root2 also change the associated arguments. void
> ndBothRoots(double a, double b, double c, double & root1, double &
> root2)
>
> // Evaluate any quadratic equation given the 3 coef cients
>
> // and the root in question. This function should return 0.0, // but
> something close to 0.0 like -6.66134e-16 is okay.
>
> // This function could return nan if b\^2 – 4ac &lt; 0 or a is 0.
> double evaluate(double a, double b, double c, double root)
>
> // Generate the requested dialog using the two functions above. int
> main()
>
> To avoid the roots being not a number (nan) when there is a negative
> square root, complex numbers could be used. However, if the roots are
> not real, the return result is allowed to be nan

Programming Projects

> (or -1.\#IND in Visual Studio as of this writing). Th e quadratic
> equation 3*x*^2^ + 4*x* + 2 has no real roots. Th is program run
> indicates there are no real roots since nan is returned with 3, 4, and
> 2 input for a, b, and c respectively:
>
> Enter a b and c coef cients of a quadratic equation: ***3 4 2***
>
> roots: nan and nan
>
> 3x\^2 + 4x + 2 when x is nan should be 0
>
> This should be 0 or very close? nan
>
> 3x\^2 + 4x + 2 when x is nan should be 0
>
> This should be 0 or very close? nan

