**C H A P T E R E I G H T**

Repetition

SUMMING UP

> Two important control structures have now been discussed—sequence and
> selection. Sequential control refers to the time when every statement
> executes—one after another. One of those statements could be a
> selection statement; in that case, one or more statements may be
> skipped. Selection executes diff erent actions under diff erent
> circumstances. Of course, it is your responsibility as a programmer to
> ensure that the proper actions always occur under the proper
> circumstances.

COMING UP

> Chapter 8 begins a study of repetitive control, the third major
> control structure. Repetition is discussed within the context of two
> major algorithmic patterns—the Determinate Loop pattern and the
> Indeterminate Loop pattern. Th ese two patterns may be implemented
> with the C++ for and while statements, respectively. A repetitive
> control structure executes some actions a specifi ed, predetermined
> number of times or until some event terminates the loop. After
> studying this chapter, you will be able to

-   recognize and use the Determinate Loop pattern to execute a set of
    > statements a predeter-mined number of times

-   implement determinate loops with the C++ for statement

-   recognize and use the Indeterminate Loop pattern to execute a set of
    > statements until some event occurs to stop it (no more data,
    > for example)

-   implement indeterminate loops with the C++ while statement

8.1 REPETITIVE CONTROL

> *Repetition* refers to the repeated execution of a set of statements.
> Repetition occurs naturally in non-computer algorithms such as these:

-   For every name on the attendance roster, call the name. Mark “0” if
    > absent or a checkmark if present.

> 221

-   Practice the fundamentals of a sport.

-   Add the fl our ¼ cup at a time, whipping until smooth.

> Repetition is also used to express algorithms intended for computer
> implementation. If something can be done once, it can be done
> repeatedly. Th ese examples have computer-based applications:

-   Process any number of customers at an automated teller
    > machine (ATM).

-   Continuously accept reservations.

-   While there are more fast food items, sum each item.

-   Compute the course grade for every student in a class.

-   Microwave the food until either the timer reaches 0, the Cancel
    > button is pressed, or the oven door is opened.

> Th is chapter examines repetitive algorithmic patterns and the C++
> statements that implement them. It begins with a statement that
> executes a collection of actions a fi xed, predetermined number of
> times.

**8.1.1 WHY IS REPETITION NEEDED?**

> Many jobs once performed by hand are now accomplished by computers at
> a much faster rate. Th ink of a payroll department with the job of
> producing employee paychecks. With only a few employees, this task
> could certainly be done by hand. However, with several thousand
> employees, a very large payroll department would be necessary to hand
> compute and generate that many paychecks in a timely fashion. Other
> situations requiring repetition include, but are certainly not limited
> to: fi nding an average, searching through a collection of objects for
> a particular item, alphabetizing a list of names, and processing all
> the data in a fi le. Let’s start with the following code that fi nds
> the average of exactly three numbers. No repetitive control is present
> yet.
>
> double sum = 0, average, number; cout << "Enter number: "; //
> <- Repeat cin >> number; // <- these sum = sum + number;
> // <- statements
>
> cout << "Enter number: "; cin >> number; sum = sum +
> number;
>
> cout << "Enter number: "; cin >> number; sum = sum +
> number;
>
> average = sum / 3.0; cout << "average = " << average;
>
> Th ere is a drawback to this brute-force approach to repetition. Any
> time a larger or smaller set of numbers needs averaging, the program
> itself must be modifi ed. It is not general enough to handle input
> sets of various sizes. Using the previous approach, the three
> statements would need
>
> ©
>
> to be repeated for every number. Th is means averaging 100 numbers
> would require an additional
>
> 97 copies of these three statements. Also, the constant 3.0 in average
> = sum / 3.0; would have to be changed to 100.0. A situation like this
> is improved with a structure that can execute these three statements
> over and over again.

**8.2 ALGORITHMIC PATTERN: **

THE DETERMINATE LOOP

> Without the selection control structures of the preceding chapter,
> computers are little more than nonprogrammable calculators. Selection
> control makes computers more adaptable to varying situations. However,
> what makes computers even more powerful is their ability to repeat the
> same actions accurately and very quickly. Two algorithmic patterns
> emerge. Th e fi rst involves performing some action a specifi c,
> predetermined (known in advance) number of times. For example, to fi
> nd the average of 142 test grades, repeat some process exactly 142
> times. To pay 89 employees, repeat some process 89 times. To produce
> grade reports for 32,675 students, repeat some process 32,675 times.
> Th ere is a pattern here.
>
> In each of these examples, the program requires that somehow the exact
> number of repetitions be predetermined. In these situations, the
> number of times to repeat the process must be pre-established and
> constant. One too many or one too few repetitions results in an
> incorrect algorithm. Th is pattern of predetermining the number of
> repetitions and then executing a set of statements precisely that
> number of times is called the Determinate Loop pattern.
>
> Th e Determinate Loop Pattern

  ---------------------------------------------------------------------------------
  **Pattern:**     Determinate Loop
  ---------------- ----------------------------------------------------------------
  **Problem:**     Do something exactly *n* times, where *n* is known in advance.

  **Algorithm:**   *determine n*
                   
                   *repeat the following n times* { *perform these actions* }

  **Code**         double sum = 0.0; int n; double number;
                   
  **Example:**     
  ---------------------------------------------------------------------------------

> cout << "Enter n: "; cin >> n;
>
> // do something n times
>
> for (int count = 1; count <= n; count = count + 1) { cout <<
> "Enter number: "; // <- Repeat these cin >> number; // <-
> statements sum = sum + number; // <- n times }
>
> Th e Determinate Loop pattern uses an integer—named n here—to
> represent the number of times the process must repeat. However, other
> appropriately-named objects certainly are allowed, such as
> numberOfEmployees. So the fi rst thing to do in the Determinate Loop
> pattern is to determine n somehow.

n = *number of repetitions*

> Th e number of repetitions may come from keyboard input as in cin
> >> n;. Or n may be defi ned at compile time, int n = 124;. Or n
> may be passed as an argument to a function as in pow(x, n). Once n is
> defi ned, another object—named count here—controls the loop
> iterations. Other appropriately-named objects could be used, counter
> for example. Th e Determinate Loop pattern is shown next in the
> context of a small program. It is implemented with the C++ for
> statement.
>
> // Determine the average of n inputs. The user must supply n.
>
> \#include <iostream> // For cout, cin, and endl using namespace
> std;
>
> int main() {
>
> int n = 0; // The number of inputs--supplied by user double sum = 0.0;
> // Keep running sum double number; // Temporarily store each input
> double average; // Holds the average for potential future use
>
> cout << "How many numbers do you need to average? "; cin
> >> n;
>
> for (int count = 1; count <= n; count = count + 1) { cout <<
> "Enter number: "; cin >> number; sum = sum + number; }
>
> average = sum / n;
>
> cout << "Average of " << n << " numbers is "
> << average;
>
> return 0; }
>
> Dialogue
>
> How many numbers do you need to average? ***4***
>
> Enter number: ***70***
>
> Enter number: ***80***
>
> Enter number: ***90***
>
> Enter number: ***100***
>
> Average of 4 numbers is 85
>
> C++ has several structures for implementing the Determinate Loop
> pattern. Th e for statement is most frequently used because it
> combines everything needed after n is determined.

8.2.1 THE for STATEMENT

> Th e following for statement shows the three components that maintain
> the Determinate Loop pattern with the C++ for statement.
>
> int n = 5; // Predetermined number of iterations for (int count = 1;
> count <= n; count = count + 1) {
>
> // Execute this block n times
>
> }
>
> In the preceding for loop, count is declared and initialized with the
> value of 1. Next, count <= n (1 <= 5) evaluates to true and so
> the block executes. When the statements inside the block are done,
> count increments by 1 (count = count + 1). Th ese three components
> ensure that the block executes n times:
>
> count = 1 // Declare and initialize counter count <= n // Loop test
> count = count + 1 // Update counter
>
> General Form 8.1 for *statement*
>
> for (*initial-statement*; *loop-test*; *update-step*) {
> *repeated-statements(s)*;
>
> }
>
> When a for loop is encountered, the *initial-statement* is executed fi
> rst—and only once. Th e *loop-test* is then checked before each
> execution of the *repeated-statement(s)*. Th e *update-step* executes
> after each iteration of the repeated part. Th is process continues
> until the loop test is false.
>
> Th is generalized behavior of a for loop is summarized in this fl
> owchart view:

for

count 15

> int n = 5;
>
> for (int count = 1; count <= n; count = count + 1) { cout <<
> count << " "; }
>
> Output
>
> 1 2 3 4 5

Although a block is not necessary to repeat one statement, consider
always using a block

> ({ }) with the for loop. Th is practice helps avoid diffi
> cult-to-detect intent errors later if you get into the habit of using
> { and }.

8.2.2 OTHER INCREMENT AND ASSIGNMENT OPERATORS

> Assignment operations alter computer memory even when the object on
> the left of = is also involved in the expression to the right of =.
> For example, the int object count is updated by +1 with this
> assignment operation:
>
> count = count + 1;
>
> Th is type of update—incrementing an object—is used so frequently that
> C++ off ers other, additional incrementing operators. Th e ++ and --
> operators increment and decrement an object by 1, respectively. For
> example, the expression count++; adds 1 to the value of count. Th e
> expression x-- reduces x by 1. Th e ++ and -- unary operators alter
> the numeric object that they follow (see the table below).

  **Statement **   **State of** count
  ---------------- --------------------
  int count = 0;   > 0
  count++;         1
  count++;         2
  count--; 1

> So, within the context of the counting for loop, the update step can
> be written as count++ rather than count = count + 1. Th e for loop
>
> for (int count = 1; count <= n; count = count + 1) // . . .
>
> may now be written as this equivalent loop with the ++ operator used
> in the update step:
>
> for (int count = 1; count <= n; count++) // . . .
>
> Th ese new assignment operators are shown because they provide a
> convenient method for accomplishing incrementing and decrementing
> operations in the for loop. Another reason has to do with the fact
> that most C and C++ programs use the ++ operator in for loops.
>
> C++ also has several assignment operators in addition to =. Two of
> them are used to add and subtract value from an object.

  > **Operator **   **Equivalent Meaning**
  ----------------- ---------------------------------------------
  > +=              Increment object on left by value on right.
  > -=              Decrement object on left by value on right.

> Th ese two new operators alter the numeric object that they follow
> (see the table below).

  > **Statement **   **State of** count
  ------------------ --------------------
  > int count = 0;   > 0
  > count += 3;      > 3
  > count += 4;      > 7
  > count -= 2;      > 5

> Whereas the operators ++ and -- increment and decrement the object by
> one, respectively, the operators += and -= increment and decrement the
> object by any amount. Th e += operator is most often used to
> accumulate values inside a loop. For example, the following code sums
> all input by the user:
>
> // Demonstrate the summing pattern
>
> \#include <iostream> using namespace std;
>
> int main() { int n; double aNum;
>
> double sum = 0.0; // Maintains running sum, so start at 0.0
>
> cout << "How many numbers are there to sum? "; cin >> n;
>
> cout << "Enter " << n << " numbers now: "; for (int
> count = 1; count <= n; count++) { cin >> aNum;
>
> sum += aNum; // Equivalent to sum = sum + aNum;
>
> }
>
> cout << "Sum: " << sum << endl;
>
> return 0;
>
> }

  -----------------------------------------------------------------------------------
  > **Dialogue**                                            
  --------------------------------------------------------- ------------------ ------
  > How many numbers are there to sum? ***4***              
  >                                                         
  > Enter 4 numbers now: ***7.5 3.0 1.5 2.0***              

  for **Loop Iteration State of** count **State of** aNum   **State of** sum

  0 0                                                       0.0

  1 1                                                       7.5

  2 2                                                       3.0

  3 3                                                       1.5

  4 4                                                       2.0
  -----------------------------------------------------------------------------------

> Th e += and -= operators also increment and decrement for the loop
> counters by values other than 1:
>
> for (int count = 0; count <= 10; count += 2) { // Count by twos
> cout << count << " ";
>
> }
>
> // Output: 0 2 4 6 8 10

SELF-CHECK

8-1 Does a for loop evaluate the loop test fi rst?

8-2 Must a for loop update step increment the loop counter by + 1?

8-3 Do all for loops always execute the repeated part at least once?

8-4 Describe a situation when the loop test count <= n of a for loop
never becomes false.

8-5 Write the output from the following program segments.

a\. for (int c = 1; c < 5; c = c + 1) { cout << c << " ";
}

b\. int n = 5; for (int c = 1; c <= n; c++) { cout << c <<
" ";

}

c.  int n = 3; for (int c = -3; c <= n; c += 2) { cout << c
    << " "; }

d.  for (int c = 0; c < 5; c++) { cout << c << " "; }

e.  for (int c = 5; c >= 1; c --) { cout << c << " "; }

f.  cout << "before" << endl; int n = 0; for (int c = 1; c
    <= n; c++) { cout << c << " ";

} cout << "after" << endl;

6.  Write a for loop that displays all the integers from 1 to 100 on
    > separate lines.

7.  Write a for loop that displays all the integers from 10 down to 1.

8.2.3 DETERMINATE LOOPS WITH Grid OBJECTS

> A Grid object has row numbers that range from 0 to aGrid.nRows()-1
> inclusive. Th e column numbers range from 0 to aGrid.nColumns()-1
> inclusive. Using these facts and the Determinate Loop pattern allows
> us to manipulate Grid objects more compactly. For example, the
> blockBorder function (below) has two for loops that block all
> intersections on all four edges of any Grid object.
>
> // Use for loops to set blocks around a Grid of any size
>
> \#include <iostream> using namespace std; \#include "Grid.h" //
> For the Grid class
>
> void setBorder(Grid & g) { // Changing g changes the argument
>
> // pre: The mover is not on an edge
>
> // post: The entire outside border is blocked int r, c;
>
> // It is useful that objects know things about themselves--number
>
> // of rows and columns for example, which vary from Grid to Grid for
> (r = 0; r < g.nRows(); r++) {
>
> g.block(r, 0); // Block west edge
>
> g.block(r, g.nColumns()-1); // Block east edge }
>
> // The rst and last columns are blocked already so block // column \#1
> up to 1 less than the last column for (c = 1; c < g.nColumns() - 1;
> c++) {
>
> g.block(0, c); // Block most of the north edge
>
> g.block(g.nRows()-1, c); // Block most of the south edge
>
> }
>
> }
>
> int main() {
>
> Grid aGrid(8, 10, 1, 1, east);
>
> Grid anotherGrid(3, 30, 1, 28, west);
>
> setBorder(aGrid); aGrid.display(); cout << endl;
>
> setBorder(anotherGrid); anotherGrid.display(); return 0;
>
> }
>
> Output
>
> The Grid
>
> \# \# \# \# \# \# \# \# \# \#
>
> \# > . . . . . . . \#
>
> \# . . . . . . . . \#
>
> \# . . . . . . . . \#
>
> \# . . . . . . . . \#
>
> \# . . . . . . . . \#
>
> \# . . . . . . . . \#
>
> \# \# \# \# \# \# \# \# \# \#
>
> The Grid
>
> \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \#
> \# \# \# \# \# \# \#
>
> \# . . . . . . . . . . . . . . . . . . . . . . . . . . . < \#
>
> \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \#
> \# \# \# \# \# \# \#
>
> Th e for loops—applied in yet another instance of the Determinate Loop
> pattern—reduce the number of instructions. For example, a 20-by-20
> Grid would require exactly 76 block messages. More importantly, such a
> brute-force approach would allow the function to work only on a
> 20-by-20 Grid. Th e accessor functions Grid::nColumns and Grid::nRows
> and the determinate for loop pattern allow the function to work
> properly for any sized Grid. Th is is because every Grid object knows
> its own size.

SELF-CHECK

> 8-8 What diff erence occurs when the fi rst for loop in setBorder is
> changed to for (r = 0; r <= g.nRows(); r++)?
>
> 8-9 What diff erence occurs when the second for loop in setBorder is
> changed to for (c = 1; c < g.nColumns(); c++)?
>
> 8-10 What diff erence would occur when the function heading is changed
> to void setBorder(Grid g)?

8.3 APPLICATION OF THE DETERMINATE LOOP PATTERN

> *Problem:* Write a program that determines a range of temperature
> readings. Range is defi ned as the diff erence between the highest and
> lowest. Th e user must supply the number of temperature readings fi
> rst.
>
> In this application, the user is required to enter the total number of
> temperature readings before entering the actual temperatures. Th e
> output must be labeled as Range followed by the range of temperatures
> (23–11 or 12 with this dialogue). Th e dialogue must look like this:
>
> Dialogue
>
> Enter number of temperature readings: ***6***
>
> Enter temperatures:
>
> ***11***
>
> ***15***
>
> ***19***
>
> ***23***
>
> ***20***
>
> ***16***
>
> Range: 12

8.3.1 ANALYSIS

> Th e number of temperature readings will fi rst be obtained from the
> user. An integer named n will serve nicely. Another numeric object is
> required to hold the individual temperature readings as they are
> processed. Th is object could be appropriately named aTemp. Th e range
> of temperature readings is the diff erence between the highest and
> lowest temperature readings in the list, so two more objects are
> needed to store the highest and lowest.
>
> To fi nd the range without the aid of a computer (easier with a small
> number of temperature readings), one could glance at the list of
> numbers and simply keep track of the highest and lowest while scanning
> the list from top to bottom:

  > aTemp   highest   > lowest
  --------- --------- ----------
  > -5      > -5      -5
  > 8       > 8       -5
  > 22      > 22      -5
  > -7      > 22      -7
  > 15      > 22      -7

> For this set of data, the range = highest - lowest = 22 - (-7) = 29 as
> shown in this sample problem.

  **Problem Description **   **Object Name **   **Sample Values **   **Input/Output**
  -------------------------- ------------------ -------------------- ------------------
  > Compute the range of     n                  5                    Input
  > temperature readings     aTemp              -5, 8, 22, -7, 15    Input
                             highest            22                   Process
                             lowest             -7                   Process
                             range              29                   Output

8.3.2 DESIGN

> For a large list—an approach more suited to a computer—the algorithm
> mimics the repetition of the hand-operated version just suggested. It
> uses a determinate loop to compare every temperature reading in the
> list to the highest and lowest—updating them if necessary.
>
> Determining the Range Algorithm
>
> *input the number of temperature readings (n)* for *each temperature
> reading* { *input aTemp from user*
>
> if *aTemp is greater than highest so far,* *store it as the highest*
> if *aTemp is less than lowest so far,* *store it as the lowest*
>
> } *range = highest – lowest*

As usual, it is a good idea to walk through the algorithm to verify its
soundness.

1.  Input the number of temperature readings (n == 5)

2.  Input aTemp from user (aTemp == -5)

3.  If aTemp > highest so far (-5 > Whoops!), store it as highest

> Th ere is no value for highest or lowest. Let us now assume the
> program will initialize highest and lowest to 0:

lowest = 0; highest = 0;

1.  Input the number of temperature readings (n == 5)

2.  Input aTemp from user (aTemp == -5)

3.  If aTemp is greater than highest so far (-5 > 0), store it as
    > highest (highest stays 0)

4.  If aTemp is less than lowest so far (-5 < 0), store it as lowest
    > (lowest becomes -5) Well, this seems to work. How about one more
    > iteration?

<!-- -->

2.  Input aTemp from user (aTemp == 8)

3.  If aTemp is greater than highest so far (8 > 0), store it as
    > highest (highest becomes 8)

4.  If aTemp is less than lowest so far (8 < 0), store it as lowest
    > (lowest stays -5)

> Seems okay. Try three more inputs to verify that highest and lowest
> are correct. Finally, the last step in the algorithm (after the
> repetition) produces the range: range = highest - lowest.

SELF-CHECK

> 8-11 What is the range when n is 4 and the temperature readings are 1
> 2 3 4?
>
> If you did the previous self-check question correctly, you will notice
> that lowest stays 0. Th e initial value of lowest is less than all
> subsequent inputs. So what might have seemed to work does not. Th e fi
> rst test set works only because a negative temperature was input. Th e
> same algorithm will not work on a warmer day when all temperatures are
> positive. So instead of initializing both highest and lowest to 0,
> consider setting highest to something ridiculously low, say -9999, so
> low that any input will have to be higher. Set highest to something
> ridiculously high like 9999, so high that any input will have to be
> lower. Better yet, set lowest to the largest integer that is defi ned
> in C++ as INT\_MAX. Also set lowest to the minimum integer that is
> defi ned in C++ as INT\_MIN. You may need to use \#include
> <climits>.
>
> \#include <iostream>
>
> \#include <climits> // for INT\_MIN and INT\_MAX
>
> int main() {
>
> std::cout << INT\_MIN << std::endl; std::cout <<
> INT\_MAX << std::endl; return 0; }
>
> Output (may vary with diff erent compilers)
>
> -2147483648
>
> 2147483647

8.3.3 IMPLEMENTATION

> Since the problem stated that the user must fi rst supply the number
> of inputs, the exact number of repetitions is determined. Th is is an
> instance of the Determinate Loop pattern.
>
> for (int count = 1; count <= n; count++) {
>
> // Process one input
>
> }
>
> Th e following program implements a corrected algorithm (written now
> in C++ rather than pseudocode). Notice that the user need not input
> the same set of temperature readings twice— the checks are made for
> both the highest and the lowest within the same loop.
>
> // Determine the range of temperatures in a set of known size
>
> \#include <iostream>
>
> \#include <climits> // For INT\_MIN and INT\_MAX using namespace
> std;
>
> int main() { int aTemp, n, range;
>
> int highest = INT\_MIN; // All ints will be >= INT\_MIN int lowest
> = INT\_MAX; // All ints will be <= INT\_MAX
>
> cout << "Enter number of temperature readings: "; cin >>
> n;
>
> // Input rst temperature to record it as highest and lowest cout
> << "Enter readings 1 per line" << endl;
>
> // Use a determinate loop to process n temperatures for (int count =
> 1; count <= n; count++) {
>
> // Get the next input cin >> aTemp;
>
> // Update the highest so far, if necessary if (aTemp > highest)
> highest = aTemp;
>
> // Update the lowest so far, if necessary if (aTemp < lowest)
> lowest = aTemp; }
>
> range = highest - lowest; cout << "Range: " << range
> << endl; return 0; }
>
> Dialogue
>
> Enter number of temperature readings: ***5***
>
> Enter readings 1 per line
>
> ***-5***
>
> ***8***
>
> ***22***
>
> ***-7***
>
> ***15***
>
> Range: 29

8.3.4 TESTING

> Programmers gain confi dence that a program works by picking an
> arbitrary number of test cases. Th e fi rst test case was letting n be
> 5 with readings of ***-5***, ***8***, ***22***, ***-7***, and
> ***15***. Th is set of inputs shows the diff erence between the
> highest and lowest is (22 − (−7)) or 29. Looking at the dialogue and
> seeing the range is 29 could lead us to believe that the algorithm and
> implementation are correct. However, the only thing that is sure is
> this: when those particular fi ve temperatures were entered, the
> correct range was displayed. Th e data used in this previous test
> would indicate that everything is okay. Other test cases include
> letting n be 1 for a range of 0, two numbers that are the same,
>
> a sequence of all negative integers, a sequence of all positive
> integers, a sequence in ascending order, and another sequence in
> descending order.
>
> Testing only reveals the presence of errors, not the absence of
> errors. If the range were shown as an obviously incorrect answer (-11,
> for example), hopefully, you would detect the presence of the error.
> Now consider this slightly diff erent implementation sometimes seen in
> introductory courses:
>
> for (int count = 1; count <= n; count++) { cin >> aTemp; if
> (aTemp > highest) highest = aTemp; else if (aTemp < lowest)
> lowest = aTemp; }

SELF-CHECK

> 8-12 Trace the code above using the same input (assume n is 5):

-5 8 22 -7 15

and predict the value stored in range. Is it correct?

> 8-13 Trace through the same code with these inputs (assume n is 5):

5 4 3 2 1

Predict the value stored in range. Is it correct?

> 8-14 Trace through the same code with these inputs (assume n is 3):

1 2 3 4

Predict the value stored in range. Is it correct?

> 8-15 *Multiple Choice:* When is range incorrectly computed?

a.  When the input is entered in descending order.

b.  When the input is entered in ascending order.

c.  When the input is entered in neither ascending or descending order.

> 8-16 What must be done to correct the error?

8.3.5 WHAT TO DO WHEN AN INTENT ERROR IS DETECTED

> When you detect an intent error and a loop is involved, it is
> recommended that you display important values, such as highest and
> lowest, for each iteration of the loop. Th is simple debugging tool
> reveals what is happening and, in so doing, helps the debugging
> process. A few well-placed output statements can be very revealing.
> For example, a debugging output statement could be included in the
> loop that contained the intent error:
>
> for (int count = 1; count <= n; count++) { cin >> aTemp;
>
> // Add an output statement in the loop to aid debugging cout <<
> highest << " " << lowest << endl; . . .
>
> Now the dialogue, while testing the incorrect algorithm just before
> the preceding self-checks, would look like this:
>
> Enter number of temperature readings: 3
>
> Enter readings 1 per line
>
> 5
>
> -2147483648 2147483647
>
> 7
>
> 5 2147483647
>
> 12
>
> 7 2147483647
>
> Range: -2147483635

**8.4 ALGORITHMIC PATTERN:**

THE INDETERMINATE LOOP

> Although the Determinate Loop pattern occurs frequently in many
> algorithms, it has a serious limitation—someone, somehow, must
> determine the number of repetitions in advance. Quite often this is
> impossible, or at least very inconvenient and diffi cult. For example,
> an instructor may have a diff erent number of tests to average as
> attendance varies between terms. A company may not have a constant
> number of employees as there are hires, fi res, layoff s, transfers,
> and retirements. Th e schools where the software is distributed may
> have a diff erent number of students each day.
>
> It is often necessary to execute a set of statements an undetermined
> number of times, for example to process report cards for *every*
> student in a school—not precisely 310 every term. Programs cannot
> always depend on prior knowledge to determine the exact number of
> repetitions. It is often more convenient to think in terms of “process
> a report card for all students” rather than “process precisely 310
> report cards.” Th is leads to another recurring pattern in algorithm
> design that captures the essence of repeating a process an unknown
> number of times. It is a pattern to help design a process that
> iterates until some event occurs to indicate the looping is fi nished.
>
> Here are some events used in this textbook to terminate loops:

-   Th e loop counter becomes greater than the desired number of
    > iterations

-   Th e mover on a Grid can no longer move forward

-   Th e user enters a special value to indicate there is no more input

-   Th e end of the fi le is reached (see Chapter 9: File Streams)

> Whereas the number of repetitions for determinate loops is known in
> advance, the Indeterminate Loop pattern uses other techniques to stop.
> With indeterminate loops, the number of repetitions need not be known
> in advance.
>
> Th e Indeterminate Loop Pattern

  ---------------------------------------------------------------------------------------------------------------------
  **Pattern:**     Indeterminate Loop
  ---------------- ----------------------------------------------------------------------------------------------------
  **Problem:**     Some process must repeat an unknown number of times so some event is needed to terminate the loop.

  **Algorithm:**   while (*the termination event has not occurred*) { *perform these actions*
                   
                   *do something to bring loop closer to termination* }

  **Code**         // Place things until the mover is blocked while (aGrid.frontIsClear()) { aGrid.putDown();
                   
  **Example:**     
  ---------------------------------------------------------------------------------------------------------------------

> aGrid.move(); }

Th e C++ while statement is often used to implement the Indeterminate
Loop pattern:

> General Form 8.2 while *statement*
>
> while (*loop-test*) { *repeated-statements*
>
> }
>
> Th e *loop-test* is a logical expression that evaluates to either true
> or false. Th e *repeated-statement(s)* may be any C++ statement, but
> it is usually a set of statements enclosed in { and }.
>
> When a while loop is encountered, the loop test evaluates to either
> true or false. If true, the repeated part executes. Th is process
> continues while (as long as) the loop test is true.

8.4.1 THE USE OF while TO IMPLEMENT THE DETERMINATE LOOP PATTERN

Th e while loop could also implement the Determinate Loop pattern. It is
simply a matter of moving the initialization before the while loop and
the update step to the bottom of the repeated part.

> // initialization while ( *loop-test* ) { // Activities to be repeated
> *update-step* }

Th e following code represents an alternate implementation of the
determinate loop pattern:

> // Sum the rst n integers int accumulator = 0;
>
> int count = 1; // Initialization int n = 5; // Initialization while
> (count <= n) { // Loop test accumulator = accumulator + count ; //
> Action count++; // Update step } cout << "Sum of the rst "
> << n << " integers is " << accumulator;
>
> Although the while loop can also be used for determinate loops, the
> for loop is more concise and convenient. It is recommended that you
> use the for loop when the number of iterations is known in advance.
> When this cannot be determined, as with indeterminate loop problems,
> use the while statement instead.

8.4.2 INDETERMINATE LOOP PATTERN WITH Grid OBJECTS

> Th ere are many events used to terminate the loop in an Indeterminate
> Loop pattern. Consider moving the mover up until the edge of a Grid,
> or perhaps a block, prevents the mover from continuing—a subproblem
> that will come in very handy for one of the Grid-related programming
> projects.
>
> // The event loop terminates when the front is no longer clear
>
> \#include <iostream> // For cout
>
> using namespace std; // allow cout instead of std::cout \#include
> "Grid.h" // For the Grid class
>
> void moveTillStopped(Grid & g) {
>
> // post: The mover is facing a block or edge in front while
> (g.frontIsClear()) {
>
> g.move();
>
> }
>
> }
>
> int main() {
>
> Grid tarpit(5, 10);
>
> cout << "When initialized with only the number of rows\\n"
> << "and columns, a Grid object gets a random opening\\n"
>
> << "with the mover at a random location and direction\\n"
>
> << endl;
>
> moveTillStopped(tarpit); tarpit.display();
>
> return 0; }
>
> Dialogue
>
> When initialized with only the number of rows and columns, a Grid
> object gets a random opening with the mover at a random location and
> direction
>
> The Grid
>
> \# \# \# \# \# \# \# \# \# \#
>
> . . . . . . . . . \#
>
> \# . . . > \#
>
> \# . . . . . . . . \#
>
> \# \# \# \# \# \# \# \# \# \#
>
> Because of the randomness of the Grid object tarpit, moveTillStopped
> uses an indeterminate loop to advance the mover. Th e g.move() message
> may repeat the move message once, twice, or as many times as necessary
> to get the mover up against the “wall.”

SELF-CHECK

> 8-17 Why must moveTillStopped use an Indeterminate Loop rather than a
> Determinate Loop pattern?

8.4.3 THE INDETERMINATE LOOP USING A SENTINEL

> A *sentinel* is a specifi c input used to terminate an indeterminate
> loop. A sentinel value should be the same class of data as the other
> input. However, the sentinel is not meant to be processed as a valid
> part of the input. For example, the following set of inputs hints that
> the input of -1.0 is the event that terminates the loop and that -1.0
> is not to be counted as a valid test score. Otherwise, the average
> would not be 80.0.
>
> Dialogue
>
> Enter tests scores \[0.0 through 100.0\] or -1.0 to quit
>
> ***80.0 90.0***
>
> ***70.0***
>
> ***-1.0***
>
> Average of 3 tests = 80
>
> Th is dialogue asks the user either to enter data in the range of 0.0
> through 100.0 inclusive or to enter -1.0 to signal the end of data.
>
> With sentinel indeterminate loops, a message is usually displayed to
> indicate how the user must end the input. It is important to inform
> the user that a sentinel is being used. Th e user must be told what
> that sentinel value is. It could have been -999 or any other negative
> number, for example.

8.4.4 USING cin >> AS A LOOP TEST

> Up to this point, cin >> has often been used for input. What
> hasn’t been revealed is this: a cin statement returns true when it is
> successful. If the input operation fails to get a number, cin >>
> is replaced with false. Th is means that a cin >> statement can
> be, and often is, used as the logical expression in an if...else or
> while statement:
>
> if (cin >> intObject) - or - while (cin >> intObject)
>
> Both of the above logical expressions return true when cin
> successfully extracts a valid integer from the input stream. However,
> the same logical expressions return false if an invalid integer is
> encountered in the input stream or, as shown later, the end of fi le
> is found. With this new information, implementation of sentinel loops
> is simplifi ed when the cin extraction is part of the loop test.
>
> // The priming extraction is now part of the loop test while ((cin
> >> testScore) && (testScore != sentinel)) { accumulator =
> accumulator + testScore; // Update accumulator n++; // Update total
> inputs }

Th e actual return value of the input statement cin >> testScore
isn’t all that important.

> However, because cin >> testScore is guaranteed to execute fi
> rst, testScore is guaranteed to have obtained a valid numeric value
> through keyboard input before it is compared to the sentinel.
>
> Th e second part (testScore != sentinel) evaluates to true *only* if
> the input was the sentinel (-1.0 in this case). So for any valid data,
> this loop test is true && true, which evaluates to true. In this case,
> the loop executes the repeated part. For example, the loop test is
> evaluated like this when 95.0 is entered:
>
> Loop Test Evaluation When Input Is 95.0
>
> while ((cin >> testScore) && (testScore != sentinel)) ( true &&
> ( 95.0 != -1.0 ))
>
> ( true && true ) true
>
> Th e loop test is true only if a valid number is input and that number
> is not -1.0. With 95.0, the loop test is true (true && true is true).
> When the sentinel of -1.0 is entered, the loop test is false (true &&
> false is false)—the termination condition is reached.
>
> Loop Test Evaluation When Input Is -1.0 (or -1)
>
> while ((cin >> testScore) && (testScore != sentinel)) ( true &&
> ( -1.0 != -1.0 )) true && false false
>
> Th is loop test is now placed into the context of a program that
> computes the average of any number of inputs:
>
> // Use a sentinel of -1 to terminate a loop
>
> \#include <iostream> using namespace std;
>
> int main() {
>
> const double sentinel = -1.0; // User enters this to terminate double
> accumulator = 0.0; // Maintain running sum of inputs int n = 0; //
> Maintain total number of inputs double testScore, average;
>
> // Prompt
>
> cout << "Enter test scores \[0.0 through 100.0\] or " <<
> sentinel << " to quit" << endl;
>
> // Input and process at the same time
>
> while ((cin >> testScore) && (testScore != sentinel)) {
> accumulator += testScore; // Update accumulator n++; // Update total
> inputs }
>
> if (n > 0) {
>
> average = accumulator / n;
>
> cout << "Average of " << n << " tests = " <<
> average << endl;
>
> } else
>
> cout << "Can't average 0 numbers" << endl; return 0; }
>
> Dialogue
>
> Enter test scores \[0.0 through 100.0\] or -1.0 to quit
>
> ***80.0 90.0 70.0 -1.0***
>
> Average of 3 tests = 80
>
> Th e following table traces the changing state of the important
> objects to simulate execution of the previous program. In addition to
> keeping the running sum of the test scores in accumulator, n must also
> be incremented by 1 for each valid testScore.

  > **Iteration **   testScore   accumulator   n   testScore != sentinel Number
  ------------------ ----------- ------------- --- ------------------------------
  Before the loop    NA          0.0           0   NA
  Loop 1             70.0        70.0          1   true
  Loop 2             90.0        160.0         2   true
  Loop 3             80.0        240.0         3   true
  > After the loop   NA          240.0         3   NA

SELF-CHECK

> 8-18 Determine the average for each of the following code fragments by
> simulating execution when the user inputs ***70.0***, ***90.0***,
> ***80.0***, ***-1***.

a.  cin >> testScore; while (testScore != sentinel) { cin >>
    > testScore; accumulator += testScore; // Update accumulator

> n++; // Update total inputs
>
> }
>
> average = accumulator / n; // Division by 0 possible

a.  cin >> testScore; while (testScore != sentinel) { accumulator
    > += testScore; // Update accumulator n++; // Update total inputs

> cin >> testScore;
>
> }
>
> average = accumulator / n; // Division by 0 possible

19. If you answered 80.0 for both a and b above, redo both until you get
    > diff erent answers.

20. Which code (a or b) is equivalent to the previous complete program
    > where the loop test is while ((cin >> testScore) &&
    > (testScore != sentinel))?

8.4.5 INFINITE LOOPS

> It is possible that a loop may never execute, not even once. It is
> also possible that a while loop will never terminate. Consider the
> following while loop that potentially continues to execute until
> external forces are applied (turning off the computer or a hardware
> failure, for example). Th is is potentially an *infi nite loop*,
> something that is usually undesirable.
>
> cin >> testScore; while (testScore != sentinel) {
>
> accumulator += testScore; // Update accumulator n++; // Update total
> inputs }
>
> Th e loop repeats virtually forever. Th e termination condition can
> never be reached. Th e loop test is always true because there is no
> statement in the repeated part that brings the loop closer to the
> termination condition of testScore == sentinel. When writing while
> loops, remember to ensure that the loop test will eventually become
> false.
>
> When you do get a program that executes a loop over and over again—and
> you will—use the system-dependent method necessary to terminate the
> program that is executing the infi nite loop (ask your instructor).

SELF-CHECK

> 8-21 How many iterations of the previous loop occur when the user
> enters the sentinel (-1.0) as the very fi rst input?
>
> 8-22 What activity should be added to the previous while statement so
> each loop iteration brings the loop one step closer to termination?
>
> 8-23 Th e following code represents another example of an infi nite
> loop. What must be done to make this loop terminate as intended?
>
> while (g.frontIsClear());
>
> {
>
> g.move(); }
>
> 8-24 Write the output from the following C++ program fragments:

a.  int n = 3;

> int counter = 1; while (counter <= n) { cout << counter
> << " "; counter++;
>
> }

a.  int last = 10; int count = 2; while (count <= last) { cout
    << count << " "; count += 2;

> }

25. Write the number of times count is output. Assume count, sum, and n
    > have been declared as int objects. “Zero,” “infi nite,” and
    > “unknown” are valid answers.

  ----------------------------------------------------------------------------------------------------------------------------------------------
  a.   while (count <= n) { cout << count<< endl;                             d.   count = 1; sum = 0;
                                                                                                  
       }                                                                                          while (count <= 5) { sum += count; sum++;
                                                                                                  
                                                                                                  }
  ---- ------------------------------------------------------------------------------------- ---- ----------------------------------------------
  b.   n = 5; count = 1; while (count <= n) cout << count << endl; count++;   e.   count = 1; n = 5;
                                                                                                  
                                                                                                  while (count <= n) { count++;
                                                                                                  
                                                                                                  }

  c.   count = 1; n = 0;                                                                     f.   count = 10;
                                                                                                  
       while (count <= n) cout << " " << count;                                    while (count >= 0);
                                                                                                  
                                                                                                  {
                                                                                                  
                                                                                                  count = count - 2;
                                                                                                  
                                                                                                  }
  ----------------------------------------------------------------------------------------------------------------------------------------------

25. Write a code fragment that sums all integers until the user
    > enters 999.

8.5 THE do while STATEMENT

> Th e do while statement is similar to the while loop. It allows a
> collection of statements to be repeated while an expression is true.
> Th e primary diff erence is the time at which the loop test is
> evaluated. Th e while loop test is evaluated at the beginning of each
> iteration. Th e do while statement evaluates the loop test at the end
> of each iteration. Th is means that the do while loop always executes
> its repeated part at least once.
>
> General Form 8.3 do while *loop*
>
> do {
>
> *repeated-statement(s)*
>
> } while ( *loop-test* ) ;
>
> When a do while statement is encountered, all statements within the
> block ({ }) execute. Th e *loop-test* is evaluated at the *end* of the
> loop—not at the beginning. If true, the *repeatedstatement(s)*
> executes again. If the test expression is false, the loop terminates.
> Although the block is not absolutely required with the while and for
> statements, braces must always exist between the do and the while in
> this statement. Here is an example of the do while loop that displays
> the increasing value of counter to simulate its execution.

8.5: The do while Statement

> int counter = 1; int n = 4;
>
> cout << endl << "Before loop..." << endl; do {
>
> cout << "Loop \#" << counter << endl; counter++;
>
> } while (counter <= n); cout << "...After loop" <<
> endl;
>
> Output
>
> Before loop...
>
> Loop \#1
>
> Loop \#2
>
> Loop \#3
>
> Loop \#4
>
> ...After loop
>
> Th e do while loop is a good choice for repetition whenever a set of
> statements must be executed at least once to initialize objects used
> later in the loop test. For example, the do while loop is the
> preferred statement when asking the user to enter one of several
> options. For example, the do while loop in the char type function
> nextOption repeatedly requests the user to enter one of three choices.
> Th e loop does not terminate until the user enters a valid option.
> main also uses a do while loop to process as many deposits and
> withdrawals as the user wants.
>
> // Use a do while loop that repeatedly asks for a valid option
>
> \#include <cctype> // For toupper
>
> \#include <iostream> // For cout, cin, and endl
>
> \#include <string> using namespace std;
>
> char nextOption() {
>
> // post: Return an uppercase W, D, or Q string option; char rstChar;
> do {
>
> cout << "W)ithdraw, D)eposit, or Q)uit: "; cin >> option;
>
> rstChar = toupper(option.at(0));
>
> } while (( rstChar != 'W') && ( rstChar != 'D') && ( rstChar != 'Q'));
> return rstChar;
>
> }
>
> int main() { char choice = 'Q';
>
> do {
>
> choice = nextOption(); // assert: choice is either 'Q', 'W', or 'D'
>
> if ('W' == choice)
>
> cout << "\\nValid entry--process W\\n" << endl;
>
> if ('D' == choice)
>
> cout << "\\nValid entry--process D\\n" << endl;
>
> if ('Q' == choice)
>
> cout << "\\nHave a nice day :)" << endl; } while (choice
> != 'Q');
>
> return 0; }
>
> Dialogue (the user enters one valid entry, three invalid choices, and
> quits with Q)
>
> W)ithdraw, D)eposit, or Q)uit: W
>
> Valid entry--process W
>
> W)ithdraw, D)eposit, or Q)uit: make
>
> W)ithdraw, D)eposit, or Q)uit: 3
>
> W)ithdraw, D)eposit, or Q)uit: invalid entries
>
> W)ithdraw, D)eposit, or Q)uit: Q
>
> Have a nice day :)
>
> Because at least one character must be obtained from the keyboard
> before the test expression evaluates, the do while loop in nextOption
> is used instead of a while loop—the loop must iterate at least once.
> Also, a do while loop is used in main to get an option because it
> needs at least one user input to evaluate whether or not the user
> wants to quit. Although do while is not necessary, it is a bit easier
> to implement than using a while loop.
>
> cout << "W)ithdraw, D)eposit, or Q)uit: "; cin >> option;
>
> rstChar = toupper(option.at(0)); while (( rstChar != 'W') && ( rstChar
> != 'D') && ( rstChar != 'Q')) { cout << "W)ithdraw, D)eposit, or
> Q)uit: "; cin >> option;
>
> rstChar = toupper(option.at(0));
>
> }

SELF-CHECK

> 8-27 Write the output produced by the following code:

a.  int count = 1;

> do { cout << count << endl; count++;
>
> } while (count <= 3);

a.  double x = -1.0; do { cout << x << endl; x = x + 0.5; }
    while (x <= 1.0);

8.6: Loop Selection and Design

28. Write a do while loop that prompts for and reads numbers until the
    > number is in the range of 1 through 10 inclusive.

29. Write a do while loop that prompts for and then reads characters
    > until the user enters w, W, d, D, q, or Q at the prompt Enter
    > W)ithdraw D)eposit Q)uit:.

8.6 LOOP SELECTION AND DESIGN

> For some people, loops are easy to implement, even at fi rst. For
> others, infi nite loops and intent errors are more common. In either
> case, the following outline is off ered to help you choose and design
> loops in a variety of situations:

1.  Determine which type of loop to use

2.  Determine the loop test

3.  Write the statements to be repeated

4.  Bring the loop one step closer to termination

5.  Initialize objects if necessary

8.6.1 DETERMINE WHICH TYPE OF LOOP TO USE

> If the number of repetitions is known in advance or read as input, use
> the Determinate Loop pattern, which has a statement specifi cally
> designed for this—the for loop. Although you can use the while loop to
> implement the Determinate Loop pattern, consider using the for loop
> instead. Th e while implementation allows you to omit one of the key
> counting parts, making any intent errors more diffi cult to detect and
> correct. If you omit one of the counting parts of a for loop, you’ll
> get an easy-to-detect-and-correct compile time error.
>
> If you need to wait until some event occurs during execution of the
> loop, the Indeterminate Loop pattern is more appropriate. If so, use
> the while loop. If the loop must always execute once, for example when
> input data must be checked for validity (an integer value that must be
> in the range of 0 through 100), use the do while loop. A do while loop
> is also a good choice for menudriven programs that repeatedly request
> options until the menu choice for *quit* is entered.

8.6.2 DETERMINE THE LOOP TEST

> If the loop test is not obvious, try writing the conditions that must
> be true for the loop to terminate. For example, if you want the user
> to enter STOP to stop entering input, the termination condition is:
>
> inputName == "STOP"; // Termination condition
>
> Th e logical negation inputName != "STOP" can be used directly as the
> loop test of a while or do while loop.

while (inputName != "STOP") { do {

// . . . // . . .

} } while (inputName != "STOP")

8.6.3 WRITE THE STATEMENTS TO BE REPEATED

> Th is is why the loop is being written in the fi rst place. Some
> common tasks include keeping a running sum, keeping track of a high or
> low value, or counting the number of occurrences of some value. Other
> tasks that will be seen later include searching for a name in a list
> or repeatedly comparing all string elements of a list in order to
> alphabetize it.

8.6.4 BRING THE LOOP ONE STEP CLOSER TO TERMINATION

> To avoid an infi nite loop, at least one action in the loop body must
> bring it closer to termination. In a determinate loop, this might mean
> incrementing or decrementing a counter by some specifi c value.
> Inputting the next value is another way to bring loops closer to
> termination—for example, when the user inputs data until the sentinel
> is extracted from the input stream. In a for loop, the repeated
> statement should be designed to bring the loop closer to termination,
> usually by incrementing the counter. In general, the loop test should
> contain at least one object that is altered during each iteration of
> the loop.

8.6.5 INITIALIZE OBJECTS IF NECESSARY

> Check to see if any objects used in either the body of the loop or the
> loop test need to be initialized. Doing this usually ensures that the
> objects of the loop and the objects used in the iterative part have
> been initialized. For example, consider this loop:
>
> double sum, x, average; int n;
>
> cout << "Enter numbers or -1 to stop: "; while (x != -1) { sum =
> sum + x; n++; cin >> x;
>
> } average = sum / n;
>
> With this code, the values of sum, average, x, and n are garbage. What
> is the initial value of sum, perhaps -1,234.5 or 99,999.9? Th e fi rst
> value of x is unknown, as is that of n. Consider each object in the
> loop test and the iterative part as potential candidates for
> initialization. Th is may require setting n to 0, but it may also
> require that some object becomes initialized through the input
> statement. Here is the corrected code:

Chapter Summary

> double sum = 0.0; int n = 0;
>
> double x, average; // x and average don't require initialization cout
> << "Enter numbers or -1 to stop: "; cin >> x; while (x !=
> -1) { sum += x; n++; cin >> x;
>
> } average = sum / n;

SELF-CHECK

> 8-30 Which loop best accomplishes these tasks?

a.  Sum the fi rst fi ve integers (1 + 2 + 3 + 4 + 5).

b.  Find the average value for a set of numbers when the size of the set
    > is known.

c.  Find the average value for a set of numbers when the size of the set
    > cannot be determined by the program or the user until the data has
    > been completely entered.

d.  Obtain a character from the user that must be an uppercase I, S,
    > or Q.

> 8-31 For a loop to process inputs called value until -1 is entered:

a.  Write a termination condition.

b.  Write the loop test for a while or do while loop.

> 8-32 For each loop, which objects are not initialized but should be?

a.  while (count <= n) {

> // . . . ;
>
> }

a.  for (int count = 1; count <= n; count = count + inc) {

> // . . . ;
>
> }

CHAPTER SUMMARY

-   Repetition is an important method of control for all
    > programming languages. Typically, the body of a loop has
    > statements that may change the state of one or more objects during
    > each loop iteration.

-   Th e for loop is often used to implement the Determinate Loop
    > pattern, which requires that the number of repetitions be
    > determined *before* the loop is encountered.

-   Determinate loops rely on this value (n perhaps) and a properly
    > initialized and incremented loop counter (count perhaps) to track
    > the number of repetitions. Th e counter is compared to the known
    > number of iterations at the start of each loop. Th e counter is
    > automatically updated at the end of each for loop iteration.

-   Th ere are a number of ways to determine the number of loop
    > iterations before the loop executes. Th e number of iterations may
    > be input from the user, passed as an argument to a function,
    > initialized in advance, or n may be part of the state of
    > some object. For example, every Grid object knows its number of
    > rows and number of columns. Every string object knows how many
    > characters it has at any given moment.

-   Th is Determinate Loop pattern is so common that a specifi c
    > statement—the for loop—is built into almost all languages.

-   Indeterminate loops rely on some external event for
    > their termination. Th e terminating event may occur at any time.

-   Indeterminate loops are used when the program is unable to
    > determine, in advance, the number of times a loop must iterate. Th
    > e terminating events include sentinels extracted from the input
    > stream (-1 as a test or “Q” in a menu selection). Th ese types of
    > loops allow any number of bank customers to make any number of
    > transactions or repeatedly prompt a user for input until valid
    > input is entered.

-   Although the while loop is the only repetitive statement needed to
    > solve any computer problem, the for loop is more convenient under
    > certain circumstances. Th e for loop requires the program to take
    > care of the initialization, loop test, and repeated statement all
    > at once. Th e compiler protests if one of these important steps
    > is missing. Th e for loop provides a more compact and less
    > error-prone determinate loop.

-   Remember these steps if you are having trouble designing loops:

>  Determine which type of loop to use
>
>  Determine the loop test
>
>  Write the statements to be repeated
>
>  Bring the loop one step closer to termination
>
>  Initialize objects if necessary

EXERCISES

1.  How many times will the following loops execute cout << "Hello
    > ";? “Zero,” “unknown,” and “infi nite” are perfectly
    > legitimate answers.

    a.  int n = 5;

for (int count = 1; count <= n; count++) {

cout << "Hello ";

}

a.  int n = 0;

for (int count = 5; count >= n; count --) {

cout << "Hello ";

}

Exercises

a.  int n = 5;

for (int count = 1; count <= n; count --) {

cout << "Hello ";

count++;

}

a.  int n = 0;

for (int count = 1; count <= n; count++) {

cout << "Hello ";

}

1.  Write the output produced by these for loops:

> for (int counter = 1; counter <= 5; counter++) cout << " "
> << counter;
>
> cout << "Loop One"; // Incorrectly indented to confuse for (int
> counter = 10; counter >= 1; counter--) cout << " " <<
> counter;
>
> cout << "Blast Off"; // Correctly indented to avoid confusion

1.  Write loops to produce the outputs shown:

    a.  10 9 8 7 6 5 4 3 2 1 0

    b.  0 5 10 15 20 25 30 35 40 45 50

    c.  -1000 -900 -800 -700 -600 -500 -400 -300 -200 -100 0

2.  Write the output generated by the following code:

> int count = 0; while (count < 5) { cout << " " << count
> ; count = count + 1; }

1.  Write a loop that sums all the integers between start and stop
    > inclusive that are input from the keyboard. You may assume start
    > is always less than or equal to stop. If the input were 5 for
    > start and 10 for stop, the sum would be 5 + 6 + 7 + 8 + 9 +
    > 10 (45).

2.  How many times will Hello be displayed using the following program
    > segments? “Zero,” “undetermined,” and “infi nite” are perfectly
    > legitimate answers.

> a\. while (count <= 10) cout << "Hello"; b. count = 1; while
> (count <= 7) { cout << "Hello";
>
> count++;
>
> }

c.  count = 7; while (count <= 1) { cout << "Hello";

}

c.  count = 1; while (count <= 5) cout << "Hello"; count++;

<!-- -->

1.  Write a while loop that produces this output:

> -4 -3 -2 -1 0 1 2 3 4 5 6

1.  Write a while loop that displays 100, 95, . . ., 5, 0 on
    > separate lines.

2.  Write a loop that counts how many perfect scores (the number 100)
    > are entered from the keyboard.

3.  Convert the following code to its for loop counterpart:

> int counter = 1; double sum = 0; int n, number;
>
> cout << "Enter number of ints to be summed: "; cin >> n;
> while (counter <= n) { cin >> number; sum = sum + number;
> counter++;
>
> } cout << sum;

1.  Write a loop that counts the number of words input by a user until
    > the user enters the string ENDOFDATA (must be uppercase letters,
    > no spaces).

2.  Write the complete output generated by the following program when
    > the user enters 1, 2, 3, 4, and -1 on separate lines.

> \#include <iostream> using namespace std;
>
> int main() { double test; double sum = 0.0;
>
> cout << "Enter tests or a negative number to stop: " <<
> endl; while ((cin >> test) && (test >= 0.0)) { sum = sum +
> test;
>
> }
>
> cout << "Sum: " << sum << endl; }

13. Write the output generated by the following code:

> string choice("BDWBQDW"); int count = 0;
>
> while (choice\[count \] != 'Q') {

Exercises

> cout << "Opt: " << choice\[count \] << endl;
> count++; }

13. How many times will the following loops execute cout << "Hello
    > ";? “Zero,” “unknown,” and “infi nite” are perfectly
    > legitimate answers.

  ------------------------------------------------------------------------------------------------------------------
  a.   count = 1; n = 10; do {                                               c.   count = -1; do {
                                                                                  
       cout << "Hello "; } while (count > n);                            cout << "Hello "; count++;
                                                                                  
                                                                                  } while (count != -3);
  ---- --------------------------------------------------------------------- ---- ----------------------------------
  b.   n = 10; count = 1; do {                                               d.   count = 1; do {
                                                                                  
       cout << "Hello "; count = count - 2; } while (count <= n);        cout << "Hello "; count++;
                                                                                  
                                                                                  } while (count <= 100);
  ------------------------------------------------------------------------------------------------------------------

13. Write a do while loop that generates this output:

> 10 9 8 7 6 5 4 3 2 1 0

13. Write the output generated by the following program:

> \#include <iostream> using namespace std;
>
> int main() { int count = -2; do {
>
> cout << " " << count; count--;
>
> } while (count > -6);
>
> }

13. Convert the following code to its do while counterpart:

> char option;
>
> cout << "Enter option A, B, or Q: "; cin >> option; option
> = toupper(option);
>
> while ((option != 'A') && (option != 'B') && (option != 'Q')) { cout
> << "Enter option A, B, or Q: "; cin >> option; option =
> toupper(option); }

13. Write a function named option that prompts for and returns an
    > uppercase S, A, M, or Q only. Th e return type of the option
    > function must be char. Return S, A, M, or Q through the function
    > name, not as a reference. Th e following code must only assign one
    > of four allowed letters to choice:

> char choice = option(); cout << choice; // Output must be either
> S, A, M, or Q only!

PROGRAMMING TIPS

1.  Pick the type of loop you want to use. After recognizing the need
    > for repetition, decide if the number of repetitions can be
    > determined in advance. If so, this is a determinate loop that is
    > best implemented as a for loop. If the number of iterations cannot
    > be determined in advance, fi rst determine the event that will
    > terminate the loop. Use its logical negation as the loop test. For
    > example, the loop will terminate when someone enters the word

> STOP. Th e termination condition is (word == "STOP"). Th e loop test
> is the logical negation while (word != "STOP").

1.  Beware of infi nite loops. Th ey are easy to create and sometimes
    > very diffi cult to fi nd. Can you spot why these are infi nite
    > loops?

  --------------------------------------------------------------------------------------------------------------------
  a.  int count = 1; int sum = 0;                             c.  int count = 1; int sum = 0;
                                                              
  > while (count <= 100);                                  > while (count <= 100)
  >                                                           >
  > { // Sum the rst 100 integers sum += count ; count++; }   > // Sum the rst 100 integers sum += count ; count++;
                                                              
  a.  for (int count = 0; count <=                         c.  for (int count = 0; count <= 100; count++) {
                                                              
  > 100; count++);                                            > // Sum the rst 100 integers sum += count ; count --;
  >                                                           >
  > { // Sum the rst 100 integers sum += count ;              > }
  >                                                           
  > }                                                         
  ----------------------------------------------------------- --------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------

1.  Always write a compound statement for the iterative part of a while
    > loop even if it is not necessary. Th is provides a better chance
    > of including any increment statement as part of the loop rather
    > than accidentally leaving it outside the loop.

2.  Use debugging prints to fi nd out what is going on in a loop. When
    > in doubt, place a debugging cout statement inside the loop to
    > display some important object that should be changing. Th is can
    > be very revealing. Sometimes you’ll spot an infi nite loop. Other
    > times you might spot that the loop test was never true.

> while ( . . . ) {
>
> // . . .
>
> mid = (lo + hi) / 2.0;
>
> cout << "In loop, mid == " << mid << endl; }

1.  Loops may not always execute the iterative part. It is possible that
    > a loop will execute zero times, or fewer than you might
    > have thought.

2.  Th ings become much simpler when the input statement is part of an
    > indeterminate loop test. If you are used to a priming read for
    > sentinel loops—especially you Pascal programmers—try to forget it.
    > C++ allows input as part of the loop test, so it is easier to
    > write sentinel loop tests like this:

> while ((cin >> aNumber) && (aNumber != sentinel)) {
>
> // Process aNumber but not the sentinel
>
> }

1.  Sometimes a "quasi-infi nite" loop with a break is the easiest way
    > to implement a loop. If you are having trouble with loop tests,
    > consider using a loop with a guarded break (this code is
    > equivalent to the previous sentinel loop):

> while ( true ) { cin >> aNumber;
>
> if (aNumber == sentinel) // The termination condition break; // Exit
> this loop
>
> // Otherwise process aNumber
>
> }

**PROGRAMMING PROJECTS**

8A WIND SPEED RECORDING

> Write a program that determines the lowest, highest, average, and
> range of a set of wind speed readings which are all positive or zero.
> Terminate the loop with any negative input. Be sure you notify the
> user how to terminate data entry.
>
> Dialogue
>
> Enter wind speed readings or a number < 0 to quit:
>
> 5.0 6.0 2.0
>
> 8.0 -999 n: 4 High: 8
>
> Low: 2
>
> Range: 6
>
> Ave: 5.25

8B BANK TELLER

> Write a C++ program that allows the user to create exactly one
> BankAccount object and then make as many withdrawals and deposits as
> desired. Th e fi nal line of output should be the balance.
>
> Your code should not allow a withdrawal greater than the balance. Use
> the following dialogue as a guide to this problem’s specifi cation:
>
> Enter customer name: Jackson
>
> Enter initial balance: 0.00
>
> W)ithdraw, D)eposit, or Q)uit: ***D*** Enter deposit amount: 250.00
>
> W)ithdraw, D)eposit, or Q)uit: ***W***
>
> Enter withdrawal amount: 300.00
>
> \*\*Amount requested exceeds account balance\*\*
>
> W)ithdraw, D)eposit, or Q)uit: ***w*** Enter withdrawal amount: 200.00
>
> W)ithdraw, D)eposit, or Q)uit: ***q***
>
> Ending balance: 50

8C FIND THE Grid EXIT

> Write a C++ function named ndExit that instructs the mover to fi nd
> the lone exit in any Grid. Make sure you initialize the Grid object
> with only two arguments—number of rows and number of columns. Th is
> ensures that you will get a Grid that has only one exit. Also, the
> mover will be at a random location facing a random direction every
> time you run the program. Th is will help you test your solution. Use
> the following test driver:
>
> \#include "Grid.h" // For the Grid class
>
> void ndExit(Grid & g) {
>
> // pre: The Grid has exactly one exit, but not at a corner
>
> // post: The mover is located at the lone exit // You complete the
> function here }
>
> int main() {
>
> // Test drive ndExit
>
> Grid tarpit(10, 16);
>
> // assert: The 10-by-16 Grid has the mover in a random location
>
> tarpit.display(); ndExit(tarpit); tarpit.display();
>
> return 0;
>
> }
>
> Output
>
> The Grid:
>
> \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \#
>
> \# \#
>
> \# . . . . . . . . . . . . \#
>
> \# . . . . . . . . . . . . \#
>
> \# . . . . . . . . . \#
>
> \# . . . . . . . . . . . . . \#
>
> < . . . . . . . . . . . . . \#
>
> \# . . . . . . . . . . . . . . \#
>
> \# . . . . . . . . . . . . . . \#
>
> \# \# \# \# \# \# \# \# \# \# \# \# \# \# \# \#

8D A HALF-DOZEN FUNCTIONS WITH LOOPS

> Write one C++ program where your main method is a test driver of your
> own design that tests six new free functions implemented in the same
> fi le. You may write your own tests with assert functions.
>
> /\* \* A test driver like this may be used to test the functions.
>
> \*
>
> \* File name: TestRepetitionFunctions (on the book's website)
>
> \*/ int main() { // Test rstNints assert(15 == rstNints(5)); assert(21
> == rstNints(6));

1.  int rstNints(int n)

> Given an integer argument that represents the number of integers to
> sum, return the sum of the fi rst n integers. Use a for loop. Do not
> use a formula. Assume the argument is always positive.
>
> rstNints(1) returns 1
>
> rstNints(2) returns 3, which is 1+2
>
> rstNints(5) returns 15, which is 1+2+3+4+5

1.  int factorial(int n)

> Return n factorial, which is written as n!. 5! = 5\*4\*3\*2\*1 or in
> general, n! = n\*(n-1)\*(n-2) …\*2\*1. Use a for loop.
>
> factorial(1) returns 1 factorial(2) returns 2, which is 2 \* 1
> factorial(4) returns 24, which is 4 \* 3 \* 2 \* 1

1.  string reverseString(string arg)

Return a new string that has arg’s characters in reverse order.

> reverseString("") returns "" reverseString("1") returns "1"
> reverseString("1234") returns "4321"

1.  int charPairs(string str)

Return the number of times two consecutive characters occur in the given
string.

> charPairs("") returns 0 charPairs("H") returns 0 charPairs("aabbcc")
> returns 3 charPairs("!!!") returns 2 charPairs("mmmm") returns 3
> charPairs("mmOmm") returns 2

1.  int bonacci(int n)

> Return the correct Fibonacci number for the given argument.
> precondition: n >= 0. (*Hint:* Keep track of two consecutive
> Fibonacci numbers.)

n bonacci(n) n bonacci(n)

1.  0 5 5

2.  1 6 8

3.  1 7 13

4.  2 8 21

5.  3 9 34

<!-- -->

1.  void replace(string & str, char oldC, char newC)

> Modify the string argument associated with the parameter str so that
> all occurences of oldC are replaced with newC.
>
> string arg = "bookkeeper"; replace(arg, 'e', 'X'); assert("bookkXXpXr"
> == arg);

8E MASTERMIND

> In this project, you are going to implement a number guessing game
> known as Mastermind. Th is assignment will give you more experience
> with:

-   Strings

-   User input

-   if statements while statements

-   Testing

-   Problem solving

> To fi rst give you an overall feeling for the fi nished game, we fi
> rst present a dialog to show how the game will be played. Assuming
> your program has generated a “secret” number that has fi ve unique
> digits, the game should prompt the player to guess the number. Th e
> input is errorchecked only to ensure the user enters a string of
> length 5. Entering "what?" will not help at all, but it should be
> allowed and should count as a try at the secret number. If the user
> enters "123456" or "1234", notify the user they must enter 5 digits
> but do not count this as an attempt at the secret number.
>
> Th e game rules insist that you give the player some feedback on
> guesses. Based on that feedback, the player makes more guesses.
> Guessing continues until the secret number is guessed or until the
> maximum number of tries (32) is reached. Here is one sample dialog
> that plays one game where the user determines the secret number is
> ***12345***.
>
> Enter your 5 digit guess: ***11111***
>
> Try number: 1
>
> Digits found: 1
>
> Correct position: 1
>
> Enter your 5 digit guess: ***22222***
>
> Try number: 2
>
> Digits found: 1
>
> Correct position: 1
>
> Enter your 5 digit guess: ***99999***
>
> Try number: 3
>
> Digits found: 0
>
> Correct position: 0
>
> Enter your 5 digit guess: ***12333***
>
> Try number: 4
>
> Digits found: 3
>
> Correct position: 3
>
> Enter your 5 digit guess: ***12344***
>
> Try number: 5 Digits found: 4
>
> Correct position: 4
>
> Enter your 5 digit guess: ***what?***
>
> Try number: 6
>
> Digits found: 0
>
> Correct position: 0
>
> Enter your 5 digit guess: ***123456*** '123456' must have a length of
> 5
>
> Enter your 5 digit guess: ***54321***
>
> Try number: 7
>
> Digits found: 5
>
> Correct position: 1
>
> Enter your 5 digit guess: ***12345***
>
> Try number: 8
>
> Digits found: 5
>
> Correct position: 5 You won in 8 tries!
>
> Before implementing the main function, you are asked to fi rst write
> four well-tested examples that will make writing the actual game
> itself much easier with far fewer bugs. Th ese three methods listed
> next should be tested well and have the same exact function headings.
> Sample asserts are included below each function heading to help
> explain the method’s use and behavior.
>
> // Generates a 5-digit, valid secret "number" as a string.
>
> // A secret number is valid if it contains no duplicates and
>
> // all ve characters are digits '0'..'9' string generateSecretNumber()
>
> // Return the number of digits that are contained in both the
>
> // secret number and the guess. For example when secretNumber
>
> // is 12345 and guess is 67821, the two numbers, actually strings,
>
> // share two digits: 1 and 2. int uniqueDigitsFound(string
> secretNumber, String guess)
>
> // Sample assertions from MasterMindTest.java (not a complete test)
> assert(5 == uniqueDigitsFound("12345", "21435")); assert(0 ==
> m.uniqueDigitsFound("12345", "67890"));
>
> // Returns the number of matching digits between the guess
>
> // and the secret number. For example when secretNumber is // "12345"
> guess is "12675" returns 3 as the 1, 2, and 5 all
>
> // have the same value at the same location.
>
> int foundInPosition(String secretNumber, String guess)
>
> // Sample assertions from MasterMindTest.java (not a complete test)
> assert(1, m.foundInPosition("12345", "99399")); assert(3,
> m.foundInPosition("12345", "19395"));

8F CLASS Elevator

> Write the class defi nition and implement the member functions for
> class elevator with a constructor that places an elevator at a
> selected fl oor. Include a void select(int goToFloor) member function
> that allows fl oors to be selected. For every fl oor, the message
> going up or going down should be displayed before the current fl oor
> of the elevator. At that point, select should print "open at" the
> destination fl oor. Th e precondition is that the fl oor is
> selectable, or an int in the range of 1–100. Here is one sample output
> to give you an idea of what a simulated elevator will look like on
> your screen:
>
> \#include "Elevator.h" // For class Elevator int main() {
>
> Elevator aLift(1); // Construct an Elevator object aLift
> aLift.select(5); aLift.select(3); return 0; }
>
> Output
>
> start on oor 1 going up to 2 going up to 3 going up to 4 going up to 5
> open at 5 going down to 4 going down to 3 open at 3

© 2018 Franklin, Beedle & Associates All rights reserved
