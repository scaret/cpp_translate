**C H A P T E R F I V E**

Sending Messages

SUMMING UP

> You have now used and implemented free (non-member) functions. Th ese
> functions represent only a small portion of available non-member
> functions. Th ese free functions—those that are not part of a specifi
> c class—continue to play a role in the C++ language. You can use new
> functions by reading the function headings and associated
> documentation.

COMING UP

> Th is chapter introduces sending messages to existing objects with a
> syntax that diff ers from calling free functions. Th is chapter
> explores some of the standard member functions of the classes string,
> ostream, and istream and two author-supplied classes BankAccount and
> Grid. Th is will help you develop problem-solving skills while
> encouraging you to contemplate the increasing importance of classes
> that encapsulate data members and the member functions that use that
> state.
>
> After studying this chapter, you will be able to

-   send messages to objects

-   use string and ostream messages and understand their eff ects

-   problem solve with string, Grid and BankAccount objects

-   appreciate why programmers partition software into classes, which
    > are collections of member functions combined with their related
    > data members.

5.1 MODELING THE REAL WORLD

> Th e C++ programming language has primitive types to store Booleans,
> characters, and numbers. C++ also has many types implemented with the
> C++ class construct. For example, string (which is implemented as a
> C++ class) stores a collection of characters along with other
> information such as the number of characters in that string. string
> type objects represent names, addresses—all sorts of data. Other
> classes allow programmers to store large collections of data. Even
> then, these hundreds of C++ classes do not supply everything that
> every programmer will ever need. Th ere are many times when
> programmers discover they need their own types to model things in
> their applications. Consider the following system from the domain of
> banking:
>
> 105
>
> Th e Bank Teller Specifi cation
>
> Implement a bank teller application to allow bank customers to access
> bank accounts through unique identifi cation. A customer, with the
> help of the teller, may complete any of the following transactions:
> withdraw money, deposit money, query account balances, and see the ten
> most recent transactions. Th e system must maintain the correct
> balances for all accounts. Th e system must be able to process one or
> more transactions for any number of customers.
>
> You are not asked to implement this system now. However, you should be
> able to pick out some types that are relevant to this system. One
> simple tool for fi nding the types of objects that model a solution is
> to write down the nouns in the problem statement. Th en consider each
> as a candidate type that might eventually represent part of the
> system. Th e types used to build the system come from sources such as

-   the problem specifi cation

-   an understanding of the problem domain

-   the types that come with the programming language

Th e types should model the real world if possible. Here are some
candidates:

  > **Candidate Objects to Model a Solution **   
  ---------------------------------------------- -----------------------------
  bank teller                                    transaction
  customers                                      10 most recent transactions
  bank account                                   balance

> Here is a picture to give an impression of the major types in the bank
> teller system. Th e BankTeller will accomplish this by getting help
> from many other objects.

5.1: Modeling the Real World

> Th is problem specifi cation shows that programs usually consist of
> many diff erent types. Instead of implementing the entire system and
> adding a user interface, only one type of object will be used here as
> an example — BankAccount.

5.1.1 BankAccount OBJECTS

> Implementing a BankAccount type as a C++ class (in the chapter that
> follows) provides the ability to have many BankAccount objects. Each
> instance of BankAccount represents an account at a bank. Using your
> knowledge of the concept of a bank account, you might recognize that
> each BankAccount object should have its own account number and its own
> account balance. Other values could be part of every BankAccount
> object: a transaction list, a personal identifi cation number (PIN),
> and a mother’s maiden name, for example. You might visualize other
> banking operations, such as creating a new account, making deposits,
> making withdrawals, and accessing the current balance. Th ere could
> also be many other banking messages—generateMonthlyStatementAsPDF, for
> example.

As a preview to a class as a collection of operations and values, here
is a defi nition for the

> BankAccount type in the fi le BankAccount.h (h stands for header). Th
> e details for implementing new types as C++ classes will be presented
> in the next chapter.
>
> \#include <string>
>
> class BankAccount { public: BankAccount(std::string initName, double
> initBalance); // post: Construct call with two arguments:
>
> // BankAccount anAcct("Hall", 100.00);
>
> void deposit(double depositAmount); // post: Credit depositAmount to
> the balance
>
> void withdraw(double withdrawalAmount); // post: Debit
> withdrawalAmount from the balance
>
> double getBalance() const; // post: Return this account's current
> balance
>
> std::string getName() const; // post: Return this account's name
>
> private:
>
> std::string name; double balance; };
>
> Consider this class BankAccount defi nition as a blueprint used by C++
> to construct many BankAccount objects. Each BankAccount object will
> have its own data member's name and currentBalance. Each BankAccount
> object will understand the same fi ve member functions: BankAccount,
> deposit, withdraw, getName, and getBalance. While the defi nition is
> in a fi le named BankAccount.h, the actual implementation of this C++
> class will be in another fi le named

BankAccount.cpp.

> It should be noted here that the C++ community uses the term *data
> member* for a function that is part of a class. Th ey also use the
> term *data member* for the variables that store the state of the
> objects. Other object-oriented programming languages use the term
> *method* rather than *member function* and the term *instance
> variable* rather than *data member*. Th is textbook will use the C++
> terms.

BankAccount objects are constructed with two arguments to initialize the
object’s state:

-   A string to represent the account identifi er, a name for example

-   A fl oating-point number to represent the initial account balance

> **General Form 5.1** *Constructing objects (initial values are
> optional)*

*class-name object-name*(*initial-value(s)*);

Example object constructions:

> BankAccount anAccount("Chris", 125.50); string str("A string") string
> str2() // default value is an empty string ""

Every object has

-   a name: a variable that references the entire object

-   state: the values that the object currently has

-   messages: the operations each object can do

> Every object will have a variable to provide access to the state of
> that object. Every object has its own unique state. Every object will
> understand the same set of messages. For example, given this object
> construction,

BankAccount anotherAccount("Dakota", 60.00); we can derive the following
information:

-   a name to access the object: anotherAccount

-   state: an account name of “Dakota” and a balance of 60.00

-   messages: understands messages like withdraw, deposit, getBalance

> Other instances of BankAccount will understand the same set of
> messages. However, they will have their own separate state. For
> example, after another BankAccount construction,

BankAccount newAccount("Kim", 1000.00); newAccount has its own name
“Kim” and its own balance of 1000.00.

5.2: Sending Messages

5.1.2 CLASS AND OBJECT DIAGRAMS

> Th e three characteristics of objects can be summarized with a class
> diagram:

  BankAccount
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  string name double balance
  BankAccount(string initName, double initBalance) void deposit(double depositAmount) void withdraw(double withdrawalAmount) double getBalance() const string getName() const

> A class diagram lists the class name in the topmost compartment. Th e
> instance variables appear in the compartment below it. Th e bottom
> compartment captures the methods. Objects can also be viewed as
> instance diagrams where the name of the object is underlined and
> values are shown:

  ----------------------------------------------------------------------------------------------------
  *anAccount*                       *anotherAccount*                  *newAccount*
                                                                      
  name = "Chris" balance = 125.50   name = "Dakota" balance = 60.00   name = "Kim" balance = 1000.00
  --------------------------------- --------------------------------- --------------------------------
  ----------------------------------------------------------------------------------------------------

> Th ese three object diagrams describe the current state of three diff
> erent BankAccount objects. One class can be used to construct many
> objects, each with its own separate state (set of values).

5.2 SENDING MESSAGES

> Objects such as cin, cout and any string object have class member
> functions. Using them is a bit diff erent from using the free
> functions such as those declared in cmath. A diff erent syntax is
> required. Th is diff erent type of function call is even distinguished
> with a diff erent name— *message*—when using a member function. Some
> messages return the object’s state. Other messages tell an object to
> do something.

-   A message that asks the object to return its state:
    > anAccount.getBalance();

-   A message that tells the object to do something:
    > anAccount.withdraw(25.00);

> Th e state of objects is made accessible through certain operations
> such as getName and getBalance. Other class member functions exist so
> programmers can modify the state of the object: withdraw and deposit,
> for example. Here is the general form used to send messages to
> objects:

**General Form 5.2** *Sending a message to an object*

*object-name.function-name*(*argument-list*) Example BankAccount
messages:

> anAccount.deposit(237.42); anAccount.withdraw(5);
> anAccount.getBalance();

Th e following are incorrect:

  anAccount.deposit();        // Missing the amount to deposit
  --------------------------- ---------------------------------------------
  deposit();                  // missing the object-name and .
  anAccount.getBalance;       // missing ()
  anAccount.withdraw("10");   > // wrong class of argument
  anAccount;                  > // missing member function name
  anAccount.withdrawal(10);   > // BankAccount has no function withdrawal

> Fortunately, failure to supply the object name, the dot, and the
> operation name in the proper order usually generates an error message
> at compile time. Also, as with any function, the compiler complains if
> the client code does not supply the proper arguments between
> parentheses. Th e BankAccount class (and therefore all BankAccount
> objects) has two member functions to access the state of the object:
> getName and getBalance. Th e BankAccount class has two member
> functions that modify the state—withdraw and deposit. Th ese
> operations are exemplifi ed in the following program that constructs
> two BankAccount objects and sends messages to both of those objects.
> Th ose messages result in the following actions:

-   deposit 133.33 to the object named ba1

-   withdraw 250.00 from the object named ba2

-   display the names and modifi ed balances of both objects

> // Initialize two BankAccount objects and send some messages
>
> \#include <iostream> // for cout using namespace std; \#include
> "BankAccount.h" // for class BankAccount
>
> int main() {
>
> BankAccount ba1("Miller", 100.00); BankAccount ba2("Barber", 987.65);
>
> ba1.deposit(133.33); ba2.withdraw(250.00);
>
> cout << ba1.getName() << ": " << ba1.getBalance()
> << endl; cout << ba2.getName() << ": " <<
> ba2.getBalance() << endl;
>
> return 0;
>
> }

5.2: Sending Messages

> Output
>
> Miller: 233.33
>
> Barber: 737.65
>
> Objects store varying amounts of data depending on the class to which
> they belong. Th e state of an object may require many values—and these
> values also may be of diff erent classes. For example, a BankAccount
> object stores a string object to represent the account name, and at
> the same time stores a number to represent the balance. A
> weeklyEmployee object might store several strings such as name,
> address, social security number, and several numbers such as pay rate
> and hours worked. A robot object may store a current position, a map,
> and the state of its arm mechanism.

SELF-CHECK

5-1 Each of the lettered lines has an error. Explain why.

> \#include <iostream> // For cout
>
> \#include "BankAccount.h" // For class BankAccount using namespace
> std;
>
> int main() {

BankAccount b1("Sam"); // -a

> BankAccount b2(500.00); // -b BankAccount b3("Jo", 200.00); // -c
> b1.deposit(); // -d b1.deposit; // -e b1.deposit("100.00"); // -f
> B1.deposit(100.00); // -g b1.Deposit(100.00); // -h withdraw(100); //
> -i cout << b4.getName() << endl; // -j cout <<
> b1.getName << endl; // -k cout << b1.getName(100.00)
> << endl; // -l return 0; }

5-2 Write the output generated by the following program:

> \#include <iostream> // For cout using namespace std;
>
> \#include "BankAccount.h" // For the BankAccount class int main() {
>
> BankAccount b1("Chris", 0.00); BankAccount b2("Kim", 500.00);
> b1.deposit(222.22); b1.withdraw(20.00); b2.deposit(55.55);
> b2.withdraw(10.00);
>
> cout << b1.getName() << ": " << b1.getBalance()
> << endl; cout << b2.getName() << ": " <<
> b2.getBalance() << endl; return 0; }

5.3 string OBJECTS

> Like bankAcount, the string type is implemented as a C++ class.
> Although each string object stores a collection of characters, a
> programmer may sometimes be interested in one single character. At
> other times the programmer may require several characters or the
> current length of a string (number of characters stored). It is
> sometimes necessary to discover if a certain substring exists in a
> string. For example, is the substring ", " included in the string
> "Last, First" and if so, at what index does ", " begin? Th e C++
> string type provides a large number of member functions to help with
> problems requiring knowledge of string values. You will use string
> objects in many programs.
>
> Each string object stores a collection of zero or more characters.
> string objects can be constructed in two ways.
>
> **General Form 5.3** *Constructing string objects in two diff erent
> ways*
>
> string *identi er*(*string-literal*); string *identi er* =
> *string-literal*;
>
> Examples
>
> string stringReference("A String Object"); string
> anotherStringReference = "Another";
>
> As with most classes, string has member functions that modify the
> state of string objects— insert, replace, erase—and member functions
> that return something about the state—length, nd, and substr. Th e
> string class has operations that allow access to the elements, or
> individual characters at, \[\], front, and back. Th ere are also a
> number of operators that can be applied to string objects such as +,
> \[\], <<, and >>.

5.3.1 ACCESSING METHODS

**string::length()**

> A length message sent to a string object returns the number of
> characters currently in the string.
>
> string stringReference("A String Object"); string
> anotherStringReference = "Another"; stringReference.length(); //
> returns 15 anotherStringReference.length(); // returns 7

5.3: string Objects

**string::at**

> An at message returns the character located at the index passed as an
> int argument. Notice that string objects have zero-based indexing. Th
> e fi rst character is located at index 0, and the second character is
> located at index 1, or as the message at(1).
>
> string str("A string object"); str.at(0); // returns 'A' str.at(1); //
> returns ' ' str.at(2); // returns 's'

str.at(str.length()-1); // returns 't', the last character **string::nd
and string::rnd**

> A nd message returns the index of the fi rst character where the
> entire string argument is found. If the string argument does not
> exist, nd returns string::npos (no position), which is a very large
> integer that may be diff erent from the integer shown below. r nd
> returns the starting index of the *last* occurrence of the string
> argument.

string str("there is the other the"); str. nd("the"); // returns 0, the
rst "the" cout << str.r nd("the"); // returns 19, the last "the"
cout << str. nd(" is "); // returns 5 cout << str. nd("not
here"); // returns string::npos which // may be 18446744073709551615
**string::substr**

> A substr message returns the part of a string starting at the index
> specifi ed as the fi rst argument. Th e second argument represents the
> total number of characters to the end of the string.

string str("Smiles a Lot"); str.substr(1, 4); // returns "mile"
str.substr(9, 1); // returns "L" str.substr(9, 2); // returns "Lo"
str.substr(9, 55); // returns "Lot" **str::front and str::back **

> Th e front and back member functions provide access to the fi rst and
> last characters in the string object.
>
> string str("abc");
>
> // front and back are part of C++11. With some C++ compilers,
>
> // this code may generate compile time errors because their
>
> // string class may does not yet have these member functions.
>
> str.front(); // returns 'a' str.back(); // returns 'c'

5.3.2 MODIFYING METHODS

**str::insert**

> An insert message adds additional characters into the string object
> right before the character indexed by the fi rst argument. Th e second
> argument can be a string literal or another string object.
>
> string quick("quick"); string all("the brown jumped dog");

all.insert(4, quick); // all.length() increased all.insert(23, "over the
lazy"); cout << all; // prints: the quick brown jumped over the
lazy dog **str::replace**

> Th e replace member function changes the portion of the string that
> begins at the index of the fi rst argument and spans the number of
> characters specifi ed as the second argument.

string quick("quick"); string all("the brown jumped dog");
all.replace(4, 14, quick); cout << all; // prints: the quick dog
**str::erase**

> An erase message erases the part of the string indicated by the
> indexes specifi ed in the arguments.
>
> string all("the quick brown fox"); all.erase(4, 12);
>
> cout << all << endl; // prints: the fox cout <<
> all.length(); // prints 7

5.3.3 OPERATORS DEFINED FOR string OBJECTS

+ OPERATOR

> Programmers often make one string object from two separate strings
> with the + operator that concatenates (connects) two or more strings
> into one string.
>
> string rstName("Kim"); string lastName("Potter");

string fullName = lastName + ", " + rstName; cout << fullName; //
prints Potter, Kim Characters can also be concatenated with strings.

5.3: string Objects

> fullName = '>' + fullName + '<'; cout << fullName; //
> prints >Potter, Kim<

<< AND >> OPERATORS

> Th e << and >> operators are overloaded for the string
> class to allow input and output of strings, just like numbers.
>
> string rstName; cout << "Enter rst name: "; cin >>
> rstName; // If the user enters Kim cout << "Hello " + rstName;
> // output would be: Hello Kim

\[\] OPERATOR

> Th e \[\] is like the at member function. Using square brackets,
> individual characters can be accessed or changed.
>
> string str("abcde");
>
> str\[0\]; // returns 'a' str\[1\]; // returns 'b' str\[4\]; // returns
> 'e'
>
> str\[2\] = 'X'; str\[3\] = 'O'; cout << str; // prints abXOe
>
> Other operators for comparing strings, such as <= and ==, will be
> presented in a later chapter.

SELF-CHECK

> 5-3 What is the output from the following program?
>
> \#include <iostream>
>
> \#include <string>
>
> using namespace std; // Allows string instead of std::string
>
> int main() {
>
> string str("Social Network"); cout << str.length() <<
> endl; cout << str.at(0) << endl; cout <<
> str.at(str.length() - 1) << endl; cout << str. nd("Net")
> << endl; cout << str. nd("net") << endl; cout
> << str.substr(7, 3) << endl; cout << str.substr(7,
> 1) << endl; cout << str.substr(7, 99) << endl; cout
> << str\[1\] << endl return 0;
>
> }
>
> 5-4 What is the modifi ed value of each string object?

  a.   string str1("Social"); str1.replace(0, 1, "UnS");                 > c.   > string str2("Social"); str2.erase(3, 2);
  ---- ----------------------------------------------------------------- ------ ----------------------------------------------------------
  b.   string str3("Social"); str3.insert(3, "iet"); str3.erase(6, 1);   > d.   string str4("Social"); str4\[0\] = 'N'; str4\[5\] = 'X';

> str4\[2\] = 'T';
>
> 5-5 Write the code to store the middle character of a string object
> into a char variable named mid. If there is an even number of
> characters, store the char to the right of the middle. For example,
> the middle character of “abcd” is ‘c’.
>
> 5-6 For each of the following messages, if there is something wrong,
> write “error”; otherwise, write the value of the expression.

string str("Any String");

  a\. length(str)   d\. str. nd(" ")
  ----------------- -----------------------
  b\. str.length    e\. str.substr(2, 5)
  c\. str(length)   f\. str.substr("tri")

5.4 ostream AND istream MEMBER FUNCTIONS

> Th e istream and ostream classes provide input and output.

**ostream::width**

> Th e member function width modifi es the state of the ostream object
> named cout.
>
> \#include <iostream> using namespace std; int main() { cout
> << 1; cout.width(5); cout << 2; cout << 3; return 0;
> }
>
> Output
>
> 1 23

5.4: ostream and istream Member Functions

> Normally, the state of cout is set to display the next output in the
> minimum number of columns—with no leading spaces—which is the default
> state of cout. Th e cout.width(5) message temporarily alters the state
> of cout such that the very next output will be output in a minimum of
> fi ve columns. After that, the default situation is back in force so
> the 2 is printed in one column, immediately following the 3.

**ostream::precision**

> To gain control over the appearance of fl oating-point output, use the
> ostream member function precision. A precision message tells the
> ostream object cout to show a specifi c number of digits in fl
> oating-point numbers. Unlike width, the precision remains the same
> until another precision message is sent to cout.
>
> // Send two precision messages to the ostream object named cout
>
> \#include <iostream> using namespace std;
>
> int main() { double x = 1.23456;
>
> cout << x << endl; // Default (1.23456) cout.precision(1);
> // Modify the state of cout cout << x << endl; // Show
> only one signi cant digit (1) cout.precision(4); // Modify the state
> of cout cout << x << endl; // Show four digits rounded
> (1.235) cout << x << endl; // Precision of 4 still in
> effect
>
> return 0; }
>
> Output
>
> 1.23456 1
>
> 1.235
>
> 1.235

**istream::good**

> Th e member function good of the istream class returns the state of an
> input object (usually cin). Normally, cin.good() returns 1, which
> means “true” if cin is still capable of reading. However, if someone
> enters an improper value, such as input of BAD instead of a number as
> shown below, the good message returns 0, which means “false.”

cout << cin.good(); // Returns 1 for good, 0 for bad

> Whenever cin.good() is false, no more input is allowed from cin unless
> other steps are taken. So if you enter an invalid number—an easy input
> mistake to make—strange things may occur.
>
> // Demonstrate what happens with bad input
>
> \#include <iostream> // For the cout and cin objects using
> namespace std;
>
> int main() { int x = 0.0;
>
> cout << "Is cin good? " << cin.good() << endl; cout
> << "Enter an int: "; cin >> x;
>
> cout << "Is cin still good? " << cin.good() << endl;
>
> return 0; }

  -------------------------------------------------------------------
  **Dialogue: 1 means true **   > **A 2nd Dialogue: 0 means false**
  ----------------------------- -------------------------------------
  > Is cin good? 1              Is cin good? 1
  >                             
  > Enter an int: 123           Enter an int: NotAnInt
  >                             
  > Is cin still good? 1        Is cin still good? 0
  -------------------------------------------------------------------

5.4.1 CLASS MEMBER FUNCTION HEADINGS

> When a function is a member of a class, the function heading is
> qualifi ed with the class name followed by the scope resolution
> operator ::. Using :: will be necessary to successfully build a C++
> class in the next chapter. It also helps the reader determine when the
> dot notation is required to send a message. Any function heading of
> the following form identifi es the function as a class member
> function:
>
> **General Form 5.4** *Class member function headings*

*class-name* :: *function-name*(*parameters*)

> So for example, int string::length() indicates that length is a member
> of the string class. It is diff erent from the nonmember functions
> sqrt and pow. Here is the list of some of class member function
> headings that have been revealed so far (many more exist):

EXAMPLES OF CLASS MEMBER FUNCTION HEADINGS

  > **Class **   **Member function heading**
  -------------- ---------------------------------------------------
  > string       int string::length() const;
                 // Return the number of characters in this string

5.4: ostream and istream Member Functions

> int string:: nd(string subString); // Return position of rst substring

string string::substr(int pos, int n) const;

> // Return the n characters to the right of // string\[pos\] or up to
> this string's length
>
> string insert (int pos, const string& str);
>
> // Inserts additional characters into the string right // before the
> character indicated by pos.

  ostream   int ostream::width(int nCols);
  --------- -------------------------------------------------------
            // Next output to this ostream object will be
            // displayed in nCols. Returns the current value
            // of the date member width.
            int ostream::precision(int nDigits);
            // Show oating-point output with nDigits of digits.
            // Also returns the current precision.
  istream   int istream::good();
            // post: Return 1 if istream can read or 0 if corrupt

> BankAccount BankAccount::BankAccount(string aName, double
> initBalance); // post: Construct a BankAccount with two arguments

void BankAccount::deposit(double amount);

// pre: amount >= 0

// post: amount is credited to this object's balance

> void BankAccount::withdraw(double amount); // pre: amount >= 0 and
> <= this object's balance // post: amount is debited from this
> object's balance
>
> double BankAccount::getBalance() const; // post: Return this object's
> current balance

string BankAccount::getName() const;

// post: Return this object's name

> Th e class name and :: should help you determine whether you must call
> a non-member (free) function without the function name fi rst or send
> a message with the object name followed by a dot.

  **Free Function Heading **                  **Function Call**
  ------------------------------------------- ------------------------------------
  > double pow(double base, double power)     > double answer = 0.0;
  > // post: Return base to the power power   > double x = 1.023102;
                                              > answer = pow(x, 360.0);
  **Member Function Heading **                **Message**
  > string string::substr(int pos, int n)     > string name("Doe, Jo");
  > // post: Return n characters of this      > int n = name. nd(",");
  > // string beginning at index pos          > string last = name.substr(0, n);

> Additionally, to document a function name as a class member function
> requiring the dot notation, you will often see member functions
> referred to without the parameter list and return type such as
> string::length. Th is is true in the context of this textbook and with
> most online and book documentation.

SELF-CHECK

> 5-7 Write the output generated by the following program. Make sure you
> line up all output in the correct column.
>
> \#include <iostream> using namespace std; int main() {
>
> cout << "123456789012345" << endl; cout.width(3); cout
> << 1; cout.width(5); cout << 2.3; cout.width(6); cout
> << "who" << endl; return 0; }
>
> 5-8 Write the exact output generated by the following program:
>
> \#include <iostream> using namespace std; int main() {
> cout.precision(3); cout << 9.876543 << endl;
> cout.precision(1); cout << 1.2 << endl; cout.precision(8);
> cout << 1.2 << endl; return 0; }
>
> 5-9 Write the complete dialogue generated by the following program
> when:

a.  the user enters ***123***

b.  the user enters ***XYZ***

> \#include <iostream> using namespace std; int main() { int
> anInt(0);
>
> cout << "Enter an integer: "; cin >> anInt;
>
> cout << "Good? " << cin.good() << endl; return 0; }
>
> 5-10 What class does each member function belong to?

  a\. istream::clear   d\. string::replace
  -------------------- ---------------------------
  b\. Grid::move       e\. BankAccount::withdraw
  c\. ostream::width   f\. istream::good

5.5 ANOTHER NONSTANDARD CLASS: Grid

> Th is section presents another nonstandard class that will be used
> occasionally over the next several chapters to help you think in terms
> of objects while providing opportunities to improve problemsolving
> skills.
>
> Th is section presents a Grid type implemented as a C++ class. Before
> you study this section, please realize that the Grid class is meant to
> be used for teaching and learning purposes only. It will be used
> occasionally in later chapters to demonstrate new concepts in a visual
> manner. However, Grid objects are not meant to predominate any of
> those new concepts. Th e graphical state of Grid is meant to help you
> more readily grasp the access and modifi cation of object state
> through messages. You will be able to complete a few programming
> projects comprised only of messages to this object.
>
> Th e Grid class presented here is based on the work of Rich Pattis’
> *Karel the Robot: A Gentle Introduction to the Art of Programming* and
> a game seen at Disney World’s Epcot Center. Th e game asked the
> question, “Could you be a programmer?” Th e player was invited to
> guide a pirate ship to a treasure while avoiding obstacles.
>
> A Grid object stores a little rectangular map of rows and columns with
> an object to move. A Grid object is initialized with fi ve arguments:
>
> Grid *Grid-name* (*rows*, *cols*, *mover-row*, *mover-col*,
> *direction*); where the fi rst two arguments represent the size of the
> Grid in rows and columns, the next two arguments are the mover’s
> starting row and column, and the last argument is the mover’s starting
> direction. Th e direction must be listed either as north, south, east,
> or west. Th e following program provides an example initialization
> with an output message
>
> (Grid::display) that allows the programmer to inspect the state of the
> Grid. To maintain consistency with C++, which begins counting at 0,
> the fi rst row is referenced as the 0 row. Th e fi rst column is also
> referenced as the 0 column and the intersection of the fi rst row, fi
> rst column location is referenced as 0, 0.
>
> // Initialize and display a Grid object
>
> \#include "Grid.h" // For the Grid class
>
> int main() {
>
> // Arguments used to initialize a Grid object go like this:
>
> // \#rows, \#columns, StartRow, StartColumn, StartDirection
>
> Grid aGrid(8, 16, 4, 8, east); // 4 is the fth and // 8 is the ninth
> column aGrid.display(); return 0; }
>
> Output
>
> The Grid:
>
> . . . . . . . . . . . . . . . .
>
> . . . . . . . . . . . . . . . .
>
> . . . . . . . . . . . . . . . .
>
> . . . . . . . . . . . . . . . .
>
> . . . . . . . . > . . . . . . .
>
> . . . . . . . . . . . . . . . .
>
> . . . . . . . . . . . . . . . .
>
> . . . . . . . . . . . . . . . .

A Grid object’s state is accessed with class member functions such as
these:

-   int Grid::row() const

-   int Grid::nRows() const

-   int Grid::nColumns() const

-   void Grid::display() const

-   bool Grid::frontIsClear() const

> Although you may not see the need for these operations at this point,
> they will come in handy if you do any problem solving associated with
> Grid objects.
>
> // Access the state of a Grid object with messages
>
> \#include <iostream> // For the cout object using namespace std;
> \#include "Grid.h" // For class Grid
>
> int main() {
>
> Grid aGrid(7, 14, 5, 8, east); // Column 8 is the ninth column cout
> << "Current row : " << aGrid.row() << endl; cout
> << "Current column : " << aGrid.column() << endl;
> cout << "Number of rows : " << aGrid.nRows() <<
> endl; cout << "Number of columns: " << aGrid.nColumns()
> << endl; cout << "Front is clear? : " <<
> aGrid.frontIsClear() << endl; return 0; }
>
> Output
>
> Current row : 5
>
> Current column : 8
>
> Number of rows : 7
>
> Number of columns: 14
>
> Front is clear? : 1
>
> Th e state of any Grid object is modifi ed with the messages
> Grid::move(), Grid::turnLeft(), and Grid::turnRight().
>
> \#include "Grid.h" // For the Grid class
>
> int main() { Grid aGrid(7, 9, 1, 3, east);
>
> aGrid.move(); aGrid.move(); aGrid.turnRight(); aGrid.move();
> aGrid.move(); aGrid.turnRight(); aGrid.move(); aGrid.move();
> aGrid.turnLeft(); aGrid.move(); aGrid.move(); aGrid.display(); return
> 0; }
>
> Output
>
> The Grid:
>
> . . . . . . . . .
>
> . . . . . .
>
> . . . . . . . .
>
> . . . . . .
>
> . . . . . . . .
>
> . . . v . . . . .
>
> . . . . . . . . .

SELF-CHECK

> 5-11 Write the output of the following program:
>
> \#include <iostream> // For cout using namespace std; \#include
> "Grid.h" // For the Grid class
>
> int main() {
>
> Grid aGrid(6, 6, 4, 2, east); aGrid.move(2); aGrid.turnLeft();
> aGrid.move(3); aGrid.turnLeft(); aGrid.move(2); aGrid.display();
>
> cout << "row: " << aGrid.row() << endl; cout
> << "col: " << aGrid.column() << endl; return 0; }

5.5.1 OTHER Grid OPERATIONS

> Th ere are several other Grid operations, some of which will be needed
> in this chapter’s programming projects. Completing those projects
> provides practice at sending messages to objects—calling member
> functions—and developing algorithms resulting in a more graphical
> result. Th e following class diagram lists all Grid member functions.
> It is not necessary to know the data members to use objects, so the
> state is omitted here.

Grid MEMBER FUNCTIONS

> // -- Modi ers void move(); void move(int spaces); void turnLeft();
> void turnRight(); void putDown();
>
> void putDown(int putDownRow, int putDownCol); void toggleShowPath();
> void pickUp(); void block(int blockRow, int blockCol);
>
> // -- Accessors bool frontIsClear() const; bool rightIsClear() const;
> int row() const; int column() const; int nRows() const; int nColumns()
> const; void display() const;
>
> Although this class diagram provides a summary of legal messages, it
> does not explain the number and class of arguments to use when sending
> messages to a Grid object. For that, the following subset of the
> member function headings is provided (all the ones you need to do the
> programming projects in this chapter) with pre- and postconditions.

SUBSET OF Grid MEMBER FUNCTIONS

> Th ese help us understand what each function does. A precondition
> tells us what must be true before a message is sent. A postcondition
> tells us what will happen if the precondition is met.
>
> Grid::Grid(int Rows, int Cols, int startRow, int startCol, int
> direction)
>
> // post: Construct a 10-by-10 Grid object with 5 arguments
>
> // Grid aGrid(10, 10, 0, 0, east);
>
> void Grid::move()
>
> // pre: The mover has no obstructions in the next space
>
> // post: The mover is 1 space forward
>
> void Grid::move(int spaces)
>
> // pre: The mover has no obstructions in the next spaces
>
> // post: The mover is spaces forward
>
> void Grid::putDown(int putDownRow, int putDownCol)
>
> // pre: The intersection (putDownRow, putDownCol) has nothing at
>
> // it except, perhaps, the mover
>
> // post: There is one thing at the intersection
>
> void Grid::pickUp()
>
> // pre: There is something to pick up at the mover's location
>
> // post: There is nothing to pick up from the current intersection
>
> void Grid::turnLeft() // post: The mover is facing 90 degrees
> counterclockwise
>
> void Grid::block(int blockRow, int blockCol)
>
> // pre: There is nothing at the intersection (blockRow, blockCol)
>
> // post: The intersection can no longer be visited
>
> void Grid::display() const // post: The current state of the Grid is
> displayed on the screen
>
> For example, think about a program that blocks three intersections
> (represented by \#), instructs a kid to eat two cookies, and moves the
> kid back to the starting point. A few messages to Grid::putDown will
> place a few “cookies” (or whatever you would like the capital letter
> “O” to represent) on the Grid. Th en the challenge is sending the
> proper messages to move the kid to eat the cookies using the Grid
> member functions such as Grid::move. If the kid is facing south you
> will see a v, if the kid is facing north you will see \^, if the kid
> is facing east you will see > and facing west <. To "eat" the
> cookies send messages to Grid::pickUp. Here is the program:
>
> // This program sets two cookies on the table and instructs a kid
>
> // on how to locate them, "eat" them, and return home
>
> \#include "Grid.h" // For the Grid class
>
> int main() {
>
> Grid kid(8, 12, 0, 0, south); kid.putDown(4, 0); kid.putDown(4, 3);
>
> kid.block(3, 2); // Can't move through a block \# kid.block(4, 2);
> kid.block(5, 2);
>
> // Show the state of kid kid.display();
>
> // "Eat" two cookies kid.move(4); kid.pickUp(); kid.move(2);
> kid.turnLeft(); kid.move(3); kid.turnLeft(); kid.move(2);
> kid.pickUp();
>
> // Get the kid back home kid.move(4); kid.turnLeft(); kid.move(3);
>
> // Show the ending state kid.display(); return 0; }
>
> Output
>
> The Grid v . . . . . . . . . . . . . . . . . . . . . . .
>
> . . . . . . . . . . . .
>
> . . \# . . . . . . . . .
>
> O . \# O . . . . . . . .
>
> . . \# . . . . . . . . .
>
> . . . . . . . . . . . .
>
> . . . . . . . . . . . .
>
> The Grid < . . . . . . . .
>
> . . . . . . . . . .
>
> . . . . . . . . . .
>
> . \# . . . . . . . .
>
> . \# . . . . . . . .
>
> . \# . . . . . . . .
>
> . . . . . . . .
>
> . . . . . . . . . . . .

5.5.2 FAILURE TO MEET THE PRECONDITIONS

> Th ere are many “illegal” messages you can send to a Grid object. For
> example, you could try sending a move message that asks the mover to
> move through a block (\#) or off the edge of the Grid. All it takes is
> one incorrect message—moving four rows instead of three, for example.

SELF-CHECK

> 5-12 If you were designing the operations for a Grid object, what
> would you want to prevent from occurring?
>
> So what should a Grid object do when sent a message that makes no
> sense? Quite frankly, it’s a bit awkward. Th e object could respond by
> doing nothing. In this case, the state of the object would remain
> unaltered. Or the object could travel off the end of the Grid or move
> through blocks—but this sounds more like a Superman object. Here’s yet
> another snippy answer: the behavior is *undefi ned*.
>
> Th is awkwardness is circumvented by the notion of preconditions. A
> function’s *precondition* is what the function presumes to be true
> when a function is called or the message is sent. For example, the
> void move(int spaces) operation has the precondition that there is no
> block or Grid edge in the path of the mover. Also, the Grid::pickUp()
> message presumes there is something to pick up.
>
> void Grid::move(int spaces)
>
> // pre: The mover has no obstructions in the next spaces
>
> // post: The mover is spaces forward
>
> void Grid::pickUp()
>
> // pre: There is something to pick up at the mover's location
>
> // post: There is nothing to pick up from the current intersection
>
> So what does happen when you violate one of these preconditions?
> You’ll likely fi nd out if you work on certain Grid-related
> programming projects.

5.5.3 FUNCTIONS WITH NO ARGUMENTS STILL NEED ( )

> You have now seen several messages that require no arguments. If a
> function has no parameters, it requires no arguments. Here are two
> examples:
>
> cout << aString.length() << endl; cout <<
> aGrid.row() << endl;
>
> It should be noted, before you do any of this chapter’s programming
> projects, that even though no values need to be passed as arguments to
> either string::length or Grid::row, the parentheses must still be
> included in the message. Th e following code will not do what you
> might expect:
>
> cout << aString.length << endl; // ERROR: Missing () after
> length cout << aGrid.row << endl; // ERROR: Missing ()
> after row
>
> Th e parentheses represent the function call operator. Without ( and
> ), there is no function call— even when zero arguments are needed by
> the function.

**5.6 WHY FUNCTIONS AND CLASSES?**

> *Abstraction* is the process of pulling out and highlighting the
> relevant features of a complex system. One aspect of abstraction is
> understanding the computer from the programming-language level without
> full knowledge of the details at the lower levels. Abstraction is our
> weapon against complexity.
>
> You can use operations such as sqrt, pow, Grid::move, and any other
> new function without knowing the implementation details coded by other
> programmers. Abstraction allows programmers to quickly and easily use
> int, double, string, BankAccount, and Grid objects. Th e
> characteristics of int data (a specifi c range of integer values) and
> int operations (such as addition, multiplication, assignment, input,
> and output) can be understood without knowing the details of those
> operations, or even how those values are stored, or how these
> operations are implemented in the hardware and software. Abstraction
> is friendly. Abstraction makes life easier. Abstraction helps keep us
> sane. Abstraction is that little “black box” programmers are always
> talking about. When you can’t see how a function is implemented, a
> programmer calls that a “black box.” Th at is abstraction.
>
> Even though C++ is delivered with a large set of abstractions known as
> functions and classes, additional functions and classes will still be
> required. New abstractions are built from existing objects,
> operations, and algorithms. As you begin to create function and class
> abstractions, set a goal to build these abstractions so they are easy
> to use and perform a well-defi ned operation. When the details of
> implementation are long forgotten, you will still be able to use the
> abstraction because you know *what* it does. You won’t have to
> remember *how* it does it.
>
> Instead of encapsulating a group of related code statements in a
> function, you could write all code statements directly in the main
> function. Th ose statements would then replace the function call.
> However, as the table below shows, that detailed way is quite
> extensive in the number of lines required.

  > **Th e Actions Represented by One Message**       
  --------------------------------------------------- -----------------------
  **Operation Th e Object-Oriented Way **             **Th e Detailed Way**
  Construct one Grid object Grid g(15,15,9,4,east);   35 lines
  Move in current direction g.move(2);                112 lines
  Output the Grid g.display();                        6 lines
  Change direction g.turnLeft();                      10 lines

5.6: Why Functions and Classes?

> Th e four messages in the middle column represent the abstract
> equivalent of coding the 163 lines the non-function way, as listed in
> the right column. Now imagine a six-message program that moves and
> turns three times. Th e equivalent non-function way would require
> approximately 366 detailed lines of code rather than the six messages!
>
> By placing the many lines of detailed code into functions, the
> programmer may execute that operation with just one message or
> function call. Th e same message may be sent over and over again. So
> whenever you have code that can be used more than once in a program,
> it is preferable to implement that behavior within the confi nes of a
> free (nonmember) function or as one of many member functions available
> to the objects. Function calls and messages represent many hidden
> instructions and details. Th e programmer need not see, nor
> understand, all implementation details. Encapsulating code in
> functions also helps avoid code duplication, a sign of poorlywritten
> programs. *Abstraction*, *encapsulation*, and *black box* are all
> terms used for hiding information.

SELF-CHECK

> 5-13 Using the previous table, how many lines of code are required to
> initialize the state of one Grid object using the object-oriented way?
>
> 5-14 Using the previous table, how many lines of code are required to
> initialize the state of one Grid object when the detailed way is used
> (right column)?
>
> 5-15 Write a paper and pencil program that constructs a Grid object
> and moves it one space in all four directions: north east south west.
>
> By partitioning low-level details into one function, the
> implementation need only be written once. Another advantage of
> functions is that the same operation can be used over and over again
> with a one-line message. Rather than one huge int main() { }, programs
> are composed of more manageable calls to nonmember (free) functions
> (sqrt and pow) and messages to class member functions (string::substr
> and Grid::move). Here are some reasons why C++ programmers use
> existing functions and objects to better manage the complexity of
> software development:

-   to reuse existing code rather than write it from scratch

-   to concentrate on the bigger issues at hand

-   to reduce errors by writing the function only once and testing it
    > thoroughly

> In the early days of programming, programs were written as one big
> main program. As programs became bigger, *structured programming*
> techniques became popular. One major feature of structured programming
> was to partition programs into functions for more manageable code.
> Programmers found this helped people understand the program better. It
> is easier to maintain programs that place related processing details
> in an independent function. It is easier to fi x a 20-line function in
> a program with 100 functions than it is to fi x a 2,000-line program.
> Other reasons for dividing a program into smaller functions include:

-   placing details into a function or class makes the code easier to
    > comprehend

-   the same actions need to be achieved more than once in a program

-   the function or class can be reused in other applications

> With free functions, the data are passed around from one nonmember
> function to another. When the data are available everywhere throughout
> a large program, they become susceptible to accidental changes.
>
> Now as software has become even more complex, object technology
> encapsulates collections of functions with the data manipulated by
> those functions. Developers don’t throw the data around between
> disparate groups of nonmember functions which would leave them open
> for accidental attack. As you will see in the next chapter, with
> object-oriented programming, data are encapsulated with the
> functions—nice and safe.
>
> Historical Progression of How Programs Are Organized into Modules

Chapter Summary

SELF-CHECK

> 5-16 What reason for using functions makes the most sense to you?
>
> 5-17 Describe one example of how abstraction helps you get through the
> day.

CHAPTER SUMMARY

-   Th e string class has a large number of operations for manipulating
    > all or part of a string.

> Th ese include substr, nd, at, replace, and length.

-   Some messages require the object name and a dot ( . ) before the
    > member function name and arguments. Use aString.substr(2, 5)
    > rather than substr(aString, 2, 5).

-   Consider using cout.width(10) to right-justify numeric output in 10
    > columns (or cout.width(9) for 9 columns, and so on). Th e new
    > column width starts after the output of the previous value. It
    > does not start at the left margin.

-   Class member functions are often written with the class name and the
    > scope resolution op-erator :: to indicate the class of objects
    > that would understand the message, so you’ll see ostream::width
    > rather than simply width.

-   Class member function headings supply the same usage information as
    > their nonmember cousins (sqrt, pow, fmod). Th e return type is
    > given, as is the function name and the number and class of
    > arguments that must be used.

-   Class member functions additionally are qualifi ed with their class
    > names, for example, void Grid::move().

-   Most classes in this textbook are part of the C++ standard. Th e
    > BankAccount and Grid classes are available at this
    > textbook’s website.

-   A class diagram summarizes the names of the messages understood by
    > any instance of a class (object). Th e programmer needs more
    > information to correctly send a message such as number and class
    > of arguments. Th at is why some of the class member functions were
    > shown with pre- and postconditions.

-   In the 1960s, programs were written as collections of statements. By
    > the 1970s, programs were usually collections of free functions.
    > Starting in the 1990s, more and more programs have been
    > collections of interacting objects, where each object is an
    > instance of a class containing a collection of member functions.
    > Each improvement allows more complex software to be built.

-   Abstraction means the programmer can call a function or send a
    > message without knowing the implementation details. Th e
    > programmer does need to know the function name, the return type,
    > or the number and class of arguments.

EXERCISES

1.  Write the output generated by the following program:

> \#include <iostream> using namespace std; \#include
> "BankAccount.h" // For class Grid
>
> int main() {
>
> BankAccount b1("One", 100.00); BankAccount b2("Two", 200.00);
> b1.deposit(50.00); b2.deposit(30.00); b1.withdraw(20.00); cout
> << b1.getBalance() << endl; cout << b2.getBalance()
> << endl; return 0; }

1.  Write the complete dialogue of this program when the user enters
    > this input in the order requested: MyName 100 22.22 44.44

> \#include <iostream> // For cout and endl using namespace std;
>
> \#include "BankAccount.h" // For the BankAccount class int main() {
> string name; double start, amount;
>
> // Input: cout << "name: "; // MyName cin >> name;
>
> cout << "initial balance: "; // 100 cin >> start;
>
> // Construct a BankAccount
>
> BankAccount one(name, start);
>
> cout << "deposit? "; // 22.22 cin >> amount;
> one.deposit(amount);
>
> cout << "withdraw? "; // 44.44 cin >> amount;
> one.withdraw(amount);
>
> cout << "balance for " << one.getName() << " is "
> << one.getBalance() << endl; return 0; }
>
> 3\. Write the output generated by the following program:
>
> \#include <iostream> // For the object cout using namespace std;

Exercises

> \#include "Grid.h" // For the Grid class int main() {
>
> Grid aGrid(6, 6, 1, 1, south);
>
> aGrid.putDown(2, 3); // Place thing at a speci c intersection
> aGrid.block(0, 0); aGrid.block(5, 5); aGrid.move(2); aGrid.turnLeft();
>
> aGrid.putDown(); // Place thing where the mover is aGrid.move(3); //
> located, which appears as & aGrid.turnLeft();
>
> aGrid.putDown(); // Place object where the mover is located
> aGrid.move(1); aGrid.turnLeft(); aGrid.move(1); aGrid.display();
>
> cout << "Mover: row\#" << aGrid.row() << " col\#"
> << aGrid.column()
>
> << endl; return 0; }

4.  What is the value of position?

> string s("012345678");
>
> // Initialize position to the rst occurrence of "3" in s int position
> = s. nd("3");

4.  What is the value of s2?

> string s1("012345678"); string s2(s1.substr(3, 2)); // assert: s2 is a
> substring of s1

4.  What is the value of lengthOfString?

> string s3("012345678"); int lengthOfString = s3.length(); // assert:
> lengthOfString stores the number of characters in s3

4.  Choose the most appropriate classes for each of the following from
    > this set of classes: double, int, ostream, istream, string,
    > BankAccount, or Grid. a. Represent the number of students in
    > a section.

    b.  Represent a student’s grade point average.

    c.  Represent a student’s name.

    d.  Represent the number of questions on a test.

    e.  Represent a person’s savings account.

    f.  Simulate a very limited version of the arcade game Pac-Man.

    g.  Read input from a user.

    h.  Display output.

5.  Name two reasons why programmers use or implement functions.

6.  Must a programmer understand the implementation of Grid::move to use
    > it?

7.  Answer the following questions given the member function heading:

> void Grid::block(int blockRow, int blockCol)
>
> // pre: The intersection at (blockRow, blockCol) has nothing
>
> // at all on it, not even the mover
>
> // post: The intersection at (blockRow, blockCol) is blocked. The
>
> // mover cannot move into this intersection.

a.  What is the member function name?

b.  What type does it return?

c.  What class does it belong to?

d.  Write a valid message assuming a Grid object named aGrid exists.

<!-- -->

4.  Write a complete C++ program that will initialize a BankAccount
    > object with an initial balance of \$500.00 and your own name. Make
    > a deposit of \$125 and a withdrawal of \$20.00. Th en show the
    > name and balance. Th e output should look like this:

> name: Your Name balance: 605

PROGRAMMING TIPS

1.  You will need author-supplied fi les to complete some
    > programming projects. Th ese are the fi les included with " and "
    > rather than < and > ("Grid.h" and "BankAccount.h",
    > for example). Both fi les need to be located in the same
    > directory (folder) as the .cpp fi le with the main function that
    > you are writing. You can download the proper fi les from this
    > textbook’s website.

2.  Distinguish standard \#include fi les from nonstandard (user
    > defi ned) fi les. \#include standard libraries (classes
    > and objects) with < > and nonstandard classes with " ". Here
    > are some examples:

> \#include <string> // For the standard string class
>
> \#include <iostream> // For cout and cin
>
> using namespace std; // Required to avoid writing std::cout
>
> \#include "BankAccount.h" // For class BankAccount
>
> \#include "Grid.h" // For class Grid

1.  Even if no arguments are required, end messages with (). Do not
    > forget parentheses in messages that do not require arguments.

> cout << myAcct.balance; // Error: This references a memory
> location cout << myAcct.balance(); // Good

Programming Tips

1.  C++ begins counting at 0, not 1. Th e fi rst character in a string
    > is referenced with subscript 0, not 1.

> cout << aString\[0\]; // Return the rst character cout <<
> aString\[1\]; // Return the second character

1.  Don’t reference aString\[aString.length()\]. Th is is an attempt to
    > reference a single value that is not in the range of 0
    > to aString.length()-1. In general, do not reference characters in
    > a string that do not exist.

> string aString;
>
> aString = "This string has 29 characters";
>
> cout << aString\[-1\]; // ERROR: -1 is out of range, only use
> 0..28 cout << aString\[aString.length()\]; // ERROR: 29 is also
> out of range

1.  Two diff erent kinds of constructions are allowed when only one
    > argument is required (C++11 defi nes another, but it is not used
    > until later). One with parenthesis and one with the assignment
    > operator:

> string state1 = "Arizona"; string state2("Minnesota");
>
> int n2 = 0;
>
> int n1(0);
>
> double x2 = 0.0; double x1(0.0);
>
> However, when two or more values are needed to initialize an object,
> use parentheses like this:
>
> BankAccount anAcct("Skyler", 23.41);
>
> Grid aGrid(12, 12, 0, 0, east);

1.  Th e :: operator indicates the class to which a function belongs. Th
    > e :: operator is called the “scope resolution operator.” Th e
    > class name followed by :: documents a function as a
    > member function. Any instance of that class will understand
    > the message. Th erefore, string::length documents that any string
    > object will understand the length message. However, the class name
    > and :: are not to be used in the message.

> BankAccount anAcct("Milan", 345.67);
>
> // Need 'object-name.functionName' not 'class-name::functionName' cout
> << BankAccount::balance(); // Invalid cout <<
> anAcct.balance(); // A valid message

**PROGRAMMING PROJECTS**

5A A LITTLE CRYPTOGRAPHY

> Write a C++ program that hides a message in fi ve words. Use one of
> the characters in the fi ve input strings to spell out one new word.
> Make up at least one other message besides these two that requires
> running the same program twice:
>
> Enter ve words: ***cheap energy can cause problems***
>
> Enter ve integers: ***4 2 1 0 5***
>
> Secret message: peace
>
> Enter ve words: ***programming is very complex work***
>
> Enter ve integers: ***3 0 0 5 2*** Secret message: giver

5B LETTER I

> Write the code that would go in a main function that constructs a
> 13-by-7 Grid object and then instructs the mover to “draw” the letter
> I exactly as shown (the mover could be left anywhere next to the I).
>
> . . . . . . .
>
> . . . . . . .
>
> . . . .
>
> . . . . . .
>
> . . . . . .
>
> . . . . . .
>
> . . . . . .
>
> . . . . . .
>
> . . . . . .
>
> . . . . . .
>
> . . > .
>
> . . . . . . .
>
> . . . . . . .

5C HURDLES

> Write a function void jumpOneHurdle(Grid & g) that instructs the mover
> to jump one “hurdle” (the block \#). Th e main function must make fi
> ve calls to this function and display the current state after each
> function call to jumpOneHurdle.
>
> g.display(); // Show initial state, just after construction
> jumpOneHurdle(g); g.display(); jumpOneHurdle(g); g.display();
> jumpOneHurdle(g); g.display(); jumpOneHurdle(g); g.display();
> jumpOneHurdle(g); g.display();

Th e fi rst display message should show this state of the Grid object:

Programming Projects

> The Grid:
>
> . . . . . . . . . . . . . . . . . . . . . . .
>
> . . . . . . . . . . . . . . . . . . . . . . .
>
> > . . \# . . . \# . . . \# . . . \# . . . \# . . .
>
> . . . . . . . . . . . . . . . . . . . . . . .

Th e sixth display message should show the mover has jumped fi ve
hurdles:

> The Grid:
>
> . . . . . . . . . . . . . . . . . . . . . . .
>
> . . . . . . . .
>
> \# \# \# \# \# > . .
>
> . . . . . . . . . . . . . . . . . . . . . . .

5D STAIR CLIMB

> Write a function void climbStair(Grid & g) that instructs the mover to
> climb one step and call it enough times to climb to the top of the
> stairs. You will need six block messages to simulate the stairs below.

*Before* *After*

The Grid: The Grid:

. . . . . . . . . . . . . . . .

. . . . . . . . . . . . >

> . . . . . \# \# \# . . . \# \# \# . . . . \# . . . . . \# . . .

. . . \# . . . . . \# . . . .

> > . \# . . . . . \# . . . . . . . . . . . . . . . . . . . . .

5E TEN String PROCESSING FUNCTIONS

> Write one C++ program that uses this test driver as a main function to
> generate the output shown by calling ten new free functions, which are
> specifi ed below.

// Test drive 10 String processing functions int main() {

cout << " matterAntiMatter(\\"LOL\\"): " <<
matterAntiMatter("LOL") << endl; cout << "
removeEnds(\\"MarkeR\\"): " << removeEnds("Marker") << endl;
cout << " tripleUp(\\"on\\"): " << tripleUp("on") <<
endl; cout << " splitString(\\"IU\\", \\"owe\\"): " <<
splitString("IU", "owe") << endl; cout << "
reverse7Chars(\\"1234567\\"): " << reverse7Chars("1234567")
<< endl; cout << " halfAndHalf(\\"ABcde\\"): " <<
halfAndHalf("ABcde") << endl; cout << "nameRearranged(\\"Li,
Kim R\\"): " << nameRearranged("Li, Kim R") << endl; cout
<< " middleThree(\\"123456\\"): " << middleThree("123456")
<< endl;

// Use reference parameters instead of returning a string string
str1("abacada"); remove3(str1, "a");

cout << " remove3(\\"abacada\\", \\"a\\"): " << str1
<< endl; string str2("ornoon");

replace(str2, 'o', 'X');

cout << "replace(\\"ornoon\\", 'o', 'X'): " << str2 <<
endl;

return 0; }

> Expected Output
>
> matterAntiMatter("LOL"): Anti-LOL removeEnds("MarkeR"): arke
> tripleUp("on"): 1)on 2)on 3)on splitString("IU", "owe"): IoweU
> reverse7Chars("1234567"): 7654321 halfAndHalf("ABcde"): cdeAB
> nameRearranged("Li, Kim R"): Kim R. Li middleThree("123456"): 345
> remove3("abacada", "a"): bcda replace("ornoon", 'o', 'X'): XrnXXn

1.  string antiMatter(string matter)

> Everyone knows that interplanetary space travel is fueled by letting
> matter and antimatter mix. With this in mind, write a function
> antiMatter that takes a string with the name of some thing or idea.
> Return a string with “Anti-” prepended to it. Don’t forget the hyphen.
>
> matterAntiMatter("Shoes") returns "Anti-shoes" matterAntiMatter("noisy
> trucks") returns ""Anti-noisy trucks" matterAntiMatter("LOL") returns
> "Anti-LOL"

1.  string removeEnds(string str)

> Complete method removeEnds to return a substring of the supplied
> string that does not have the characters at either end. Precondition:
> str always has at least two characters.
>
> removeEnds ("MarkeR") returns "arke" removeEnds ("mom") returns "o"
> removeEnds ("to") returns ""

1.  string tripleUp(string str)

> Complete method tripleUp to return a string that has the argument
> repeated three times with 1), 2), and 3) as shown. Precondition:
> str.length() 1 tripleUp("top") returns "1)top 2)top 3)top"

1.  string splitString(string str, string mid)

> Th is function takes in a string of length 2 or greater, and returns a
> string with a space added into the middle of the string. If the
> string’s length is an odd number, the second

Programming Projects

> half of the string will be the longer half.
>
> splitString("IU", "owe") returns "IoweU" splitString("ab", "\_ \_")
> returns "a\_ \_b"

1.  string halfAndHalf(string str)

> Complete method halfAndHalf to return a new string that has the fi rst
> half of the argument at the end and the last half of the argument at
> the beginning. If there are an odd number of letters, consider the
> last half to have one more character than the fi rst half before the
> split. Precondition:

str.length() 2.

> halfAndHalf("1234abcd") returns "abcd1234" halfAndHalf("ABcde")
> returns "cdeAB" halfAndHalf("Hello") returns "lloHe"

1.  string nameRearranged(string name)

> Implement nameRearranged that takes a name in the form lastName, ", "
> rstName, and an initial and returns a string in the form of rstName,
> initial, ". " and lastName.
>
> nameRearranged("Jones, Kim R") returns "Kim R. Jones"

1.  string middleThree(string str)

> Implement middleThree so it returns the middle three characters of any
> string that has three or more characters. If the length of name is
> even, favor the right. Precondition: str.length() 3.
>
> middleThree("Rob") returns "Rob" middleThree("Roby") returns "oby"
> middleThree("Robie") returns "obi" middleThree("123456") returns "345"

1.  string reverse7Chars(string str)

> Implement reverse7Chars so it returns a string that is the reverse of
> the argument. Precondition: Th e argument str is seven characters
> long.
>
> reverse7Chars("1234567") returns "7654321" reverse7Chars("morning")
> returns "gninrom"

1.  void remove3(string & str, string sub)

> Implement remove3 so it modifi es the string argument str such that
> the fi rst three occurrences of sub are removed. Precondition: Th e
> argument sub exists at least three times in str.
>
> string str("there is the other the");
>
> removeThree(str, "he"); // str changes to " tre is t otr the"
>
> string str2("to be or to be or to be");
>
> removeThree(str2, "to "); // str2 changes to " be or be or be"

1.  void replace(string & str, char oldC, char newC)

Implement replace to modify the string argument str so that the fi rst
three occurrences of oldC are changed to newC. Precondition: Th e
argument oldC exists at least three times in str.

> string str3("ornoono");
>
> replace(str3, 'o', 'X'); // str3 changes to Xr nXXno
