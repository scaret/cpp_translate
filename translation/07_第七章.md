**C H A P T E R S E V E N**

Selection

SUMMING UP

> Until this point, all programs in this textbook executed all
> statements in a sequential fashion, in order from the fi rst statement
> of each block to the last. Th e function calls and messages executed
> unseen code that involved other forms of statement control.

COMING UP

> Chapter 7 examines statements that select which actions execute.
> Depending on the current circumstances, an action may execute one time
> but not the next. Th e alternatives are made possible with the C++ if,
> if...else, and switch statements. After studying this chapter you will
> be able to

-   recognize when to use the Guarded Action pattern (do something
    > onlyunder certain conditions)

-   implement the Guarded Action pattern with the C++ if statement

-   use relational operators such as < and >

-   create and evaluate expressions with the logical operators

-   use bool objects

-   understand the Alternative Action pattern

-   implement the Alternative Action pattern with the C++ if...else
    > statement

-   implement the Multiple Selection pattern with if...else and switch

-   solve problems using the Multiple Selection pattern

7.1 SELECTIVE CONTROL

> Programs must often anticipate a variety of situations. For example,
> an automated teller machine (ATM) must serve valid bank customers—but
> it must also reject invalid access. Once validated, a customer may
> wish to perform a balance query, a cash withdrawal, or a deposit
> transaction. Th e code that controls an ATM must permit these diff
> erent requests. Without selective forms of control—the new statements
> of this chapter—all bank customers could only perform one particular
> transaction. Worse yet, invalid PINs could not be rejected!
>
> 175
>
> Before any ATM becomes operational, programmers must implement code
> that anticipates all possible transactions. Th e code must turn away
> customers with invalid PINs. Th e code must prevent invalid
> transactions such as cash withdrawal amounts that are not in the
> proper increment, typically \$20.00. Th e code must be able to deal
> with customers who attempt to withdraw more than they have. To
> accomplish these tasks, a new form of control is needed—a statement to
> permit or prevent execution of certain statements depending on certain
> inputs.

7.1.1 THE GUARDED ACTION PATTERN

> Programs often need actions that do not always execute. At one moment,
> a particular action must occur. At some other time—the next day or the
> next millisecond perhaps—the same action must be skipped. For example,
> one student may have made the dean’s list because the student’s grade
> point average (GPA) was 3.5 or higher. Th at student becomes part of
> the dean’s list. Th e next student may have a GPA lower than 3.5 and
> should not become part of the dean’s list. Th e action—adding a
> student to the dean’s list—is guarded. Th e *Guarded Action pattern*
> and the C++ means of implementing it are shown next.
>
> **Algorithmic Pattern:** *Th e Guarded Action pattern*

  **Pattern:**        Guarded Action
  ------------------- --------------------------------------------------------------------
  **Problem:**        Do something only if certain conditions are true
  **Outline:**        if ( *true-or-false-condition is true* ) *execute this action (s)*
  **Code Example:**   if (GPA >= 3.5)

> cout << "Made the deans list" << endl;

7.1.2 THE if STATEMENT

> Th is Guarded Action pattern is often implemented with the C++ if
> statement.
>
> General Form 7.1 if *statement*

if (*logical-expression*) *true-part*;

> Th e *logical-expression* is any expression that evaluates to either
> true or false. Th e *true-part* may be any valid C++ statement,
> including a block that uses curly braces { } to treat two or more
> statements as if they were one statement.

7.1: Selective Control

> Example: if *statements*
>
> cin >> hoursStudied; if (hoursStudied > 4.5)
>
> cout << "You are ready for the test" << endl;
>
> if (hours > 40.0) { regularHours = 40.0; overtimeHours = hours -
> 40.0; }
>
> When an if statement is encountered, the logical expression is
> evaluated to a false (zero) or true (nonzero) value. Th e true part
> executes only if the logical expression is true. So in the fi rst
> example above, the output "You are ready for the test" appears only
> when the user enters something greater than 4.5 hours. When the input
> is 4.5 or less, the true part is skipped—the action is guarded. Here
> is a fl owchart view of the Guarded Action pattern:
>
> Th e next program illustrates how selection alters the fl ow of
> control. Each of the sample dialogues below illustrates that the code
> performs diff erent actions due to the variety of conditions. More
> specifi cally, the musicAward function returns a diff erent string due
> to the diff erent arguments in the three function calls from main.
>
> // Show that the same code can return three different results.
>
> // showAward has three instances of the Guarded Action pattern.
>
> \#include <iostream> // For cout and endl
>
> \#include <string> // For the string class using namespace std;
>
> string musicAward(long int recordSales) {
>
> // pre: Argument < maximum long int (usually 2,147,483,647)
>
> // post: Return a message appropriate to record sales string result;
> if (recordSales < 500000)
>
> result = "--Sorry, no certi cation yet. Try more concerts.";
>
> if (recordSales >= 500000)
>
> result = "--Congrats, your music is certi ed gold.";
>
> if (recordSales >= 1000000)
>
> result = result + " It's also gone platinum!";
>
> return result; }
>
> int main() {
>
> // Test drive showAwards three times with different results cout
> << 123456 << musicAward( 123456) << endl; cout
> << 504123 << musicAward( 504123) << endl; cout
> << 3402394 << musicAward(3402394) << endl; return 0;
> }
>
> Output
>
> 123456--Sorry, no certi cation yet. Try more concerts.
>
> 504123--Congrats, your music is certi ed gold.
>
> 3402394--Congrats, your music is certi ed gold. It's also gone
> platinum!
>
> Th rough the power of the if statement, the same exact code results in
> three diff erent versions of statement execution. Th e if statement
> controls execution because the true part executes only when the
> logical expression is true. Th e if statement also controls statement
> execution by disregarding statements when the logical expression is
> false. For example, the platinum message is disregarded when
> recordSales is less than one million.

7.2 RELATIONAL OPERATORS

> Two new operators, < and >=, test the relationship between the
> value of recordSales and the numeric values 500,000 and 1,000,000. Th
> ey are part of the set of relational operators that create logical
> expressions—an important part of if statements (see table below):

  **Relational Operator **   **Meaning**
  -------------------------- ----------------------------
  <                       Less than
  >                       Greater than
  <=                      > Less than or equal to
  >=                      > Greater than or equal to
  ==                         > Equal to
  !=                         > Not equal to

7.2: Relational Operators

> When a relational operator is applied to two operands that can be
> compared, the result is one of two values: true or false. Th e next
> table shows some examples of simple logical expressions and their
> resulting values. Notice that objects such as double and string can be
> compared to other objects of the same class. string objects are
> related alphabetically—"A" is less than "B" and "D" is greater than
> "C", for example.

Logical Expression Result Logical Expression Result

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------
  double x = 4.0;                                       > true false true false true   string name = "Bill";                           > false true true false true
                                                                                                                                       
  x < 5.0 x > 5.0 x <= 5.0 5.0 == x x != 5.0                                  name == "Sue" name != "Sue" name < "Chris"   
                                                                                                                                       
                                                                                       "Bobbie" > Bobby"                            
                                                                                                                                       
                                                                                       "Bob" < "Bobbie"                             
  ----------------------------------------------------- ------------------------------ ----------------------------------------------- ------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------

> Th is is a good time to point out an all-too-common and diffi
> cult-to-track-down error that can create havoc. All math courses you
> have ever taken use = for algebraic equality. When you try to do that
> in C++, you will actually be using the assignment operator = rather
> than ==, the C++ equality operator. Th e problem is that the compiler
> does not detect an error. Consider this if statement:
>
> int x = 0; if (x = 3) cout << x << " equals 3" <<
> endl;
>
> Output
>
> 3 equals 3
>
> First x was 0, then it became 3 while testing the logical expression x
> = 3, which is an assignment. It turns out that C++ assignment
> operations evaluate to the value being stored. Th e expression x = 3
> not only assigns 3 to x, it also evaluates to the value actually
> assigned, which in this case is 3, or nonzero, or true. If you want to
> compare x to 3, use == like this:
>
> int x = 0; if (x == 3) cout << x << " equals 3" <<
> endl;
>
> Output
>
> There is no output.

SELF-CHECK

7-1 Which expressions evaluate to true assuming j and k are initialized
like this:

> int j = 4; int k = 8;

a.  (j+4) == k d. j != k g. j = 0 *careful*

b.  0 == j e. j < k h. j = 165 *careful*

c.  j >= k f. 4 == j

7-2 Write the output generated by the following code:

a.  string option = "A"; d. int grade = 45; if (option == "A") if
    > (grade >= 70) cout << "addRecord"; cout <<
    > "passing" << endl; if (option == "D") { if (grade < 70)
    > cout << "deleteRecord"; cout << "dubious" <<
    > endl;

> } if (grade < 60) cout << "failing" << endl;

a.  string option = "D"; e. int grade = 65; if (option == "A") if
    > (grade >= 70) cout << "addRecord"; cout <<
    > "passing" << endl; if (option == "D") if (grade < 70)

cout << "deleteRecord"; cout << "dubious" << endl;

if (grade < 60)

cout << "failing" << endl;

a.  string option = "a"; f. int g = 45; if (option == "A") { // Careful!

cout << "addRecord"; cout << "g: " << g << endl;

} if (g = 70)

if (option == "D") { cout << "at cutoff" << endl;

cout << "deleteRecord"; cout << "g: " << g <<
endl;

} if (g = 1)

> cout << "you get one" << endl; cout << "g: "
> << g << endl;

7.3: The Alternative Action Pattern

7.3 THE ALTERNATIVE ACTION PATTERN

> Programs must often select from a variety of actions. For example, one
> student passes with a fi nal grade of >= 60.0 and the next student
> fails with a fi nal grade of < 60.0. Th is is an example of the
> Alternative Action algorithmic pattern. Th e program must choose one
> course of action or an alternative.
>
> **Algorithmic Pattern:** *Th e Alternative Action pattern*

  ----------------------------------------------------------------------------------------
  > **Pattern:**   Alternative Action
  ---------------- -----------------------------------------------------------------------
  > **Problem:**   Need to choose one action from two alternatives

  > **Outline:**   if ( *true-or-false-condition is true* ) *execute action-1* else
                   
                   *execute action-2*

  > **Code**       if ( nalGrade >= 60.0) cout << "passing" << endl; else
  >                
  > **Example:**   cout << "failing" << endl;
  ----------------------------------------------------------------------------------------

7.3.1 THE if...else STATEMENT

> Th e Alternative Action pattern is implemented in C++ with the
> if...else statement. Th is control structure can be used to choose
> between two diff erent courses of action (and as shown later, to
> choose between more than two alternatives).
>
> General Form 7.2 if...else *statement*

if (*boolean-expression*)

*true-part*; else

*false-part*;

> Th e if...else statement is an if statement followed by the alternate
> path after an else. Th e *true-part* and the *false-part* may be any
> valid C++ statement, including a block.
>
> if (sales <= 20000.00)
>
> cout << "No bonus this month" << endl; else cout <<
> "Bonus coming" << endl;

When an if...else statement is encountered, the *logical expression*
evaluates to either false or true. When true, the true part executes—the
false part does not. When the logical expression is false, only the
false part executes.

> Th e next example illustrates how if...else works. When x has a value
> less than or equal to zero, the output is FALSE. When x is positive,
> the true part executes and TRUE is output.
>
> double x; cout << "Enter x: "; cin >> x; if (x > 0.0)
>
> cout << "TRUE" << endl; else cout << "FALSE"
> << endl;
>
> Here is another example of if...else demonstrating alternative action
> that depends on the logical expression (miles > 900000). Sometimes
> the true part executes—when miles is greater than 90000. Otherwise,
> the false part executes—when miles is not greater than 90000.
>
> int miles; cout << "Enter miles: "; cin >> miles; if
> (miles > 90000) {
>
> cout << "Tune-up " << (miles-90000) << " miles
> overdue" << endl;
>
> } else {
>
> cout << "Tune-up due in " << (90000-miles) << "
> miles" << endl; }
>
> When miles is input as 96230, the output is Tune-up 6230 miles
> overdue, but when miles is input as 89200, the false part executes;
> the output is Tune-up due in 800 miles.

SELF-CHECK

7-3 What output occurs when miles is 90000?

Th e ability to choose is a powerful feature of any programming
language. Th e if...else statement provides the means to make a program
general enough to generate useful information

7.3: The Alternative Action Pattern

> appropriate to a variety of data. For example, an employee’s gross pay
> may be calculated as hours times the rate when hours is less than or
> equal to 40. However, certain employers must pay timeand-a-half to
> employees who work more than 40 hours per week. Gross pay with
> overtime can be computed as follows:

pay = (40 \* rate) + (hours - 40) \* 1.5 \* rate;

> With alternative actions, a program can correctly compute gross pay
> for a variety of values including those less than 40, equal to 40, and
> more than 40. Th is instance of the Alternative Action pattern is now
> placed in the context of a complete program.
>
> // Illustrate the exibility offered by Alternative Action
>
> \#include <iostream> using namespace std;
>
> int main() { double pay = 0.0; double rate = 0.0; double hours = 0.0;
>
> cout << "Enter hours worked and rate of pay: "; cin >>
> hours >> rate;
>
> if (hours <= 40.0)
>
> pay = hours \* rate; // True part else
>
> pay = (40 \* rate) + (hours - 40) \* 1.5 \* rate; // False part cout
> << "pay: " << pay << endl;
>
> return 0; }
>
> **Dialogue 1:**
>
> Enter hours worked and rate of pay: ***38.0 10.0*** pay: 380
>
> **Dialogue 2:**
>
> Enter hours worked and rate of pay: ***42.0 10.0*** pay: 430
>
> It should be noted that semicolon (;) placement in if...else
> statements is somewhat confusing at fi rst. If you observe a compile
> time error near an if...else statement, look closely at the placement
> or lack of semicolons. Also be careful that you don’t place a
> semicolon immediately after the logical expression. Th is is a common
> mistake. In this case, the true part is an empty statement where
> nothing happens and what follows ; is not part of the if statement.

SELF-CHECK

7-4 Given the following code:

> if (hours >= 40.0) hours = 40 + 1.5 \* (hours - 40);

Determine the fi nal value of hours when hours starts as:

a.  38 c. 42

b.  40 d. 43.5

> 7-5 Write the output generated by each of the following programs given
> these initializations of n and x:
>
> int n = 8; double x = -1.5;

a.  if (x < -1.0) c. if (x >= n)

cout << "true" << endl; cout << "x is high";

else else

> cout << "false" << endl; cout << "x is low"; cout
> << "after if...else";

a.  if (n >= 0) { d. // true part is another if...else cout <<
    > "zero or pos"; if (x <= 0.0) {

> } if (x < 0.0) else { cout << "neg"; cout << "neg";
> else

} cout << "zero";

> } else cout << "pos";
>
> 7-6 Write an if...else statement that displays your name if option has
> the value 1, and displays your school if option has the value of
> anything else.

7.4 BLOCKS WITH SELECTION STRUCTURES

> Th e special symbols { and } have been used to gather a set of
> statements that are treated as one inside the body of a function. Th
> ese two special symbols delimit (mark the boundaries of) a block. Th e
> block groups together many actions, which can then be treated as one.
> Th e block is also useful for combining more than one action as the
> true or false part of an if...else statement.
>
> // This program uses blocks for both the true and false parts. The //
> block makes it possible to treat many statements as one.
>
> \#include <iostream> using namespace std;

7.4: Blocks with Selection Structures

> int main() { double GPA = 0.0;
>
> double margin = 0.0; // How far from dean's list cut-off
>
> cout << "Enter GPA: "; cin >> GPA; if (GPA >= 3.5) {
>
> // True part contains more than one statement in this block cout
> << "Congratulations, you are on the dean's list." << endl;
> margin = GPA - 3.5;
>
> cout << "You made it by " << margin << " points."
> << endl;
>
> } else {
>
> // False part contains more than one statement in this block cout
> << "Sorry, you are not on the dean's list." << endl;
> margin = 3.5 - GPA;
>
> cout << "You missed it by " << margin << " points."
> << endl;
>
> } return 0; }
>
> Th e block makes it possible to treat several statements as one. When
> GPA is input as 3.7, GPA >= 3.5 becomes true and the following
> dialog is generated:
>
> Enter GPA: ***3.7***
>
> Congratulations, you are on the dean's list.
>
> You made it by 0.2 points.

When GPA is 2.9, GPA >= 3.5 becomes false and this output occurs:

Enter GPA: ***2.9***

> Sorry, you are not on the dean's list.
>
> You missed it by 0.6 points.
>
> Th is alternative execution is provided by the two possible
> evaluations of the logical expression GPA >= 3.5. If true, the true
> part executes; if false, the false part executes.

7.4.1 THE TROUBLE IN FORGETTING AND

> Neglecting to use the block can cause a variety of errors. Modifying
> the previous example illustrates what can go wrong if the block is not
> used when attempting to execute both cout statements.
>
> if (GPA >= 3.5) margin = GPA - 3.5;
>
> cout << "Congratulations, you are on the dean's list." <<
> endl; cout << "You made it by " << margin << "
> points." << endl; else // <- ERROR: Unexpected else
>
> With { and } removed there is no block; the two highlighted statements
> no longer belong to the preceding if...else—even though the
> indentation might make it appear as such. Th is previous code
> represents an if statement, followed by two cout statements, followed
> by the reserved word else. When else is encountered, the C++ compiler
> complains because there is no statement that begins with an else.
>
> Here is another example of what can go wrong when a block is omitted.
> Th is time, { and } are omitted after else.
>
> else
>
> margin = 3.5 - GPA;
>
> cout << "Sorry, you are not on the dean's list." << endl;
> cout << "You missed it by " << margin << " points."
> << endl;
>
> Th ere are no compile time errors here, but the code does contain an
> intent error. Th e fi nal two statements always execute! Th ey do not
> belong to if...else. Whenever GPA >= 3.5 is false, the code does
> execute as one would expect, but when this logical expression is true,
> the output is not what is intended. Instead, this rather confusing
> output shows up:
>
> Congratulations, you are on the dean's list.
>
> You made it by 0.152 points.
>
> Sorry, you are not on the dean's list.
>
> You missed it by -0.152 points.
>
> Although not necessary, it could help if you always use blocks as the
> true and false part of if and if...else statements. Th e practice can
> make for more readable code and at the same time prevent intent errors
> such as the one above. One of the drawbacks is that there are more
> lines of code and more sets of curly braces to line up. Also, as
> you’ll see in the second part of this chapter with the Multiple
> Selection pattern, the action is most often only one statement. Th e
> block is not required.

7.5 bool OBJECTS

> C++ has bool objects to store either one of these constants: true or
> false. Named after the mathematician George Boole, bool objects
> simplify logical expressions as demonstrated in the following program:
>
> // Demonstrates bool initialization and assignment. A standard C++ //
> compiler has bool, true, and false built in.
>
> \#include <iostream> using namespace std;
>
> int main() {
>
> // Initialize three bool objects to false bool ready, willing, able;
> double credits = 28.5; double hours = 9.5;
>
> // Assign true or false to all three bool objects ready = hours >=
> 8.0; willing = credits > 20.0; able = credits <= 32.0;
>
> // If all three bools are true, the logical expression is true if
> (ready && willing && able) cout << "YES" << endl; else
>
> cout << "NO" << endl;
>
> return 0; }
>
> Output
>
> YES
>
> Like other objects, bool objects can be declared, initialized, and
> assigned a value. Th e assigned expression should be a logical
> expression—one that evaluates to true or false. Two new constants are
> also added: true and false. Th is is shown in the initializations of
> the three bool objects in the previous program.
>
> Th e bool class is often used as the return type in both nonmember and
> class member functions. For example, the LibraryBook class has a
> member function that returns true when a book is available or false if
> it was checked out.
>
> bool LibraryBook::isAvailable() // post: Return true if this book is
> available, or false if not

Here is an example free function that returns true if the integer
argument is odd:

> // Demonstrate a simple bool function
>
> \#include <iostream> using namespace std;
>
> bool isOdd(int n) {
>
> // post: Return true if n is an odd integer return (n % 2) != 0; }
>
> int main() { int j = 3;
>
> // Ensure j is an even number if (isOdd(j)) { j = j + 1;
>
> }
>
> cout << j << endl;
>
> return 0;
>
> }
>
> Output
>
> 4

7.5.1 BOOLEAN OPERATORS

> C++ has three Boolean operators, ! (not), ¦¦ (or), and && (and), to
> create more complex logical expressions. For example, this logical
> expression:
>
> (test >= 0) && (test <= 100) shows the logical “and” operator
> (&&) applied to two logical operands. Since there are only two logical
> values, true and false, the following table shows every possible
> combination of logical values and the logical operators !, ¦¦, and &&:

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  **! (not)**      **¦¦ (or)**   **&& (and)**
  ---------------- ------------- --------------------------------------------------------- ---------------------- --------------------------------------------------------- ------------------------
  **Expression**   **Result**    **Expression**

  ! false          true false    true ¦¦ true true ¦¦ false false ¦¦ true false ¦¦ false
                                 
  ! true                         
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

> Th e next example logical expression uses the Boolean operator &&
> (logical “and”) to ensure a test is in the range of 0 through 100
> inclusive. Th e logical expression is true when test has a value
> greater than or equal to 0 (test >= 0) and at the same time is less
> than or equal to 100

(test <= 100).

> if ((test >= 0) && (test <= 100)) cout << "Test is in
> range"; else cout << "\*\*Warning--Test is out of range";
>
> Here is how the if statement evaluates its logical expressions when
> test has the value 97 and then 977 (to simulate an attempt to enter 97
> when the user accidentally presses 7 twice):
>
> (test >= 0) && (test <= 100) (test >= 0) && (test <= 100)
> ( 97 >= 0) && ( 97 <= 100) (977 >= 0) && (977 <= 100)
>
> true && true true && false true false

7.5.2 OPERATOR PRECEDENCE RULES

> Programming languages have precedence rules governing the order in
> which operators are applied to the operand(s). For example, in the
> absence of parentheses, the relational operators >= and <= are
> evaluated before the && operator. Most operators are grouped
> (evaluated) in a left-to-right order: a / b / c / d is equivalent to
> (((a / b) / c) / d).
>
> However, there is one notable exception. Th e assignment operator
> groups in a rightto-left order to allow multiple assignments such as
> this: x = y = z = 0.0 is equivalent to
>
> (x = (y = (z = 0.0))). Th e expression z = 0.0 returns 0.0, which is
> then transferred to y, which is transferred to x.
>
> Th e following table lists some (though not all) of the C++ operators
> in order of precedence. Th e :: and () operators are evaluated fi rst
> (have the highest precedence), and the assignment operator = is
> evaluated last. Although there are more operators in C++, this table
> represents all the operators used in this textbook, and they have all
> been discussed already.
>
> Precedence rules of C++ operators (partial list)

  --------------------------------------------------------------------------------------------
  **Category **    **Operators**         **Descriptions **                     **Grouping**
  ---------------- --------------------- ------------------------------------- ---------------
  Highest          :: , ()               Scope resolution, Function call       Left to right

  Unary            ! , + , -             Not, Unary plus, Unary minus          Right to left

  Multiplicative   \* , / , %            Multiplication, Division, Remainder   Left to right

  Additive         + , -                 Binary plus, Binary minus             Left to right

  Input/Output     >> , <<   Stream extraction, Stream insertion   Left to right

  Relational       < , >           Less than, Greater than               Left to right
                                                                               
                   <= , >=         Less or equal, Greater or equal       

  Equality         == , !=               Equal, Not equal                      Left to right

  and              &&                    Logical and                           Left to right

  or               ¦¦                    Logical or                            Left to right

  Assignment       =                     Assign right value to left value      Right to left
  --------------------------------------------------------------------------------------------

> One of the problems with these elaborate precedence rules is simply
> trying to remember them. When unsure, use parentheses to clarify these
> precedence rules. Using parentheses makes the code more readable and
> therefore more understandable.

SELF-CHECK

7-7 Evaluate the following expressions to true or false:

a.  (false ¦¦ true)

b.  (true && false)

c.  (1 \* 3 == 4 - 1)

d.  (false ¦¦ (true && false))

e.  (3 < 4 && 3 != 4)

f.  (! false && ! true)

g.  ((5 + 2) > 3 && (11 < 12))

h.  ! ((false && true) ¦¦ false)

    8.  Write an expression that is true only when the int object named
        > score is in the range of 1 through 10 inclusive.

    9.  Write an expression that is true if test is outside the range of
        > 0 through 100 inclusive.

    10. Write the output generated by the following code (be careful):

> double GPA = 1.03; if (GPA = 4.0) cout << "President's list";

7.5.3 THE BOOLEAN “OR” ¦¦ WITH A grid OBJECT

> Th e next sample logical expression uses the operator ¦¦ (logical
> “or”) to determine if the mover in a grid object is on one of the four
> edges. Th e logical expression is true when the mover is in row number
> 0, column number 0, the last row, or the last column.
>
> (g.row() == 0)
>
> ¦¦ (g.row() == g.nRows()-1)
>
> ¦¦ (g.column() == 0)
>
> ¦¦ (g.column() == g.nColumns()-1)
>
> Th is logical expression evaluates like this when the mover is in row
> 1, column 5 of a 6-by-6 grid object (the ¦¦ operator evaluates in a
> left-to-right order):

The grid:

. . . . . .

. . . . . > . . . . . .

. . . . . .

. . . . . . . . . . . .

g.row()==0 ¦¦ g.row()==g.nRows()-1 ¦¦ g.column()==0 ¦¦
g.column()==g.nColumns()-1

1==0 ¦¦ 1==5 ¦¦ 5==0 ¦¦ 5==5 false ¦¦ false ¦¦ 5==0 ¦¦ 5==5 false ¦¦
false ¦¦ 5==5 false ¦¦ true true

> Th e only time this expression is false is when all four
> subexpressions are false. If any one of them is true, the expression
> evaluates to true, in fact, more quickly than you might think (see
> short circuit Boolean evaluation below). Now here is the same
> expression put into the context of a function that determines if the
> mover is on the edge of *any* grid object:
>
> // Show a more complex logical expression inside a bool function
>
> \#include <iostream> // For cout using namespace std; \#include
> "Grid.h" // For class Grid bool moverOnEdge(const Grid & g) {
>
> // post: Return true if the mover is on an edge or false if not bool
> result;
>
> result = (g.row() == 0) // On north edge? ¦¦ (g.row() == g.nRows()-1)
> // On south edge?
>
> ¦¦ (g.column() == 0) // On west edge? ¦¦ (g.column() ==
> g.nColumns()-1); // On east edge?
>
> return result; }
>
> int main() {
>
> // Test drive moverOnEdge
>
> Grid tarpit(6, 6, 2, 5, east);
>
> if (moverOnEdge(tarpit)) { cout << "On edge" << endl;
>
> } else {
>
> cout << "Not on edge" << endl; }
>
> return 0; }
>
> Output
>
> On edge

SELF-CHECK

> 7-11 Many tests are necessary for the moverOnEdge function. Write the
> output from the preceding program when the mover is at each of the
> following intersections:

  > **Row**   **Column**   > **Output—on edge or not?**
  ----------- ------------ ------------------------------
  3           4            
  4           3            
  2           2            
  0           2            
  2           0            

7.5.4 SHORT CIRCUIT BOOLEAN EVALUATION

> In the logical expression (E1 && E2), E1 is evaluated fi rst and if it
> is false, E2 is not evaluated. Th is is called *short circuit
> evaluation*. It is satisfactory because false && false is false. So is
> false && true. Evaluating the second expression E2 is not necessary.
> Th is is the way C++ evaluates logical expressions—stopping as soon as
> possible. Short circuit evaluation is also possible with the “or”
> operator ¦¦. In the expression (E1 ¦¦ E2), E1 is evaluated fi rst and
> if E1 is true, E2 is not evaluated. A programmer can actually get away
> with code like this:
>
> if ((x >= 0.0) && (sqrt(x) <= 4.0))
>
> When x is negative, the second expression with sqrt(x) is never
> evaluated. By checking for x >= 0.0 fi rst, the square root of a
> negative number never occurs. Switch the order of statements and a
> runtime error occurs when x < 0.0.

Also consider the previous example of Boolean evaluation in the bool
function moverOnEdge.

> When the mover was in row 2 and column 5, the fi rst three Boolean
> subexpressions were false. Th erefore, the evaluation had to carry on
> until the fourth (and fi nal) subexpression. Th is entire expression
> would also be evaluated whenever the mover was not on an edge—all four
> subexpressions would be false. However, consider the same expression
> if the mover had been in row 0:
>
> The grid:
>
> . . . . . > . . . . . .
>
> . . . . . .
>
> . . . . . .
>
> . . . . . .
>
> . . . . . .

  g.row()==0                   true
  ------------------------- -- ---------------
  ¦¦ g.row()==g.nRows()-1      not evaluated
  ¦¦ g.column()==0             not evaluated

> ¦¦ g.column()==g.nColumns()-1 not evaluated
>
> As soon as g.row()==0 evaluates to true, the following three
> subexpressions do not need to be evaluated. true ¦¦ anything is true.
> Short circuit Boolean evaluation is part of C++ because it improves
> runtime effi ciency. Imagine evaluating one or two fewer
> subexpressions millions of times.

SELF-CHECK

> 7-12 Evaluate the following expressions after each set of assignments
> to x and y:
>
> ((fabs(x - y) >= 0.001) && (x >= 0.0) && (sqrt(x) < 6.5))

  a\. x = 1.0        c\. x = -1.0
  ------------------ --------------
  > y = 2.0          y = 2.0
  b\. x = 56.77779   d\. x = -1.0
  > y = 56.77777     y = 1.0

> 7-13 How many subexpressions evaluate when the mover is in row 5,
> column 3, assuming a 6-by-6 grid?
>
> g.row()==0 ¦¦ g.row()==g.nRows()-1
>
> ¦¦ g.column()==0
>
> ¦¦ g.column()==g.nColumns()-1

7.6: A bool Member Function

7.6 A bool MEMBER FUNCTION

> Th e class defi nition of BankAccount has a void withdraw member
> function with the precondition that the withdrawal amount must not be
> greater than the balance. Th is implementation currently allows the
> balance to go negative when the preconditions are not met by the
> client code (the following member function is from BankAccount.cpp).
>
> void BankAccount::withdraw(double withdrawalAmount) {
>
> // pre: withdrawalAmount <= balance balance = balance -
> withdrawalAmount; }
>
> A better design would be to disallow negative balances. Th en the
> client code would not have to worry about satisfying the precondition.
> Th e withdraw message could avoid negative balances. Th e return type
> could also become bool so the client code has the chance to determine
> if the withdraw message was successful or not. First, the class defi
> nition would have to be changed. void is changed to bool in the fi le
> BankAccount.h:
>
> bool withdraw(double withdrawalAmount); // post: If withdrawalAmount
> <= balance && withdrawalAmount > 0.0, // debit withdrawalAmount
> from this balance and return true.
>
> // Otherwise don't change anything--just return false.
>
> Th en the implementation is changed in BankAccount. Th e Alternative
> Action pattern chooses between debiting the account and returning true
> or returning false when the balance is not large enough.
>
> bool BankAccount::withdraw(double withdrawalAmount) { bool result =
> true;
>
> if ((withdrawalAmount > balance) ¦¦ (withdrawalAmount <= 0.00))
> result = false; else
>
> balance = balance - withdrawalAmount;
>
> return result; }
>
> Th e following program test drives this new behavior. Because withdraw
> returns either true or false, the message can be used as a test
> expression.
>
> // Test drive the "safe" BankAccount::withdraw
>
> \#include <iostream> using namespace std;
>
> \#include "BankAccount.h" // A modi ed "safe" BankAccount
>
> int main() {
>
> BankAccount aSafeAccount("Charlie", 50.00); double withdrawalAmount;
> cout << "Enter amount to withdraw: ";
>
> cin >> withdrawalAmount;
>
> if (aSafeAccount.withdraw(withdrawalAmount)) {
>
> cout << "Balance = \$" << aSafeAccount.getBalance()
> << endl;
>
> } else {
>
> cout << "Could not withdraw " << withdrawalAmount <<
> endl; }
>
> // Can ignore return result aSafeAccount.withdraw(10000); return 0; }
>
> Dialogue 1
>
> Enter amount to withdraw: ***75.00***
>
> Could not withdraw 75.00
>
> Dialogue 2
>
> Enter amount to withdraw: ***20.00***
>
> Balance = \$30
>
> In C++, any function return result can be ignored. Th is new version
> of withdraw could be used as it was before—as a stand-alone statement
> rather than as part of an if statement. Th is is done at the attempt
> to withdraw \$1,000.00 as the last statement in main, just before
> return 0.

SELF-CHECK

> 7-14 Using this new safe version of the BankAccount::withdraw
> function, write the output generated by the program given below for
> each value of wAmount:

a.  double wAmount = 100.00; c. double wAmount = 112.50;

b.  double wAmount = -100.00; d. double wAmount = 200.00;

> \#include <iostream> // For cout using namespace std; \#include
> "BankAccount.h" // For the BankAccount class
>
> int main() {
>
> BankAccount b("Kilroy", 112.50);
>
> double wAmount = -100.00; // Substitute new values here if
> (b.withdraw(wAmount)) { cout << "okay" << endl;
>
> }

7.7: Multiple Selection

> else {
>
> cout << "failed" << endl;
>
> } return 0; }

7.7 MULTIPLE SELECTION

> *Multiple Selection* refers to the times when the programmer needs to
> select one action from many possible actions. Th is is something that
> occurs quite often when programming. Th e pattern that solves this
> problem can be implemented as an if...else statement that has other
> if...elses nested inside their false parts. Th e more actions there
> are to choose from, the more nesting occurs. Th is pattern is
> summarized as follows:
>
> **Algorithmic Pattern:** *Th e Multiple Selection pattern*

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  > **Pattern:**   Multiple Selection
  ---------------- -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  > **Problem:**   Must execute one set of actions from three or more alternatives

  > **Outline:**   if ( *condition 1 is true* ) *execute action 1*
                   
                   else if ( *condition 2 is true* ) *execute action 2* // ... else if ( *condition n-1 is true* ) *execute action n-1* else
                   
                   *execute action n*

  > **Code**       if (grade < 60.0) result = "F"; else if (grade < 70) result = "D"; else if (grade < 80) result = "C"; else if (grade < 90) result = "B"; else result = "A";
  >                
  > **Example:**   
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

> Th e following program contains an instance of the Multiple Selection
> pattern to select from one of the three possible actions:
>
> // Multiple selection where exactly one cout statement executes.
>
> // The output is dependent on the input value for GPA.
>
> \#include <iostream> using namespace std;
>
> int main() { double GPA;
>
> cout << "Enter your GPA: "; cin >> GPA;
>
> if (GPA < 3.5) {
>
> cout << "Try harder" << endl;
>
> }
>
> else {
>
> // Execute this multiple selection statement if (GPA < 4.0)
>
> cout << "You made the dean's list" << endl; else
>
> cout << "You made the president's list" << endl;
>
> } return 0; }
>
> Notice that the false part of the fi rst if...else statement is
> another if...else statement. If GPA is less than 3.5, Try harder is
> output and the program skips over the nested if...else. However, if
> the logical expression is false (when GPA is greater than or equal to
> 3.5), the second if...else statement determines if GPA is high enough
> to qualify for either the dean’s list or the president’s list. Here
> one alternative selection is nested inside another alternative
> selection. When implementing the Multiple Selection pattern, it is
> important to use proper indentation so the code will execute as its
> written appearance suggests. Th e readability realized by good
> indentation habits can save you time during program implementation,
> which includes testing. To illustrate the fl exibility in formatting,
> the previous multiple selection may be rewritten in the following
> preferred manner to line up the three paths through this control
> structure:
>
> if (GPA < 3.5)
>
> cout << "Try harder" << endl; else if (GPA < 4.0)
>
> cout << "You made the dean's list" << endl; else cout
> << "You made the president's list" << endl;
>
> Th e previous formatting represents the preferred method of this
> textbook. However, you could also use blocks to make multiple
> selection look like this:
>
> if (GPA < 3.5) {
>
> cout << "Try harder" << endl;
>
> }

7.7: Multiple Selection

> else if (GPA < 4.0) {
>
> cout << "You made the dean's list" << endl;
>
> } else {
>
> cout << "You made the president's list" << endl; }

7.7.1 ANOTHER EXAMPLE: DETERMINING LETTER GRADES

> Some instructors use a scale like the following to determine the
> proper letter grade to assign to a student. Th e letter grade is based
> on a percentage representing a weighted average of all work for the
> term.
>
> ![](media/image15.png){width="2.120138888888889in"
> height="1.1569444444444446in"}Value of Percentage (should be in the
> range

A function could be implemented with if statements that begin like this:

> if ( percentage >= 90.0) result = "A";
>
> if ( percentage >= 80.0 && percentage < 90 ) // Not necessary
> result = "B";
>
> if ( percentage >= 70.0 && percentage < 80 ) // Not necessary //
> . . .
>
> However, when given the problem of choosing from among fi ve diff
> erent actions, try to remember that the choice is Multiple Selection,
> not Guarded Action. Th e preferred Multiple Selection is also more
> effi cient at runtime. Th e Multiple Selection pattern is also less
> prone to intent errors.
>
> string letterGrade(double percentage) {
>
> // pre: percentage >= 0.0 && percentage <= 100.0
>
> // post: Return letter grade according to external documentation
> string result; // Determine the proper result . . .
>
> if (percentage >= 90.0) result = "A"; else if (percentage >=
> 80.0) result = "B"; else if (percentage >= 70.0) result = "C";
>
> else if (percentage >= 60.0) result = "D"; else result = "F";
>
> return result; }
>
> Here, the output depends on the value of percentage. If percentage is
> greater than or equal to 90.0, then the statement result = "A";
> executes. Th e program skips over all other statements after the fi
> rst else. If percentage == 50.0, then all logical expressions are
> false and the program executes the action after the fi nal else:
> result = "F";.
>
> When percentage has a value between 60.0 and 90.0, logical expressions
> evaluate until the fi rst one that is true. When percentage >= 90.0
> is false, the opposite logical expression, percentage < 90.0, must
> be true. Th e second logical expression, percentage >= 80.0,
> evaluates when the fi rst expression is false. When the fi rst true
> logical expression is fi nally encountered, the very next true part
> executes and the program skips over the remaining alternative(s). Th
> is function could be improved by ensuring that letter grades are
> returned only when percentage is within the range of 0.0 through 100.0
> inclusive. Th ere is a possibility, for example, that an argument will
> be passed as 777 instead of an intended input of 77. Since 777 >=
> 90.0 is true, the function improperly returns "A" when "C" would have
> been the correct result. letterGrade could be modifi ed to contain a
> test for out-of-range input. Th is fi rst logical expression now
> checks to see if percentage is either less than 0.0 or greater than
> 100.0.
>
> if ((percentage < 0.0) ¦¦ (percentage > 100.0)) result =
> "\*\*Error--Percentage is not in range \[0...100\]"; else if
> (percentage >= 90) result = "A";
>
> If percentage is out of range, the result becomes an error message and
> the program skips over the remainder of the nested if...else
> structure. Rather than returning an incorrect letter grade for
> percentages less than 0 or greater than 100, this string is returned
> instead for the argument 777:
>
> \*\*Error--Percentage is not in range \[0...100\]

7.7.2 MULTIPLE RETURNS

> Th e previous implementation of letterGrade shows that the proper
> letter grade is fi rst assigned to the local object named result.
> Another implementation option uses multiple return statements. Th e fi
> rst time any return statement executes, the function terminates. Th
> erefore, a function could be written with many return statements:
>
> string letterGrade(double percentage) { if (percentage >= 90)
> return "A";

7.8: Testing Multiple Selection

> if (percentage >= 80) return "B"; if (percentage >= 70) return
> "C"; if (percentage >= 60) return "D"; if (percentage >= 0)
>
> return "F"; // ERROR: runtime error when percentage < 0 }
>
> If you do use the technique of multiple returns, ensure that something
> is always returned. For example, the previous code will not return
> anything for arguments that are less than 0.0. Th is code might cause
> a warning or a compile time error. Worse, some systems will wait until
> it is too late and generate a runtime error. Th e problem goes away
> when the block ends like this instead:
>
> // . . .
>
> if (percentage >= 0) return "F";
>
> return "Error: argument to letterGrade < 0"; }
>
> And while you’re at it, consider returning an error message when
> percentage > 100 if that would in fact be an error.

7.8 TESTING MULTIPLE SELECTION

> Consider how many function calls should be made to test the
> letterGrade function with Multiple Selection—or for that matter, any
> function or segment of code containing Multiple Selection. To test
> this particular example to ensure that Multiple Selection is correct
> for all possible percentage arguments, the function could be called
> with all numbers in the range from -1.0 through 101.0. However, this
> would require a virtually infi nite number of function calls. Th is is
> unnecessary!
>
> First consider a set of test data that executes every possible branch
> through the nested if...else. Branch coverage testing occurs by
> observing what happens when each and every statement (the true or
> false part) of a nested if...else executes once. Th ese three things
> are necessary to correctly perform branch coverage testing:

-   Establish a set of data that executes all branches of the
    > Multiple Selection.

-   Execute the portion of the program containing the Multiple Selection
    > for all selected data values. Th is can be done with a
    > test driver.

-   Observe that the program segment behaves correctly for all
    > data values.

-   For example, the following data set executes all branches of
    > letterGrade:

-1.0 55.0 65.0 75.0 85.0 95.0 101.0

> A test driver could start like this:
>
> int main() {
>
> cout << "-1.0 = " << letterGrade(-1.0) << endl; cout
> << "55.0 = " << letterGrade(55.0) << endl; cout
> << "65.0 = " << letterGrade(65.0) << endl; // . . .
>
> and then the program output must be examined to indicate that every
> function call returned the proper value:
>
> -1.0 = \*\*Error--Percentage is not in range \[0...100\]
>
> 55.0 = F
>
> 65.0 = D
>
> . . .

7.8.1 BOUNDARY TESTING

> Boundary testing occurs by observing what happens for each cut-off
> (boundary) value. Th is extra eff ort could go a long way. For
> example, boundary testing avoids situations where students with 90 are
> accidentally shown to have a letter grade of B rather than A. Th is
> would occur when the logical expression (percentage >= 90) is
> accidentally coded as (percentage > 90). Th e arguments of 60, 70,
> 80, and 90 complete boundary testing of the code above.
>
> Perhaps the best testing strategy is to select test values that
> combine branch and boundary testing at the same time. For example, a
> percentage of 90.0 should return A. Th e value of 90 not only checks
> the path for all; it also tests the boundary—90.0 is the cut-off .
> Counting down by tens to 60 checks all boundaries. But it misses one
> path: the one that sets result to F. Adding 59.9 completes the test
> driver.
>
> int main() {
>
> // A test driver for string letterGrade(double percentage) cout
> << "90.0? " << letterGrade(90.0) << endl; // 90.0? A
> cout << "80.0? " << letterGrade(80.0) << endl; //
> 80.0? B cout << "70.0? " << letterGrade(70.0) <<
> endl; // 70.0? C cout << "60.0? " << letterGrade(60.0)
> << endl; // 60.0? D cout << "59.9? " <<
> letterGrade(59.9) << endl; // 59.9? F return 0; }

7.9 THE ASSERT FUNCTION

> So far testing has been done by printing things with cout. Th is
> requires a careful inspection of the cout statements and the
> associated output. Placing the expected output on the same line, as is
> done above with letterGrade, can help. Th e expected and actual values
> are right next to each other. If they do not match, then either the
> expected value is incorrect, the return value is incorrect, or perhaps
> both. Th e C++ assert function can also be used to test where the
> expected value is next to the function call or message.

7.9: The Assert Function

> Th e assert function takes a bool argument. If the argument is false,
> C++ will inform you with a line of output that begins with Assertion
> failed. In this case, assert will terminate the program.
>
> If all expressions in all calls to the function are true, there is
> *no* output. So if you write your tests with assert functions, you
> only have to look at output when something has gone wrong. Th e
> following main function represents a test of letterGrade that is
> equivalent to the version above with fi ve cout statements. Getting no
> output means the assertions all passed—there were no detected errors
> when comparing the expected values like "A" with the actual return
> values like letterGrade(90.0).
>
> /\*

-   Test letterGrade using assert

> \*

-   File name: main.cpp

> \*/
>
> \#include <cassert> // Required for the assert function
>
> \#include <string> using namespace std;
>
> string letterGrade(double percentage) {
>
> // pre: percentage >= 0.0 && percentage <= 100.0
>
> // post: Return letter grade according to external documentation
> string result; if (percentage >= 90.0) result = "A"; else if
> (percentage >= 80.0) result = "B"; else if (percentage >= 70.0)
> result = "C"; else if (percentage >= 60.0) result = "D"; else
> result = "F"; return result; }
>
> int main() {
>
> assert("A" == letterGrade(90.0)); assert("B" == letterGrade(80.0));
> assert("C" == letterGrade(70.0)); assert("D" == letterGrade(60.0));
> assert("F" == letterGrade(59.9)); }
>
> Th e preceding code will have no output. Changing the "C" to a "D"
> will make the expression false in this call to the assert function:
>
> assert("D" == letterGrade(70.0));
>
> Now we get this output from assert indicating the assertion failed.
> You even get the line number and the fi le name where the assertion
> failed:
>
> Output

Assertion failed: ("D" == letterGrade(70.0)), function main, le
main.cpp, line 32.

> Th is method of testing is suggested for the programming projects at
> the end of this chapter. Th ere are several functions that have many
> branches. Th e assert function makes testing easier.

SELF-CHECK

> 7-15 Which value of percentage would detect the intent error in the
> following code?
>
> if (percentage >= 90) result = "A"; else if (percentage >= 80)
> result = "B"; else if (percentage > 70) result = "C"; else if
> (percentage >= 60) result = "D"; else result = "F";
>
> 7-16 What string is incorrectly assigned to letterGrade for the value
> of percentage you answered above?
>
> 7-17 Would you be happy with the result if your grade were computed
> with this argument?
>
> 7-18 Using the nested structure below, write the return value for each
> of these six diff erent arguments for weather: -40 20 -1 42 15 31
>
> string weather(int temp) { if (temp <= -40) return "extremely
> frigid"; else if (temp < 0) return "below freezing"; else if (temp
> < 20) return "freezing to mild"; else if (temp < 30) return
> "warm"; else if (temp < 40) return "very hot"; else
>
> return "toast"; }
>
> 7-19 List the range of integers that would cause the previous program
> to display warm.

7.10: The switch Statement

> 7-20 List the range of integers that would cause the previous program
> to display below freezing.
>
> 7-21 Write a test for weather that uses the assert function to
> completely test this free function.

7.10 THE switch STATEMENT

> Th e C++ switch statement also implements the Multiple Selection
> pattern. Although nested if...else statements can do anything the
> switch statement does, it is included here because you will see it in
> other C++ programs and because some programmers prefer this
> implementation of Multiple Selection.
>
> General Form 7.3 *Th e C++* switch *statement*
>
> switch (*switch-expression*) { case *constant-value-1*:
> *statement(s)-1*; break ; case *constant-value-2*: *statement(s)-2*;
> break ; ... case *constant-value-n*: *statement(s)-n*; break ; default
> :
>
> *default-statement(s)*;
>
> }
>
> When a switch statement is encountered, the switch-expression is
> compared to *constant-value-1*, *constant-value-2*, through
> *constant-value-n* until a match is found. When the switch expression
> matches one of these values, the statements following the colon
> execute. If no match is made, the statement(s) after default execute.
>
> Th e keyword default needs to be present only if some processing is
> desired whenever the switch expression cannot match any of the case
> values. With no default, it is possible that no statements will
> execute inside the switch statement. Sometimes that is the appropriate
> design. Th e following switch statement chooses one of three paths
> based on the input value of option. If the user enters 1, the fi rst
> case section of code is executed. Th e fi rst break terminates the
> switch statement.
>
> int option = 0;
>
> cout << "Enter option 1, 2, or 3: "; cin >> option;
>
> switch(option) { case 1:
>
> cout << "option 1 selected" << endl; break; case 2: cout
> << "option 2 selected" << endl; break; case 3: cout
> << "option 3 selected" << endl; break; default:
>
> cout << "option < 1 or option > 3" << endl; } // End
> switch
>
> If neither 1, 2, nor 3 are entered, the statement(s) after default:
> execute.
>
> Th e switch expression (option above) and each constant value (1, 2,
> and 3 above) after case must be compatible. In fact, the constants
> must be one of the C++ integral types, which consist of the integer
> types (int, long, and so on) or char—the class discussed in the next
> section. Th e break statement—a new reserved word—causes an exit from
> the control structure the program is executing. Th e break statement
> at the end of each case section causes a jump out of the switch
> statement. In fact, the switch statement typically requires many break
> statements. Th ey avoid unintentional execution of the remaining
> portions of the switch statement.

7.10.1 char OBJECTS

> Th e char class of objects is an integral type often used as the
> constant value in switch statements.
>
> A char object stores one character constant—a character between single
> quotes (apostrophes):
>
> 'A' 'b' '?' '8' ' ' ','
>
> Th ere are several special escape sequences—a backward slash (\\)
> followed by one of a select few characters that have special meaning
> (see the following table).

  **Escape Sequence**   **Meaning**
  --------------------- ------------------------
  '\\n'                 new line
  '\\"'                 double quote in a char
  '\\''                 single quote in a char
  '\\\\'                one backward slash
  '\\t'                 tab

> char objects are declared, initialized, assigned values, and displayed
> in the same way as the other fundamental types like int.
>
> // Use some char objects
>
> \#include <iostream> using namespace std;

7.10: The switch Statement

> int main() {
>
> // Declare and initialize some char objects char one, two; char
> letterGrade = 'A'; char newLine = '\\n';
>
> // Assignment is possible with character expressions one = 'T'; two =
> 'o';
>
> // Output some char objects, char constants, and escape sequences cout
> << "letterGrade is " << letterGrade << endl; cout
> << one << two << newLine << one << '\\t'
> << two << endl; cout << '\\"' << 'A' <<
> ' ' << '\\\\' << ' ' << 'S' << 't' <<
> 'r' << 'i' << 'n' << 'g' << '?' << '\\''
> << endl;
>
> return 0; }
>
> Output
>
> letterGrade is A
>
> To
>
> T o
>
> "A \\ String?'
>
> Th e char type has its own set of nonmember functions included in
> cctype. For example, the toupper function returns 68, which is the
> ASCII (numeric) code for the uppercase equivalent of its argument. If
> you want to see the actual character, typecast with char() to see the
> ‘D’:
>
> cout << toupper('d') << endl; // Output: 68 cout <<
> char(toupper('d')) << endl; // Output: D
>
> Here is a switch statement that uses characters as the constant
> expressions. It chooses one of fi ve paths based on the value of the
> char object option:
>
> // Illustrate another switch statement
>
> \#include <iostream> // For cout << using namespace std;
> \#include <cctype> // For toupper(char) returns uppercase char
>
> int main() { char option;
>
> cout << "B)alance W)ithdraw D)eposit Q)uit: "; cin >>
> option; switch(toupper(option)) { case 'B': cout << "Balance
> selected" << endl; break; case 'W': cout << "Withdraw
> selected" << endl; break; case 'D':
>
> cout << "Deposit selected" << endl; break; case 'Q': cout
> << "Quit selected" << endl; break; default:
>
> cout << "Invalid choice" << endl; } // End switch
>
> return 0; }
>
> One Possible Dialogue
>
> B)alance W)ithdraw D)eposit Q)uit: ***D***
>
> Deposit selected
>
> If the value extracted for option is B, the message Balance selected
> is output and break is executed to exit the switch control structure.
> If Q or q is input, Quit selected is output and another break is
> executed. In this example, each case is evaluated until option is
> matched to one of the four char values following case. If option is
> any other value, the message Invalid choice is displayed.
>
> One fi nal comment on the switch statement: don’t forget to include
> the optional break statements in the case portions of switch. Failure
> to break out of the switch causes all remaining statements to execute.
> Although this may be what you want in some unusual circumstance, it is
> usually not a good idea to forget the breaks. For example, imagine the
> preceding switch with all break statements removed:
>
> switch(toupper(option)) { case 'B':
>
> cout << "Balance selected" << endl; case 'W':
>
> cout << "Withdraw selected" << endl; case 'D':
>
> cout << "Deposit selected" << endl; case 'Q':
>
> cout << "Quit selected" << endl; default:
>
> cout << "Invalid choice" << endl; } // End switch
>
> Now when B is input, every statement executes—including the default!
>
> B)alance W)ithdraw D)eposit Q)uit: ***B***
>
> Balance selected
>
> Withdraw selected
>
> Deposit selected
>
> Quit selected Invalid choice

Chapter Summary

SELF-CHECK

> 7-22 Write the output produced by this switch statement:

char option = 'A';

> switch(option) { case 'A': cout << "AAA";
>
> break; case 'B':

cout << "BBB";

> break; default:
>
> cout << "Invalid";
>
> }
>
> 7-23 What is the output from the code above when option is B? 7-24
> What is the output from the code above when option is C?
>
> 7-25 What is the output from the code above when option is D?
>
> 7-26 Write a switch statement that displays your favorite music if the
> int object choice is 1, your favorite food if choice is 2, and your
> favorite instructor if choice is 3. If the option is anything else,
> display Error. Don’t forget the break statements.

CHAPTER SUMMARY

-   Selection requires logical expressions that evaluate to true
    > or false. Th e logical expressions usually have one or more of the
    > following relational, equality, or logical operators:

< > <= >= != == ! ¦¦ &&

-   Th e Guarded Action pattern is implemented with the if statement
    > that either executes a collection of statements or skips them
    > depending on the circumstances.

-   Th e Alternative Action pattern, implemented with the C++ if...else
    > statement, is used to choose one action or its
    > alternative—two choices.

-   Multiple Selection can be implemented with nested if...else
    > statements or with the switch statement. Multiple Selection should
    > be used whenever there are three or more actions to select from.

-   Selection control allows the program to respond to a variety of
    > situations in an appropriate manner.

-   Th e bool class and the bool constants true and false are sometimes
    > used as the return type of a function to conveniently return
    > information about the state of an object. Is the book available?
    > Was the withdraw message successful or not? Are there real roots
    > to this equation?

-   Several examples of Multiple Selection showed the need for
    > thorough testing.

-   When implementing the Multiple Selection pattern, be sure to
    > thoroughly test the code with the Multiple Selection. Establish a
    > set of data that executes all branches and tests all
    > cut-off (boundary) values.

-   Without thorough testing, a program may only appear to work when in
    > fact there is perhaps one value among thousands that does
    > not work.

EXERCISES

1.  True or False: When an if statement is encountered, the *true-part*
    > always executes.

2.  True or False: When an if or if...else statement is encountered,
    > valid logical expressions are evaluated to either true, false,
    > or maybe.

3.  Proper indentation and spacing improve readability. Th e next code
    > segment is an example of poor indentation; try to predict
    > the output.

> int j=123;if (j>=0)if (0==j)cout<<"one";else
> cout<<"two";else cout<<"three";

1.  Write the output from the following code fragments:

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  a.   double x = 4.0; if (10.0 == x) cout << "is 10"; else                                                    c.   int j = 0, k = 1; if (j != k) cout << "abc"; if (j == k) cout << "def";
                                                                                                                          
       cout << "not 10";                                                                                            (j <= k) cout << "ghi"; if (j >= k) cout << "klm";
  ---- ------------------------------------------------------------------------------------------------------------- ---- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  b.   string s1 = "Ab"; string s2 = "Bc"; if (s1 == s2) cout << "equal"; if (s1 != s2) cout << "not";   d.   double x = -123.4, y = 999.9; if (x < y) cout << "less "; if (x > y) cout << "greater "; if (x == y) cout << "equal "; if (x != y) cout << "not eq. ";
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  Write the output from the following code fragments:

    a.  string name = "Parker"; if (name >= "A" && name <= "F")
        > cout << "A..F"; if (name >= "G" && name <= "N")
        > cout << "G..N"; if (name >= "O" && name <= "T")
        > cout << "O..T"; if (name >= "U" && name <= "Z")
        > cout << "U..Z";

    b.  int t1 = 87, t2 = 76, larger = 0;

> if (t1 > t2) larger = t1; else larger = t2;

cout << "larger: " << larger;

Exercises

a.  double x1 = 2.89; double x2 = 3.12;

if (fabs(x1 - x2) < 1)

cout << "true";

else

cout << "false";

1.  Write the output generated from the following program fragments,
    > assuming j and k are int objects with the values 25 and
    > 50, respectively.

> int j = 25; int k = 50;

  ---------------------------------------------------------------------------------------------------------------------------------------
  a.   > if (j == k) cout << j; cout << k;                   c.   > if (j > k || k < 100) cout << "THREE"; else
                                                                              >
                                                                              > cout << "FOUR";
  ---- ----------------------------------------------------------------- ---- -----------------------------------------------------------
  b.   > if (j <= k && j >= 0) cout << "ONE" << else   d.   > if (j >= 0 && j <=100) cout << "FIVE"; else
       >                                                                      >
       > cout << "TWO";                                                 > cout << "SIX";
  ---------------------------------------------------------------------------------------------------------------------------------------

1.  Write a statement that displays YES if intObject is positive, NO if
    > intObject is negative, or NEUTRAL if intObject is zero.

2.  Write a statement that will add 1 to the int object j only when the
    > int object counter has a value less than the int object n.

3.  Write a statement that displays Hello if the int object hours has a
    > value less than 8, or Goodbye if hours has any other value.

4.  Write a program fragment that guarantees that the int object amount
    > is even. If amount is odd, increment amount by 1.

5.  Write a program segment that adds 1 to the int object amount if
    > amount is less than 10. In this case, also display Less than 10.
    > If amount is greater than 10, subtract 1 from amount and display
    > Greater than 10. If amount is 10, just display Equal to 10.

6.  Write an expression that is true if and only if the mover in the
    > Grid object myGrid is on one of the four corners of the Grid.

7.  Write function inc3 that increments all three arguments associated
    > with the parameters by 1.0. Th e following function call must
    > change the objects as shown.

> double x = 0.0, y = 0.0, z = 0.0; inc3(x, y, z);

// assert x, y, and z all equal 1.0.

1.  Implement function bool turnTillClear(Grid & grid) that faces the
    > mover in the fi rst direction that has a clear front (like the
    > mover in the left column below). In this case, return true. Return
    > false when the mover is surrounded as shown with the Grid on
    > the right.

> The grid:The grid:
>
> . . . . . . . . . .. . . \# \# \# . . . .
>
> . . . \# < . . . . .. . . \# < \# . . . . . \# \# \# \# \# \# \#
> \# .. \# \# \# \# \# \# \# \# . mover turns left twicemover is trapped
>
> The grid:The grid:
>
> . . . . . . . . . .. . . \# \# \# . . . .
>
> . . . \# > . . . . .. . . \# \^ \# . . . . . \# \# \# \# \# . . . .
> . \# \# \# \# \# \# \# \# .

1.  Write the output from the following program when:

  a\. choice = 3   c\. choice = 2
  ---------------- ----------------
  b\. choice = 1   d\. choice = 0

> \#include <iostream> using namespace std; int main() {
>
> int choice = 3; // Change 3 to 1, 2, and then 0 switch(choice) { case
> 1: cout << "1 selected" << endl; break; case 2: cout
> << "2 selected" << endl; break; case 3: cout << "3
> selected" << endl; break; default:
>
> cout << "Invalid choice" << endl;
>
> } // End switch return 0; }
>
> PROGRAMMING TIPS

1.  Take notice of the diff erence between = and ==. = assigns and
    > == compares. It is very easy, even natural, to write = instead
    > of ==. Th e following code will always execute the true part
    > because grade = 100 returns 100, which is nonzero, which is true.

Programming Tips

> if (grade = 100) cout << "another perfect score" << endl;
> else
>
> cout << "this never ever executes" << endl;

Perhaps this is the most famous C++ “gotcha”: using = instead of == in
an if statement.

1.  Test drivers help protect against errors. Use test drivers with many
    > calls to the function containing the Multiple Selection. Send
    > arguments that check all boundary values. Send arguments that
    > ensure that each branch executes at least once.

2.  Th e compound statement may be used even if it is not required.
    > Consider always using curly braces to mark the beginning and end
    > of the true part and the false part of an if...else. You *must*
    > use the block to treat several statements as one. You *may* use
    > the block for readability and to help avoid bugs.

3.  Th e way a mathematician writes an expression does not always work
    > in C++. It is easy, even natural, to write the following code that
    > checks to see if a value is in a certain range:

> int x = 2222; if ( 0 <= x <= 100 ) { cout << x << "
> is in the range of 0 through 100" << endl;
>
> }
>
> If you’re lucky, you will get a warning on a compiler. However, in
> either case, the code compiles and runs. Th en when x is 2222, you get
> this output indicating an intent error:

2222 is in the range of 0 through 100 // Wrong

Th at’s because the logical expression evaluates like this:

> if ( 0 <= x <= 100 ) 0 <= 222 <= 100
>
> true <= 100 // True is like 1 and 1 <= 100 is true true

1.  Short circuit evaluation makes programs more effi cient and comes in
    > handy sometimes. Short circuit Boolean evaluation is always in eff
    > ect to make programs run more quickly, especially when millions of
    > comparisons are made. You might fi nd that fact
    > useful occasionally. One particular algorithm in a later chapter
    > uses short circuit evaluation to avoid runtime errors.

2.  Don’t forget to use the break statement to terminate
    > switch statements. C++ executes all code to the bottom of the
    > switch or until the fi rst break is encountered. Th e following
    > code works correctly when option == 'W'. On the other hand, when
    > option == 'B', both options execute as shown in the
    > accompanying output.

> switch(option) { case 'B':
>
> cout << "Balance selected" << endl; case 'W':
>
> cout << "Withdraw selected" << endl;

}

> **Output** (when option == 'B'**)**
>
> Balance selected
>
> Withdraw selected

PROGRAMMING PROJECTS

7A A HALF-DOZEN SELECTION METHODS

> Write one C++ program where your main method is a test driver of your
> own design that tests six new free functions implemented in the same
> fi le. You may write your own tests with assert functions.
>
> /\*

-   A test driver like this may be used to test the functions

> \*

-   File name: TestSelectionFunctions (on the book's website)

> \*/ int main() {
>
> // Test isEven assert(isEven(-2)); assert(isEven(0));
> assert(isEven(2)); assert( ! isEven(-1)); assert( ! isEven(1)); // . .
> . many more asserts are available

1.  bool isEven(int number)

> Complete the free function isEven to return true if the integer
> argument is an even number.
>
> isEven(-2) returns true isEven(0) returns true isEven(2) returns true
> isEven(-1) returns false isEven(1) returns false

1.  int largest(int a, int b, int c)

> Complete the free function largest to return the largest of three
> integers.
>
> largest(2, 4, 6) returns 6 largest(1, 2, 2) returns 2 largest(-5, -2,
> -7) returns -2

1.  string rstOf3Strings(string a, string b, string c)

> Complete the free function rstOf3Strings to return a reference to the
> string that is not “greater than” the other two. Th is is the string
> that alphabetically precedes, or is equal to, the other two arguments.
> Use the relational operator to compare strings. Note: "abc" < "abc
> " and "A" < "a".
>
> rstOf3Strings("c", "b", "a") returns "a"
>
> rstOf3Strings("B", "B", "a") returns "B"
>
> rstOf3Strings("ma", "Ma", "ma") returns "Ma"
>
> rstOf3Strings("x ", "x ", "x ") returns "x "

1.  string letterGrade(double numericGrade)

> Complete the free function letterGrade that returns the proper letter
> grade as a string for a plus/minus system with the following scale:
>
> Percentage

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  93.0 ≤ percentage                                                                                                                                                                              A
                                                                                                                                                                                                 
  90.0 ≤ percentage < 93.0                                                                                                                                                                    A.  B+
                                                                                                                                                                                                 
  87.0 ≤ percentage < 90.0 83.0 ≤ percentage < 87.0 80.0 ≤ percentage < 83.0 77.0 ≤ percentage < 80.0 70.0 ≤ percentage < 77.0 60.0 ≤ percentage < 70.0 percentage < 60.0   B
                                                                                                                                                                                                 
                                                                                                                                                                                                 A.  C+
                                                                                                                                                                                                 
                                                                                                                                                                                                 C
                                                                                                                                                                                                 
                                                                                                                                                                                                 D
                                                                                                                                                                                                 
                                                                                                                                                                                                 F
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- --------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

> After implementing the function, perform branch and boundary testing.
> If the argument is a value outside the range of 0.0 through 100.0,
> return "Unkown" as the string letter grade.

5\. double salary(double sales)

> Complete the free function salary that returns a salesperson’s salary
> for the month according to the following policy:

Sales Over But Not Over Monthly Salary

0 \$10,000 Base salary

\$10,000 \$20,000 Base salary plus 5% of sales over \$10,000

\$20,000 \$30,000 Base salary plus \$500.00 plus 8% of sales over
\$20,000

\$30,000 Base salary plus \$1300.00 plus 12% of sales over \$30,000

> Th e base salary is \$1,500.00, which means salary returns a value
> that is never less than 1500.00.
>
> When sales are over \$10,000, commission is added to the base salary.
> For example, when sales equals 10001, the monthly salary is \$1,500.00
> + 5% of \$1.00 for a total of \$1,500.05, and when sales is 20001, the
> monthly salary is \$1,500.00 + \$500.00 + 8% of \$1.00 for a total of
> \$2,000.08.

6\. int romanNumeral(char numeral)

> Complete the free function romanNumeral that returns the numeric
> equivalent of an upper- or lowercase Roman numeral, which is actually
> a char. Roman numerals and their decimal equiva-
>
> lents are ‘I’ (or ‘i’) = 1, ‘V’ (or ‘v’) = 5, ‘X’ (or ‘x’) = 10, ‘L’
> (or ‘l’) = 50, ‘C’ (or ‘c’) = 100, ‘D’ (or ‘d’) = 500, and ‘M’ (or
> ‘m’) = 1,000. If the input is not a valid Roman numeral, return -1.
>
> romanNumeral('i') returns 1 romanNumeral('I') returns 1
> romanNumeral('v') returns 5 romanNumeral('X') returns 10
> romanNumeral('L') returns 50 romanNumeral('c') returns 100
> romanNumeral('D') returns 500 romanNumeral('m') returns 1000

7B A HALF DOZEN CALENDAR FUNCTIONS

> Write one C++ program where your main method is a test driver of your
> own design that tests six new free functions implemented in the same
> fi le. You may write your own tests using output statements or
> asserts.
>
> /\*

-   A test driver like this may be used to test the functions

> \*

-   File name: TestCalendarFunctions (on the book's website)

> \*/ int main() {
>
> // Test isLeapYear assert(isLeapYear(2016)); assert(isLeapYear(2020));
> assert( ! isLeapYear(2019)); assert( ! isLeapYear(2100));

1.  bool isLeapYear(int year)

> Complete the free function isLeapYear that returns true if the integer
> argument represents a leap year in which February has 29 days instead
> of 28 days. Th is is done because there are actually close to 365.25
> days in a year. A leap year is a year after 1582 that is evenly
> divisible (no remainder after division) by four unless it is the end
> of a century. In this case—where the year is also evenly divisible by
> 100—year must also be divisible by 400. For example, 2000 and 2400 are
> leap years but 1900 and 2100 are not. Let leapYear return true if the
> argument represents a leap year or false if it does not.
>
> isLeapYear(1580) returns false isLeapYear(1584) returns true
> isLeapYear(2020) returns true isLeapYear(-2020) returns false
> isLeapYear(2100) returns false

1.  string day(int dayOfWeek)

> Complete the free function dayOfWeek that returns the string "Monday"
> if the int argument passed to the parameter dayOfWeek is 1, returns
> "Tuesday" for the argument 2, and so on up through returning "Sunday"
> if the argument is 7. Return "Unknown" if the argument is not in the
> range of 1 through 7.
>
> dayOfWeek(0) returns "Unknown" dayOfWeek(3) returns "Wednesday"
> dayOfWeek(4) returns "Thursday" dayOfWeek(6) returns "Saturday"
> dayOfWeek(8) returns "Unknown"

1.  int daysInMonth(int month, int year)

> Complete the free function daysInMonth that returns the number of days
> in a month for the given year. Th ere are 30 days in the months
> September, April, June, and November, or months 9, 4, 6, and 11.
> February has 28 days unless it is a leap year, when it has 29. All
> other months—1, 3, 5, 7, 8, 10, and 12 (December)—have 31 days. Assume
> the year is always >= 1582. You may use your own existing method
> isLeapYear. Return -1 if month is not in the range of 1 through 12.
>
> daysInMonth(1, 2020) returns 31 daysInMonth(2, 2020) returns 29
> daysInMonth(2, 2019) returns 28 daysInMonth(0, 2019) returns -1
> daysInMonth(13, 2019) returns -1

1.  int thanksDate(int rstDay)

> In the U.S., Th anksgiving falls on the fourth Th ursday of each
> November. Complete method thanksDate that determines the day of the
> month upon which Th anksgiving falls, no matter which day November
> begins on. November can begin on any day where 1 represents Monday,
> through 7, which represents Sunday. A valid call would be
> thanksDate(2) to indicate the fi rst day of November is Tuesday.
> thanksDate should then return the day of the month upon which Th
> anksgiving falls, which is 24 (as shown in the calendar below).
> Arguments can only be 1 (for Monday) through 7 (for Sunday). If the
> argument is out of the range of 1 through 7, return -1.
>
> thanksDate(2) returns 24 // 1-Nov is Tue thanksDate(5) returns 28 //
> 1-Nov is Fri thanksDate(7) returns 26 // 1-Nov is Sun

  -----------------------------------------------
  > **November**
  -----------------------------------------------
  **Su Mo Tu We Th Fr Sa**

  **1 2 3 4 5**

  **6 7 8 9 10 11 12**

  **13 14 15 16 17 18 19 20 21 22 23 24 25 26**

  **27 28 29 30**
  -----------------------------------------------

1.  bool validDate(string date)

> Write free function validDate to return true if the string argument is
> a valid calendar date. Th e arguments always take the form of month,
> day, and year as positive integers separated by / as in "mm/dd/yyyy".
> If the string argument does not express a proper date, return false.
> You will need the free function std::**stoi**(string possibleInt)
> (**s**tring **to i**nteger) that returns the integer value of the
> string argument with the precondition that the string argument is a
> valid integer. For example, str("08") returns 8 and str("2021")
> returns 2021.
>
> validDate("01/31/2016") returns true validDate("12/31/2017") returns
> true validDate("06/15/2018") returns true validDate("02/28/2019")
> returns true validDate("02/29/2019") returns false
> validDate("2019/06/06") returns false

1.  int dayNumber(string date)

> Write free function dayNumber to return how many days a valid date is
> into the year. If the string argument is not a valid date, return -1.
>
> dayNumber("01/03/2016") returns 3 dayNumber("12/31/2017") returns 365
> dayNumber("12/31/2020") returns 366 dayNumber("13/11/2020") returns -1

7C CLASS STUDENT

> Given header fi le Student.h below, implement the member functions in
> a new fi le named Student.cpp for class Student such that they satisfy
> all postconditions in the class defi nition (shown below). Use this
> table to satisfy the postconditions of Student::standing:

  ----------------------------------------------------------------
                                         string **Return Value**
  -------------------------------------- -------------------------
  > Less than 30 credits                 "Freshman"
  >                                      
  > 30 credits to less than 60 credits   "Sophomore"
  >                                      
  > 60 credits to less than 90 credits   "Junior"
  >                                      
  > 90 credits or more                   "Senior"
  ----------------------------------------------------------------

> /\*

-   De ne a Student type that knows its GPA and class standing.

> \*

-   File name: Student.h

> \*/
>
> \#include <string>
>
> class Student { public:
>
> Student(std::string initName, double initCredits, double
> initQualityPoints); // post: Initialize a student with a 3 argument
> constructor // Student s("Ryan", 30.0, 120.0); // Straight A
> sophomore.
>
> void completedCourse(double credits, double numericGrade); // post:
> Record a completed course by adding credits to credits // and
> incrementing the qualityPoints by credits\*numericGrade.
>
> // aStudent.completedCourse(4.0, 3.67) is a 4 credit A-
>
> double getGPA() const; // post: return the current grade point
> average.
>
> std::string getStanding() const; // post: use selection to return the
> current standing as either
>
> // Freshman, Sophomore, Junior, or Senior.
>
> std::string getName() const; // post: return the student's name
>
> private:
>
> std::string name;
>
> double credits; // Total credits completed
>
> double qualityPoints; // sum of credits multiplied by grades };
>
> Implement the methods in Student.cpp along with your own test driver.
> Construct at least four students at the cutoff s for the standings.
> Make sure you send every possible message to one or more objects.

7D EMPLOYEE OVERTIME PAY AND FEDERAL INCOME TAX

> To complete this project, fi rst complete class Employee from the
> Chapter 6 programming projects. Th is project asks you to make these
> three changes to the specifi cation in the previous chapter.

1.  Now that Chrystal Bends, Inc. has interstate commerce, employees are
    > entitled to 1.5 times their rate of pay for any hours worked over
    > 40.00 in the week. For example, someone working 42 hours a week at
    > \$10.00 per hour would have a gross pay of

> 40 \* 10.00 + 2 \* 15.00 = 430.00. Change getGrossPay method to allow
> overtime pay.

1.  Add method getIncomeTax to compute how much to withhold for this tax
    > on the paycheck.

2.  Add two data members, one to store marital status as either "S" for
    > single or "M" for married and another data member to store the
    > number of withholding allowances such as 1 through 99. Modify the
    > constructor to take in these two new arguments. Th is code must
    > compile:

> Employee we("Peyton", 9.70, "S", 2); cout << we.getIncomeTax()
> << endl;
>
> Fully test your two new methods, especially getIncomeTax. No one
> should be withholding too much from an employee’s paycheck. Perhaps
> more importantly, no one should withhold too little federal income tax
> per week. Employees might have to pay fi nes or even go to jail for
> withholding too little each week. You will need many getIncomeTax
> messages with a lot of categories for both single and married
> employees. Th ere are 14 total income tax withholding categories for a
> weekly payroll period, and you are required to use the Percentage
> Method Tables of IRS Publication 15 (Circular E) Employer's Tax Guide
> to determine these categories. Th e percentage method from the IRS
> Employer's Tax Guide is summarized in the following section:

THE PERCENTAGE METHOD FROM THE IRS EMPLOYER'S TAX GUIDE

> Under the percentage method, you will use “TABLE 1—Weekly Payroll
> Period” for the weekly employee payroll period based on the number of
> withholding allowances claimed on the Form W-4 and the amount of
> wages; fi nd the amount of tax to withhold. Use these steps to
> deterimine the income tax to withhold under the percentage method:

1.  Multiply one withholding allowance for your payroll period by the
    > number of allowances the employee claims. One Withholding
    > Allowance = \$76.00.

2.  Subtract that amount from the employee’s gross pay.

3.  Determine the amount to withhold from the appropriate table (see
    > table below).

> Example: An unmarried employee is paid \$600 this week. Th is employee
> has a Form W-4 claiming two withholding allowances. Using the
> percentage method, fi gure the income tax to withhold as follows:

  1\. Total wage payment                                            \$600.00
  ----------------------------------------------------------------- -----------------------------------------------
  2\. One allowance                                                 \$76.90 (changes year to year)
  3\. Allowances claimed on Form W-4                                2
  4\. Multiply line 2 by line 3                                     \$153.80
  5\. Amount subject to withholding (subtract line 4 from line 1)   \$446.20
  6\. Tax to be withheld on from Table:                             \$17.80 + 0.15 × (\$446.20 − \$222) = \$51.43

(2nd row under (a) SINGLE person)

> *Note:* Th e table below has the details for amounts to withhold for
> 2015. For other years, fi nd the IRS Publication 15 for the year in
> question, (Circular E), Employer’s Tax Guide.

© 2018 Franklin, Beedle & Associates All rights reserved
