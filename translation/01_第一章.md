# 第1章 用C++来解决问题

**本章提要**

在本章，我们将会介绍针对一个问题提出计算机解决方案需要做哪些事。首先，我们可能需要用一到两个段落来做一下问题的描述。然后，对于从理解这个问题的描述到具体实现一个可行的计算机解决方案的这个过程，我们就称之为解决问题。接下来，我们将在本章学习以下内容：

* 示范解决问题的过程。
* 介绍算法的特征。
* 介绍如何利用算法模式来辅助程序设计。
* 介绍类与其多个实体对象之间的关系，以及这些对象的名称、状态和操作集。
* 介绍在软件开发的实现阶段中可能出现的错误分类。

*****

## 1.1 解决问题

解决问题的方法有很多种。在本章，我们首先要研究的是一个三步走策略，即分析、设计、实现策略。

| 步骤 | 具体活动 |
|-----|---------|
| **分析** | 理解待解决问题。 |
| **设计** | 根据解决方案的概要设计出算法。|
| **实现** | 写出可执行程序的代码。 |

接下来，我们将通过一个“计算课程成绩”的示例来逐一示范这个三个步走策略中的各个步骤，看看它们在解决问题过程中所发挥的作用，并以此开始《计算基础》这门课的学习。

### 1.1.1 分析（提问、考察、研究）

程序的开发通常始于针对某个问题的研究或分析。这是很显然的，如果我们想要确定一个程序要执行哪些操作，当然先得理解该程序要解决的问题。如果该问题已经完成了书面化描述，我们就可以从阅读这个问题开始进入分析步骤了。

在分析一个问题的过程中，做好对程序所需信息数据的命名工作会是很有帮助的。例如，我们可能会被要求计算出特定飞机在特定气象条件（譬如温度、风向等）下，在指定机场跑到上可以成功起飞时的最大重量。这时，我们就可以在分析问题时将这项要计算的信息命名为`maximumWeight`，并将计算该信息所需的信息命名为`temperature` 、`windDirection`等。

虽然这些数据并不代表整个解决方案，但它们的确表述了问题的某个重要部分。这些数据名称会是我们编写程序，以及在程序中进行计算工作时要用到的符号，譬如可能我们要计算的是飞机在`temperature`的值为19.0时的`maximumWeight`。总而言之，这些数据通常都要经过各种形式的操作或处理之后，才能得到我们所期待的结果。在这其中，有些数据得从用户那里获取，也有些数据得经过一些相乘或相加的运算，还有些数据得在计算机屏幕上显示。

在某些时候，这些数据的值会被存储在计算机的内存中。当程序运行时，相同内存位置上的值是会变化的。另外，这些数据值通常都会有一个类型，譬如整数类型、浮点数类型、字符串类型或其他各种存储类型。对于这种用于在程序运行时存储这些可变值的内存区块，我们称之为*变量*。

我们将会看到这些数据值施以某种特定行为意义的操作，这些特定的意义有助于我们将这些数据区分成由计算机显示的数据——*输出*，和计算出结果所需的数据——*输入*。这些变量帮我们总结出了一个程序必须得做的事情。

* **输入：** 用户在解决问题过程中必须提供的信息。
* **输出：** 计算机必须显示的信息。

通常情况下，我们都可以通过回答“给定输入能得到什么输出？”这个题目来更好地理解自己要解决的问题。因此，针对待解决的问题来进行举例往往是个不错的思路。下面就是两个通过变量名的选择来精准描述其存储值的问题：

| 待解决的问题 | 变量 | 输入/输出 | 问题样例 |
|------------|-----|----------|---------|
| 每月还贷计算 | amount <br> rate <br> months <br> payment | 输入 <br> 输入 <br> 输入 <br> 输出 | 12500.00 <br> 0.08 <br> 48 <br> 303.14 |
| 计算莎士比亚的<br>某指定剧本中<br>某特定词的<br>出现次数 | theWork <br> theWord <br> howOften | 输入 <br> 输入 <br> 输出 | 《无事生非》 <br> thee <br> 74 |

现在来总结一下，我们在分析问题过程中需要：

1. 阅读并理解待解决问题的书面说明。
2. 定义用来表示问题答案的数据，以作为输出。
3. 定义用户为获取问题答案必须要键入的数据，以作为输入。
4. 创建一些问题样例，以作汇总之用（就像上面做的那样）。

当然，教科书上的问题有时会提供清楚的变量名，以及输入/输出时用到的值类型（譬如字符串、整数、浮点数等）。如果没有的话，它们识别起来也往往是相对比较容易的。但在现实中，对于相当规模的问题来说，分析问题这个步骤通常是需要花费大量精力的。

*****

**自检题**

1-1. 请针对英镑与美元之间的汇率转换问题，分别为用于存储用户输入值，以及程序输出值的变量赋予有意义的命名。

1-2. 请针对“从拥有200张CD的播放器中选取一张CD来播放”这个问题，分别设定用来表示所有CD，以及表示用户所选择的那张CD的变量名。

**问题分析示例**

*问题：* 请根据右侧的课程成绩估算表，用作业项目、期中考试和期末考试这三项的加权值计算出这一门课的成绩。

| 参考项 | 权重比 |
|-------|-------|
| 作业项目 | 50% |
| 期中考试 | 20% |
| 期末考试 | 30% |

如前所述，问题分析的工作要从理解问题的书面描述开始，然后确定解决该问题所需要的输入和输出。在这里，先定义并命名好输出的内容是一个不错的切入点。因为，输出内容中通常存储的就是这个待解决问题的答案，它会驱使我们去深入理解这个待解决的问题。

一旦我们定义好了解决问题所需的数据，并赋予它们有意义的变量名之后，就可以将注意力转向如何完成任务了。就这个特定的问题而言，它要输出应该就是实际的课程成绩，我们将这个要输出给用户的信息命名为`courseGrade`。然后为了让这个问题更具有通用性，我们要让用户自己键入产生计算结果所需的值。毕竟如果这个程序可以要求用户提供所需的数据，那它以后就可以用来计算多位学生任何一门课程的成绩了。在这里，我们将需要用户输入的这些数据命名为：`projects`、`midterm`和`finalExam`。这样一来，我们目前就已经完成了问题分析这一步骤中的前三个动作：

1. 理解待解决的问题。
2. 定义要输出的信息：`courseGrade`。
3. 定义要输入的数据：`projects`、`midterm`和`finalExam`。

接下来就需要有一个问题样例，它有助于我们创建一个测试用例（test case），以验证输入的数据和程序产生的输出结果。例如，当`projects`为74.0、`midterm`为79.0、`finalExam`为84.0时，其平均加权值应该为78.0：

```LaTeX
(0.50 × projects) + (0.20 × midterm) + (0.30 × finalExam)
   (0.5 × 74.0)   +   (0.2 × 79.0)   +  (0.30 × 84.0)
      37.0        +      15.8        +      25.2
                         78.0
```

到这里，问题的分析步骤就算完成了，我们确定了用于输入/输出的变量，这有助于我们了解计算机解决方案需要做哪些事，同时还获得了一个现成的测试用例。

| 待解决的问题 | 变量 | 输入/输出 | 测试用例 |
|------------|-----|---------|--------|
| 计算某门课的成绩 | projects | 输入 | 74.0  |
|    | midterm | 输入 | 79.0 |
|    | finalExam | 输入 | 84.0 |
|    | courseGrade | 输出 | 78.0 |

*****

**自检题**

1-3. 请完成对下面问题的分析，这里你可能会需要用到一个准确的计算器。

*问题：* 请针对某项投资的当前价值、投资期限（可能以年为单位）以及投资利率，估算出它的未来价值。在这里，投资利率和投资期限是步调一致的。也就是说，如果投资期限以年为单位，那这里的投资利率就是年利率（例如8.5%，就是0.085）；如果投资期限以月为单位，那这里的投资利率就是月利率（例如，如果年利率是9%，那月利率就是0.075）。其未来价值的计算公式如下：

> $futureValue = presentValue * (1 + rate)^{periods}$

### 1.1.2 设计（模型、思考、计划、策划、模式、纲要）

*设计*这个概念背后说代表的是一系列动作，这其中包括为程序中的每个组件安排具有针对性的算法。而*算法*则是指我们在解决问题或达成某项目标的过程中所要完成的逐个步骤。一个好的算法必须要：

* 列出程序所要执行的动作。
* 按照恰当的顺序列出这些动作。

事实上，我们可以烤制胡萝卜蛋糕的过程看成是一个算法：

* 将烤箱预热至350°F。
* 将每个烤模的侧面和底部抹上油。
* 将食材放到一大碗里进行搅拌。
* 将搅拌物倒入每个烤模中，并立即放入烤箱烤制。对于纸杯蛋糕，请倒至2/3满即可。
* 根据相关图表来进行烤制。
* 当将牙签插入到蛋糕中心，拔出来后依然能干净就表示蛋糕烤制成功。

如果这些步骤的顺序被改变了，厨师可能得到的就是一个滚烫的烤模，里面放了一团鸡蛋与面粉的搅拌物。如果省去了其中的某一个步骤，厨师也不会烤成蛋糕，或许他只是点了一次火而已。当然，熟练的厨师通常是不需要这种算法的。但是，蛋糕制作原料的销售商可不能，也不该假设他们的客户都很熟练。总之，好的算法必须要按照恰当的顺序列出恰当的步骤，并且要详尽到足以完成任务。

*****

**自检题**

1-4. 烤制蛋糕的食谱通常会省略一个非常重要的动作，请指出上述算法中缺少的是什么动作。

通常情况下，算法中所包含的都是一些不涉及太多细节的步骤。例如，“在大碗中搅拌”这并不是一个非常具体的动作描述，里面的食材配比是什么呢？如果我们现在的问题是要编写一个人类能够理解的蛋糕烤制算法，这个步骤就可以做进一步的改进，使其能指导厨师更好地安排食材配比。譬如我们可以将该步骤改成“将牛奶倒入盛有鸡蛋与面粉的大碗中搅拌，直至其表面光滑”，或者为面包师将该步骤切分如下：

* 配置好食材中干燥的成分。
* 将食材的液体成分倒入碗中。
* 每次倒入四分之一杯的干成分，将其搅拌至表面光滑。

算法可以用*伪代码*来描述，甚至也可以用一种非程序员也能理解的语言来描述。由于伪代码面向的是人类，而不是计算机，所以用伪代码描述的算法在程序设计中是很有帮助的。

伪代码有极强的表达能力。一条伪代码通常可以表示多条计算机指令。另外，用伪代码来描述算法可以避免纠缠于标点错误或者与特定计算机系统相关的细节。用伪代码来描述解决方案允许我们将这些细节问题向后推，这可以让设计变得更容易一些。其实，写算法就相当于在做计划，程序开发者也可以用纸和笔来做这些设计，甚至有时可以直接在脑海中完成这些事。

### 1.1.3 算法模式

解决问题通常需要用户完成一定的输入才能计算并显示出相应的信息。事实上，这种输入-处理-输出的动作流是如此的司空见惯，我们甚至可以把它视为一种模式，而且你们会发现这绝对是程序设计中最有用的几个算法模式之一。

*模式*可以是任何一种事物形式或设计，它的作用是将某些事物模型化或者提供某种行事指南。而算法模式就是一种用于辅助我们解决问题的指南。以下面的输入/处理/输出（即Input/Process/Output，简称IPO）算法模式为例，我们可以用它来辅助解决第一个问题的设计，事实上，IPO模式可以辅助我们解决本书前五章中几乎所有程序的设计问题。

| 算法模式 | *输入/处理/输出* |
|---------|----------------|
| 模式： | 输入/处理/输出（IPO） |
| 问题： | 程序需要基于用户的输入来计算并显示我们所需的信息。 |
| 纲要： | 1. 获取输入数据。<br> 2. 用某种有意义的方式处理数据。<br> 3. 输出结果。<br> |

**代码示例：**

```C++
int n1, n2, n3;
oat average;

// Input
cout << "Enter three numbers: ";
cin >> n1 >> n2 >> n3;

// Process
average = (n1 + n2 + n3) / 3.0;

// Output
cout << "Average = " << average;
```

*****

这是若干种算法模式中的第一种。在后面的章节中，我们会陆续看到Guarded Action、Alternative Action、Indeterminate Loop等其他算法模式。为了有效地使用一个算法模式，我们首先必须得熟记它。将IPO模式注册在心中，并在开发程序时能想起它，这样就会让我们的程序设计变得更容易。例如，如果你在数据数据中发现了无意义的值，有可能是你将程序的处理步骤放在了输入步骤*之前*，或者根本就跳过了输入步骤。

关于模式在解决其他类型问题时所能提供的帮助，我们可以参考Christopher Alexander在他*A Pattern Language*\[Alexander 77\]这本书里的这样一段话：

> 每个模式描述的都是一个我们所在客观环境中反复出现的问题，及其解决方案的核心内容，通过这种方式构建的解决方案，可以让我们用上一百万次，无须用相同的方式构建两次解决方案。

尽管Alexander所描述的是用于设计家具、花园、大楼和城镇的模式，但他描述的模式也适用于计算领域问题的解决。在程序设计的过程中，IPO模式就是会反复出现，并指引着许多问题的解决方案。

### 1.1.4 算法设计示例

IPO模式也可以用来指导我们解决之前那个课程成绩计算问题的算法设计：

| 三步骤模式 | 将模式应用到具体的算法中 |
|----------|----------------------|
| 1. 输入 | 1. 读取`projects`、`midterm`和`finalExam`三个变量 |
| 2. 处理 | 2. 计算出`courseGrade`的值 |
| 3. 输出 | 3. 显示`courseGrade`的值 |

当然了，算法的开发通常是一个迭代的过程，模式也只是提供了解决这个问题所必需的动作序列纲要。

*****

**自检题**

1-5. 在阅读上述算法的三个动作时，你发现其中缺失的动作了吗？

1-6. 在阅读上述算法的三个动作时，你有发现什么不正常的动作吗？

1-7. 如果对调上述算法中前两个动作的顺序，该算法还能正常工作吗？

1-8. 上述算法的描述是否已经足够支持计算出`courseGrade`的值了？

很显然，我们在上面对计算课程成绩问题的的处理步骤的描述是不够详细的，我们还需对它进行进一步的细化。具体来说就是，说清楚在处理过程中如何用输入数据计算出课程成绩。上面的算法中省略了我们在问题书面化描述中提到的加权值，所以在下面，我们在第二步中重新细化了处理步骤：

1. 从用户那里获取`projects`、`midterm`、`finalExam`这三个数据值。
2. 计算`courseGrade` = (`projects` × 50%) + (`midterm` × 20%) + (`finalExam` × 30%)。
3. 显示`courseGrade`的值。

就像人们常说的那样，好的艺术家应该知道什么时候该放下画笔，并决定与此刻完成他的画作，这对他的成功是至关重要的。同样地，设计师也必须要知道什么时候该停止设计，那就是我们进入解决问题第三阶段——实现阶段的好时机。

现在，我们来总结一下到目前为止所取得的进展：

* 待解决的问题得到了充分的理解。
* 所要用到的变量得到了确认。
* 对已知问题样例的输出有了了解（78.0%）。
* 已经开发出了一种算法。

### 1.1.5 实现（完成、操作、使用）

计算机本质上就是一种可编程的、用来存储、检索并处理数据的电子设备。事实上，程序员们也可以通过纸和笔来手动执行存储、检索与处理数据的动作，以此来模拟算法在电子设备中的执行过程 。下面就是一个人工模拟的（即非电子的）算法执行过程：

1. 从用户那里检索到一些示例值并将它们存储起来：

```C++
    projects = 80
    midterm = 90
    finalExam = 100
```

2. 再次检索这些值并用它们计算出`courseGrade`的值：

```LaTeX
   courseGrade = (0.5 × projects) + (0.2 × midterm) + (0.3 × nalExam)
                   (0.5 × 80.0)   +   (0.2 × 90.0)  +  (0.3 × 100.0)
                        40.0      +     18.0        +     30.0
                            courseGrade = 88.0
```

3. 将存储在`courseGrade`中的值显示成88% 。

### 1.1.6 一段C++程序

下面，我们要带你来预览一段完整的C++程序，由于对这里的许多编程语言上的细节问题，我们要到下一章中才会介绍，所以各位也不必期待自己能完全理解这段C++源代码。在此次此刻，我们只需要读懂这段源代码是对之前那个伪代码算法的实现就可以了。这里有`projects`、`midterm`、`finalExam`这三个变量，代表的是用户的输入。另外还有一个名为`courseGrade`的输出变量。另外，这里的`cout`对象，发音是“see-out”，代表的是*公共输出*以及程序所产生的输出。而输入部分用的则是`cin`对象，发音是“see-in”，代表的是*公共输入*。

```C++
/*
 * This program computes and displays a final course grade as a
 * weighted average after the user enters the appropriate input.
 *
 * File name: CourseGrade.cpp
 */

#include <iostream>         // for cin and cout
#include <string>           // for string
using namespace std;        // avoid writing std::cin std::cout std::string

int main() {
    // Explain what this program does.
    cout << "This program computes a weighted course grade." << endl;

    // Read in a string
    cout << "Enter the student's name: "`;
    string name;
    cin >> name;

    // I)nput projects, midterm, and nalExam
    double projects, midterm, finalExam;

    cout << "Enter project score: ";
    cin >> projects;

    cout << "Enter midterm: ";
    cin >> midterm;

    cout << "Enter finalexam: ";
    cin >> finalExam;

    // P)rocess
    double courseGrade = (0.5 * projects) +
                         (0.2 * midterm) +
                         (0.3 * finalExam);

    // O)utput the results
    cout << name << "'s grade: " << courseGrade << "%" << endl;
}
```

**会话**

下面是该程序计算一次加权课程成绩的过程：

```shell
Enter the student's name: Dakota
Enter project score: 80
Enter midterm: 90
Enter final exam: 100
Dakota's grade: 88%
```

### 1.1.7 测试

测试这个重要的过程，可能，可以，并且也应该出现在我们解决问题的每一杆阶段中。这部分的实际工作量很小，但很值得。当然，在因为*不做*测试而遇到问题之前，你可能不会同意我这个观点。总而言之，测试相关的系列动作可以出现在程序开发的所有阶段中：

* 在分析阶段中，我们可以通过测试用例确认自己对待解决问题的理解。
* 在设计阶段中，我们可以通过测试算法来确定其按照恰当的顺序执行了恰当的步骤。
* 在测试过程中，我们可以用几组不同的输入数据来运行程序，确认其结果是否正确。
* 请复查待解决问题的书面描述，确认我们运行的程序的确执行了需要执行的操作。

You should have one or more test case problems before the program is coded—not after. Determine the input values and what you expect for output. Using 80, 90, and 100 as input and expecting the output to be 88% is one such test case. When the program fi nally does generate output, the expected result can then be compared to the output of the running program. Adjustments must be made any time the predicted output does not match the program output. Such a conflict indicates that the problem example, the program output, or perhaps both are incorrect.

Testing with several test cases helps avoid the misconception that a program is correct just because the program runs successfully and generates output. The output could be wrong! Simply executing a program does not make that program correct. Test cases provide confi dence that the program does work.

However, even exhaustive testing does not prove a program is correct. E. W. Dijkstra has argued that testing only reveals the presence of errors, not the absence of errors. Even with correct program output, the program is not proven correct. Testing reduces errors and increases confidence that the program works correctly.

*****

**SELF-CHECK**

1-9. If the programmer predicts courseGrade should be 100.0 when all three inputs are 100.0 and the program displays courseGrade as 75.0, what is wrong: the predicted output, the program, or both?

1-10. If the programmer predicts courseGrade should be 90.0 when projects is 80.0, midterm is 90.0, and nalExam is 100.0 and the program outputs courseGrade as 88, what is wrong: the prediction, the program, or both?

1-11. If the programmer predicts courseGrade should be 88 when projects is 80.0, midterm is 90.0, and nalExam is 100.0 and the program outputs courseGrade as 90.0, what is wrong: the prediction, the program, or both?

## 1.2 OBJECTS, TYPES, AND VARIABLES

To input something that can be used by a program, there must be a place to store it in the memory of the computer. Bjarne Stroustrup, the creator of C++, writes
> We call such a “place” an object. An object is a region of memory with type that specifi es what kind of information can be placed in it. A named object is called a variable. For example, character strings are put into string variables and integers are put into int variables. You can think of an object as a “box” into which you can put a value of the object’s type.

For example, the int type used in the previous program stores whole numbers, or integers. Some operations on int variables include addition, subtraction, multiplication, and division. Note that C++ uses \* for the multiplication operator (using x would be confusing).

```C++ 
double courseGrade = 0.5*projects + 0.2*midterm + 0.5*finalExam;
```

The oat and double types (double is twice the size of a oat) store numeric values with a fractional part. The C++ string type stores character sequences as "Firstname I. Lastname" along with an integer to maintain the number of characters in that string.

*Objects* are entities stored in computer memory. An object is understood by the types of values the object stores—its *attributes*—and the operations that can be applied to that object—its *behavior* \[Booch\]. Every object has

* a name to store and retrieve the values of that object
* values stored in computer memory, which is known as the object’s state
* a set of operations such as addition, input, output, assignment

These three characteristics of objects—name, state, and operations—were all illustrated in the course grade program. It used three numeric objects stored as projects, midterm, and finalExam that were read in from the keyboard. Each of these objects is capable of storing the value of an integer such as 79 or 90. Th ese objects, along with available operations such as input, multiplication, and addition, computed the courseGrade. An assignment operation was used to store it as a numeric object. An output operation with cout << was used so the user could see the results of the processing.

**Characteristics of Objects in the First Program**

|     |      |
|-----|------|
| Name: | Each of the four numeric objects has its own identity because each has its own name. The first of the four numeric objects was stored as the variable named projects. |
| State: | The value of projects was set with an input operation using cin >> The state of courseGrade was defi ned with an assignment operation using the = operator. The state of courseGrade was retrieved during output with cout. |
| Operations: | Other operations available for the int objects included addition (+) and multiplication (\*). |

C++ has fundamental types and compound types. The *fundamental* types store one value that corresponds directly to hardware with a fixed size. The type determines what values can be stored into that object and what operations can be performed. With numeric types such as int and double, the number of bytes, which varies for different computers, determines the range of values that can be stored in it.

| **Data Type** | **size** | **Typical Range of Values (varies)** |
|---------------|----------|--------------------------------------|
| short         | 2 bytes (16 bits) |  -32768 to 32767            |
| unsigned short |  2 bytes  |         0 to 65,535                |
| int            |  4 bytes  |         -2147483648 to 2147483647  |
| unsigned int   |  4 bytes  |         0 to 4294967295            |
| unsigned long  |  8 bytes  |         0 to 18446744073709551615  |
| float          |  4 bytes  |         3.4E +/- 38 (7 digits)     |
| double         |  8 bytes  |         1.7E +/- 308 (15 digits)   |
| char           |  1 byte   |         0 to 255                   |
| bool           |  1 byte   |         true or false              |

A *compound* type is a type that is defi ned in terms of another type. C++ has these compound types presented in this textbook: references, functions, classes, arrays, and pointers. For example, string is a reference type made up of characters and other data. It has operations to find the length of the sequence of characters and another operation to create a substring from a string given the starting and ending indexes (there are many more operations that will be explored in a later chapter):

```C++
string aString = "A sequence of characters"; // Output: 
cout << aString.length() << endl;            // 24 
cout << aString.substr(2, 8) << endl;        // sequence 
```

In addition to the string type, two other reference types are used immediately. Th e istream type object named cin has operations to read from an input source such as the keyboard or a fi le on disk. The ostream type object named cout helps generate output.

**SELF-CHECK**

1-12. Describe the values stored in objects of type double.

1-13. Name two operations for double objects.

1-14. Describe the values stored in objects of the int type.

1-15. Name two operations for int objects.

1-16. Describe the values stored in string objects.

1-17. Which of the types above store precisely one value?

## CHAPTER SUMMARY

This chapter presented a three-step problem-solving strategy of analysis, design, and implementation. The table below shows some of the activities performed during each of these three phases. The maintenance phase has been added to show how the three steps fit into the complete program life cycle. Th e maintenance phase actually requires the majority of the time, energy, and money of the program’s life cycle.

| **Phase** | **Activities You Might Perform** |
|-----------|----------------------------------|
| Analysis  | Read and understand the problem statement. <br> Determine the input and output objects. <br> Solve a few sample problems.|
| Design    | Look for patterns to guide algorithm development.<br>  Write an algorithm—steps needed to solve the problem.<br>  Refine the steps in the algorithm and walk through it. |
| Implementation | Translate the design into a programming language.<br>  Fix errors.<br>  Create an executable program.<br> Test the program. |
| Maintenance | Update the program to keep up with a changing world.<br> Enhance it.<br> Correct bugs as they are found. |

* Some analysis and design tools were introduced:
    * naming the objects that help solve a problem
    * developing algorithms
    * refining one or more steps of an algorithm
    * using the Input/Process/Output pattern

* The sample program we presented previews the details to be discussed in the next chapter. C++ types were previewed: fundamental and compound.

* Testing is important, but it does not prove the absence of errors. Testing can and does detect errors, but it can only build confi dence that the program appears to work.

## EXERCISES

1. What activities can be performed when analyzing problems?
2. What are the characteristics of a good algorithm?
3. What is the diff erence between objects used to store output values and objects that store the values input by the user?
4. List the three characteristics of objects.
5. What activities can be performed when designing programs?
6. What is one “deliverable” of design?
7. What type of object would you use to store the number of students registered in a course?
8. What type of object would you use to store π?
9. What type of object would you use to store the words of a Shakespeare play?
10. What is the deliverable from the implementation phase of program development?
11. Does a program that runs work correctly? Justify your answer.
12. Write an algorithm that describes how to get to where you live.
13. Write an algorithm for fi nding any phone number in the phone book. Will the search always be successful?
14. Write an algorithm that instructs someone to arrive at your home on foot.
15. Obtain the instructions necessary to create, compile, link, and execute a C++ program on your system. You may need to seek out a login procedure and/or basic editing commands and compiling commands. After this, write a complete algorithm that provides all necessary steps to successfully guide a novice to complete a program through testing. Your algorithm may contain steps such as “Compare example output to program output,” “Create a new file,” and “Compile the program.”

## PROBLEM SOLVING: WRITING ALGORITHMS

### 1A SIMPLE AVERAGE

Write an algorithm that will compute the average of three test scores of equal weight.

### 1B WEIGHTED AVERAGE

Write an algorithm that will compute the course grade using this weighted scale:

| *Assessment* | *Weight* |
|--------------|----------|
| Quiz average | 20%      |
| Midterm      | 20%      |
| Lab grade    | 35%      |
| Final exam   | 25%      |

### 1C WHOLESALE COST

You happen to know that a store has a 25% markup on compact disc (CD) players. If the retail price (what you pay) of a CD player is $189.98, how much did the store pay for that item (the wholesale price)? In general, what is the wholesale price for any item given its retail price and markup? Analyze the problem and design an algorithm that computes the wholesale price for any given retail price and any given markup. Use this formula and a little algebra to solve for wholesale price: retail price = wholesale price \* (1 + markup).

### 1D TIME DIFFERENCES

Write an algorithm that takes two diff erent train departure times (where 0 is midnight, 0700 is 7:00 a.m., 1314 is 14 minutes past 1:00 p.m., and 2200 is 10 p.m.) and prints the diff erence between the two times in hours and minutes. Assume both times are on the same date and that both times are valid. For example, 1099 is not a valid time because the last two digits are minutes, which should be in the range of 00 through 59. 2401 is not valid because the hours (the fi rst two digits) must be in the range of 0 through 23 inclusive. For example, if train A departs at 1255 and train B departs at 1305, the difference would be 0 hours and 10 minutes.

