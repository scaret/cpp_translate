# CHAPTER 1: Problem Solving with C++

**COMING UP**

We begin with a need for a computer-based solution to a problem. The need may be expressed in one or two paragraphs as a problem specification. The progression from understanding a problem specifi cation to achieving a working computer-based implementation is known as problem solving. After studying this chapter, you will understand

* one example of problem solving
* the characteristics of an algorithm
* how algorithmic patterns help in program design
* the relationship between a class and its many objects that objects have a name, state, and set of operations
* the categories of errors that occur during the implementation phase of software development

******

## 1.1 PROBLEM SOLVING

There are many approaches to problem solving. Th is chapter begins by examining a strategy with these three steps: analysis, design, and implementation.

|Phase               | Activity                                       |
|:-------------------|:-----------------------------------------------|
|**Analysis:**       | Understand the problem.                        |
|**Design:**         | Design an algorithm that outlines a solution.  |
|**Implementation:** | Code an executable program.

Our study of computing fundamentals begins with an example of this particular approach to problem solving. Each of these three phases will be exemplifi ed with a case study of one particular problem: computing a course grade.

### 1.1.1 ANALYSIS (INQUIRY, EXAMINATION, STUDY)

Program development may begin with a study, or analysis, of a problem. Obviously, to determine what a program is to do, you must first understand the problem. If the problem is written down, you can begin the analysis phase by simply reading the problem.

While analyzing the problem, it is helpful to name the data that represents the information. For example, you might be asked to compute  the maximum weight allowed for a successful liftoff of a particular  airplane from a given runway under certain thrust-aff ecting weather  conditions such as temperature and wind direction. While analyzing the problem specifi cation, you might name the desired information ```maximumWeight```. The data required to compute that information could have names such as temperature and windDirection.

Although such data do not represent the entire solution, they do represent an important piece of the problem. Th e data names are symbols for what the program will need and what the program will compute. One value needed to compute ```maximumWeight``` might be 19.0 for temperature. Such data values must often be manipulated—or processed—in a variety of ways to produce the desired result. Some values must be obtained from the user, other values must be multiplied or added, and still other values must be displayed on the computer screen.

At some point, these data values will be stored in computer memory. The values in the same memory location can change while the program is running. Th e values also have a type, such as integers, numbers with decimal points, strings of characters, or types that store several diff erent types of values. These named pieces of memory that store values that change while the program is running are known as *variables*.

You will see that there also are operations for manipulating those values in meaningful ways. It helps to distinguish the data that must  be displayed—*output*—from the data required to compute that result—*input*. Th ese variables summarize what the program must do.

* **Input:** Information a user must supply to solve a problem.
* **Output:** Information the computer must display.

A problem can be better understood by answering this question: What  would the output be given certain input? Therefore, it is a good idea to provide an example of the problem. Here are two problems with variable names selected to accurately describe the stored values:

| **Problem** | **Variable** | **Input or Output** | **Sample Problem** |
|-------------|--------------|----------------------|--------------------|
| Compute a monthly | amount | Input   | 12500.00   |
| loan payment | rate | Input | 0.08 |
|        | months | Input  | 48      |
|        | payment | Output | 303.14 |
| Count how often | theWork | Input | Much Ado About Nothing |
| Shakespeare wrote | theWord   | Input | thee    |
| a particular word in a particular play | howOften |Output  | 74  |

In summary, problems can be analyzed by:

1. Reading and understanding the problem specifi cation.
2. Deciding what data represent the answer—the output.
3. Deciding what data the user must enter to get the answer—the input.
4. Creating some sample problems (like those above) that summarize.

Textbook problems sometimes provide the variable names and types of values such as strings, integers, or numbers with a decimal point that must be input and output. If not, they are relatively easy to recognize. In real-world problems of signifi cant scale, a great deal of effort is expended in the analysis stage.

*****

**SELF-CHECK**

1-1. Given the problem of converting British pounds to U.S. dollars, provide a meaningful name for a variable to store the value that must  be input by the user. Also give a meaningful name for the variable to store a value that is to be output.

1-2. Given the problem of selecting one CD from a 200-CD player, what variable name would represent all of the CDs? What name would be appropriate to represent one CD selected by the user?

**An Example of Analysis**

*Problem:* Using the grade assessment scale to the right, compute a course grade as a weighted average of projects, a midterm, and one final exam.

|**Item**   |**Weight**|
|-----------|----------|
|Projects   |50%       |
|Midterm    |20%       |
|Final Exam |30%       |

Analysis begins by reading the problem specifi cation and establishing the desired output and the required input to solve the problem. Determining and naming the output is a good place to start. The output stores the answer to the problem. It provides insight into what the program must do.

Once the need for a data value is discovered and given a meaningful name, the focus can shift to what must be accomplished. For this particular problem, the desired output is the actual course grade. The name courseGrade represents the requested information to be output to the user. This problem becomes more generalized when the user enters values to produce the result. If the program asks the user for data, the program can be used later to compute course grades for many students with any set of grades. So let’s decide on and create names for the values that must be input. To determine courseGrade, three values are required: projects, midterm, and nalExam. The first three analysis activities are now complete:

1. Problem understood.
2. Information to be output: courseGrade.
3. Data to be input: projects, midterm, and nalExam.

It helps to have a sample problem, a test case. This involves having the input values and the expected output result. For example, when projects is 74.0, midterm is 79.0, and nalExam is 84.0, the weighted average should be 78.0:

```
(0.50 × projects) + (0.20 × midterm) + (0.30 × nalExam)
   (0.5 × 74.0)   +   (0.2 × 79.0)   +  (0.30 × 84.0)
      37.0        +      15.8        +      25.2
                         78.0
```

The problem has now been analyzed, the input and output variables have been identifi ed, it is understood what the computer-based solution is to do, and one test case exists.

| **Problem** | **Variable** | **Input or Output** | **Test Case**  |
|-------------|---------------|----------------------|----------------|
| Compute a course grade | projects | Input | 74.0   |
|    | midterm | Input  | 79.0   |
|    | nalExam | Input  | 84.0    |
|    | courseGrade | Output  | 78.0  |

*****

**SELF-CHECK**

1-3. Complete an analysis for the following problem. You will need a calculator to determine output.

*Problem:* Show the future value of an investment given its present > value, the number of periods (years, perhaps), and the interest rate. Be consistent with the interest rate and the number of periods; if the periods are in years, then the annual interest rate must be supplied (0.085 for 8.5%, for example). If the period is in months, the monthly interest rate must be supplied (0.0075 per month for 9% per year, for example). The formula to compute the future value of money:

> future value = present value \* $(1 + rate)^{periods}$

### 1.1.2 DESIGN (MODEL, THINK, PLAN, DEVISE, PATTERN, OUTLINE)

*Design* refers to the set of activities that includes specifying an algorithm for each program component. An *algorithm* is a step-by-step procedure for solving a problem or accomplishing some end, especially by a computer. A good algorithm must

* list the activities that need to be carried out
* list those activities in the proper order

Consider an algorithm to bake a cake taken from directions for carrot cake:

* Preheat oven to 350° F.
* Grease sides and bottom of each pan.
* Blend ingredients in a large bowl.
* Pour batter into the pan and bake immediately. For cupcakes, fill to 2/3 full.
* Bake following the chart below.
* Cake is done when toothpick inserted in center comes out clean.

If the order of the steps is changed, the cook might get a very hot cake pan with raw cake batter in it. If one of these steps is omitted, the cook probably won’t get a baked cake—or there might be a fi re. An experienced cook may not need such an algorithm. However, cake-mix marketers cannot and do not presume that their customers have this experience. Good algorithms list the proper steps in the proper order and are detailed enough to accomplish the task.

*****

**SELF-CHECK**

1-4. Cake recipes typically omit a very important activity. Describe an activity that is missing from the algorithm above.

An algorithm often contains a step without much detail. For example, “Blend ingredients in a large bowl” isn’t very specifi c. What are the ingredients? If the problem is to write a recipe algorithm that humans can understand, this step could be refi ned a bit to instruct the cook on how to blend the ingredients. Th e refi nement to this step could be “Empty the cake mix into the bowl and mix in the milk until smooth,” or for scratch bakers:

* Sift the dry ingredients.
* Place the liquid ingredients in the bowl.
* Add the dry ingredients a quarter-cup at a time, whipping until smooth.

Algorithms may be expressed in *pseudocode*—instructions expressed in a language that even nonprogrammers understand. Pseudocode is written for humans, not for computers. Pseudocode algorithms are an aid to program design.

Pseudocode is very expressive. One pseudocode instruction may represent many computer instructions. Pseudocode algorithms are not concerned about issues such as misplaced punctuation marks or the details of a particular computer system. Pseudocode solutions make design easier by allowing details to be deferred. Writing an algorithm can be viewed as planning. A program developer can design with pencil and paper and sometimes in their head.

### 1.1.3 ALGORITHMIC PATTERNS

Problems often require input from the user in order to compute and display the desired information. This particular flow of activities—input/process/output—occurs so often, in fact, that it can be viewed as a pattern. It is one of several algorithmic patterns you will fi nd helpful in the design of programs.

A *pattern* is anything shaped or designed to serve as a model or a guide in making something else. An algorithmic pattern serves as a guide to help solve problems. For instance, the following Input/Process/Output (IPO) algorithmic pattern can be used to help design our fi rst problem. In fact, this IPO pattern can be used to help design almost all of the programs in the first five chapters of this textbook.

|Algorithmic Pattern: |  *Input/Process/Output* |
|------------|-----------------------------|
| Pattern:   | Input/Process/Output (IPO)  |
| Problem:   | The program requires input from the user in order to compute and display the                   desired information. |
| Outline:   | 1. Obtain the input data. <br> 2. Process the data in some meaningful way. <br> 3. Output the results. <br> |

**Code Example:**

```C++
int n1, n2, n3;
oat average;

// Input
cout << "Enter three numbers: ";
cin >> n1 >> n2 >> n3;

// Process
average = (n1 + n2 + n3) / 3.0;

// Output 
cout << "Average = " << average;
```

*****

This algorithmic pattern is the first of several. In subsequent chapters, you’ll see other algorithmic patterns such as Guarded Action, Alternative Action, and Indeterminate Loop. To use an algorithmic pattern eff ectively, you should first become familiar with it. Register this Input/Process/Output algorithmic pattern and look for this pattern while developing programs. Th is allows you to design programs more easily. For example, if you discover you have no meaningful values for the input data, it may be that you have placed the process step *before* the input step. Or you may have skipped the input step altogether.

Patterns help solve other kinds of problems. Consider this quote from Christopher Alexander’s book, *A Pattern Language* \[Alexander 77\]: 
> Each pattern describes a problem which occurs over and over again in our environment, and      then describes the core of the solution to that problem, in such a way that you can use this   solution a million times over, without ever doing it the same way twice. 

Even though Alexander was describing patterns in the design of furniture, gardens, buildings, and towns, his description of a pattern can also be applied to computational problem solving. The IPO pattern frequently pops up during program design. It guides the solution to many problems.

### 1.1.4 AN EXAMPLE OF ALGORITHM DESIGN

The Input/Process/Output pattern guides the design of the algorithm that relates to our course grade problem.

| **Three-Step Pattern** | **Pattern Applied to a Specifi c Algorithm** |
|-------------------------|----------------------------------------------|
| 1. Input <br>  2. Process <br> 3. Output | 1. Read in projects, midterm, and nalExam <br> 2. Compute courseGrade <br> 3. Display courseGrade |

Although algorithm development is usually an iterative process, a pattern provides an outline of the activities necessary to solve this problem.

*****

**SELF-CHECK**

1-5. Read the three activities of the algorithm above. Do you detect a missing activity?

1-6. Read the three activities of the algorithm above. Do you detect any activity out of order?

1-7. Would this previous algorithm work if the first two activities were switched?

1-8. Is the algorithm detailed enough to compute courseGrade?

There currently is not enough detail in the process step of the course grade problem. Th e algorithm needs further refi nement. Specifi cally, exactly how should the input data be processed to compute the course grade? Th e algorithm omits the weighted scale described in the problem specifi cation. The process step should be refined a bit more as shown in step 2:

1. Obtain projects, midterm, and nalExam from the user
2. Compute courseGrade = (50% projects) + (20% midterm) + (30% nalExam)
3. Display the value of courseGrade

It has been said that good artists know when to put down the brush. Deciding when a painting is done is critical for its success. By analogy, a designer must decide when to stop designing. This is a good time to move on to the third phase of problem solving, which is implementation.

In summary, here is what has been accomplished so far:

* The problem is understood
* Variables have been identifi ed
* Expected output of a sample problem is known (78.0%)
* An algorithm has been developed

### 1.1.5 IMPLEMENTATION (FULFILLMENT, OPERATION, USAGE)

A computer is a programmable electronic device that can store, retrieve, and process data. Programmers can simulate an electronic version of an algorithm by following the algorithm and manually performing the activities of storing, retrieving, and processing data using pencil and paper. The following algorithm walkthrough is a human (non-electronic) execution of the algorithm:

1. Retrieve some example values from the user and store them as shown:<br> projects = 80 <br> midterm = 90 <br>nalExam = 100

2. Retrieve the values and compute courseGrade as follows:<br>

```
   courseGrade = (0.5 × projects) + (0.2 × midterm) + (0.3 × nalExam)
                   (0.5 × 80.0)   +   (0.2 × 90.0)  +  (0.3 × 100.0)
                        40.0      +     18.0        +     30.0 
                                courseGrade = 88.0
```

3. Display the value stored in courseGrade to show 88%

### 1.1.6 A C++ PROGRAM

The following complete C++ program previews many programming language details presented in the next chapter. You are not expected to understand this C++ source code. For now, just peruse the source code as an implementation of the pseudocode algorithm. The three variables—projects, midterm, and nalExam—represent user input. The output variable is named courseGrade. The object cout, pronounced "see-out," stands for *common output* and allows a program to generate output. Input is made possible using the object cin, pronounced "see-in," which stands for *common input*.

```C++
/*
 * This program computes and displays a nal course grade as a 
 * weighted average after the user enters the appropriate input.
 *
 * File name: CourseGrade.cpp
 */

#include <iostream>         // for cin and cout
#include <string>           // for string
using namespace std;        // avoid writing std::cin std::cout std::string

int main() {
    // Explain what this program does.
    cout << "This program computes a weighted course grade." << endl;

    // Read in a string
    cout << "Enter the student's name: ";
    string name;
    cin >> name;

    // I)nput projects, midterm, and nalExam
    double projects, midterm, finalExam;

    cout << "Enter project score: ";
    cin >> projects;

    cout << "Enter midterm: "; 
    cin >> midterm;

    cout << "Enter finalexam: ";
    cin >> finalExam;

    // P)rocess
    double courseGrade = (0.5 * projects) +
                         (0.2 * midterm) +
                         (0.3 * finalExam);

    // O)utput the results
    cout << name << "'s grade: " << courseGrade << "%" << endl;
}
```

**Dialogue**

This program computes a weighted course grade.

> Enter the student's name: ***Dakota*** <br>
> Enter project score: ***80*** <br>
> Enter midterm: ***90*** <br>
> Enter nal exam: ***100*** <br>
> Dakota's grade: 88%       <br>  

### 1.1.7 TESTING

The important process of testing may, can, and should occur at any phase of problem solving. The actual work can be minimal, and it’s worth the eff ort. However, you may not agree until you have experienced the problems incurred by *not* testing. Testing activities can occur during all phases of program development:

* During analysis, establish test case problems to confirm your understanding of the problem.
* During design, walk through the algorithm to ensure that it has the proper steps in the proper order.
* During testing, run the program several times with diff erent sets of input data. Confirm that the results are correct.
* Review the problem specifi cation. Does the running program do what was requested?

You should have one or more test case problems before the program is coded—not after. Determine the input values and what you expect for output. Using 80, 90, and 100 as input and expecting the output to be 88% is one such test case. When the program fi nally does generate output, the expected result can then be compared to the output of the running program. Adjustments must be made any time the predicted output does not match the program output. Such a conflict indicates that the problem example, the program output, or perhaps both are incorrect.

Testing with several test cases helps avoid the misconception that a program is correct just because the program runs successfully and generates output. The output could be wrong! Simply executing a program does not make that program correct. Test cases provide confi dence that the program does work.

However, even exhaustive testing does not prove a program is correct. E. W. Dijkstra has argued that testing only reveals the presence of errors, not the absence of errors. Even with correct program output, the program is not proven correct. Testing reduces errors and increases confidence that the program works correctly.

*****

**SELF-CHECK**

1-9. If the programmer predicts courseGrade should be 100.0 when all three inputs are 100.0 and the program displays courseGrade as 75.0, what is wrong: the predicted output, the program, or both?

1-10. If the programmer predicts courseGrade should be 90.0 when projects is 80.0, midterm is 90.0, and nalExam is 100.0 and the program outputs courseGrade as 88, what is wrong: the prediction, the program, or both?

1-11. If the programmer predicts courseGrade should be 88 when projects is 80.0, midterm is 90.0, and nalExam is 100.0 and the program outputs courseGrade as 90.0, what is wrong: the prediction, the program, or both?

## 1.2 OBJECTS, TYPES, AND VARIABLES

To input something that can be used by a program, there must be a place to store it in the memory of the computer. Bjarne Stroustrup, the creator of C++, writes
> We call such a “place” an object. An object is a region of memory with type that specifi es what kind of information can be placed in it. A named object is called a variable. For example, character strings are put into string variables and integers are put into int variables. You can think of an object as a “box” into which you can put a value of the object’s type.

For example, the int type used in the previous program stores whole numbers, or integers. Some operations on int variables include addition, subtraction, multiplication, and division. Note that C++ uses \* for the multiplication operator (using x would be confusing).
> double courseGrade = 0.5\*projects + 0.2\*midterm + 0.5\* finalExam;

The oat and double types (double is twice the size of a oat) store numeric values with a fractional part. The C++ string type stores character sequences as "Firstname I. Lastname" along with an integer to maintain the number of characters in that string.

*Objects* are entities stored in computer memory. An object is understood by the types of values the object stores—its *attributes*—and the operations that can be applied to that object—its *behavior* \[Booch\]. Every object has

* a name to store and retrieve the values of that object
* values stored in computer memory, which is known as the object’s state
* a set of operations such as addition, input, output, assignment

These three characteristics of objects—name, state, and operations—were all illustrated in the course grade program. It used three numeric objects stored as projects, midterm, and finalExam that were read in from the keyboard. Each of these objects is capable of storing the value of an integer such as 79 or 90. Th ese objects, along with available operations such as input, multiplication, and addition, computed the courseGrade. An assignment operation was used to store it as a numeric object. An output operation with cout << was used so the user could see the results of the processing.

**Characteristics of Objects in the First Program**

|     |      |
|-----|------|
| Name: | Each of the four numeric objects has its own identity because each has its own name. The first of the four numeric objects was stored as the variable named projects. |
| State: | The value of projects was set with an input operation using cin >> The state of courseGrade was defi ned with an assignment operation using the = operator. The state of courseGrade was retrieved during output with cout. |
| Operations: | Other operations available for the int objects included addition (+) and multiplication (\*). |

C++ has fundamental types and compound types. Th e *fundamental* types store one value that corresponds directly to hardware with a fixed size. The type determines what values can be stored into that object and what operations can be performed. With numeric types such as int and double, the number of bytes, which varies for different computers, determines the range of values that can be stored in it.

| **Data Type** | **size** | **Typical Range of Values (varies)** |
|---------------|----------|--------------------------------------|
| short         | 2 bytes (16 bits) |  -32768 to 32767            |
| unsigned short |  2 bytes  |         0 to 65,535                |
| int            |  4 bytes  |         -2147483648 to 2147483647  |
| unsigned int   |  4 bytes  |         0 to 4294967295            |
| unsigned long  |  8 bytes  |         0 to 18446744073709551615  |
| float          |  4 bytes  |         3.4E +/- 38 (7 digits)     |
| double         |  8 bytes  |         1.7E +/- 308 (15 digits)   |
| char           |  1 byte   |         0 to 255                   |
| bool           |  1 byte   |         true or false              |

A *compound* type is a type that is defi ned in terms of another type. C++ has these compound types presented in this textbook: references, functions, classes, arrays, and pointers. For example, string is a reference type made up of characters and other data. It has operations to find the length of the sequence of characters and another operation to create a substring from a string given the starting and ending indexes (there are many more operations that will be explored in a later chapter):

```C++
string aString = "A sequence of characters"; // Output: 
cout << aString.length() << endl;            // 24 
cout << aString.substr(2, 8) << endl;        // sequence 
```

In addition to the string type, two other reference types are used immediately. Th e istream type object named cin has operations to read from an input source such as the keyboard or a fi le on disk. The ostream type object named cout helps generate output.

**SELF-CHECK**

1-12. Describe the values stored in objects of type double.

1-13. Name two operations for double objects.

1-14. Describe the values stored in objects of the int type.

1-15. Name two operations for int objects.

1-16. Describe the values stored in string objects.

1-17. Which of the types above store precisely one value?

## CHAPTER SUMMARY

This chapter presented a three-step problem-solving strategy of analysis, design, and implementation. The table below shows some of the activities performed during each of these three phases. The maintenance phase has been added to show how the three steps fit into the complete program life cycle. Th e maintenance phase actually requires the majority of the time, energy, and money of the program’s life cycle.

| **Phase** | **Activities You Might Perform** |
|-----------|----------------------------------|
| Analysis  | Read and understand the problem statement. <br> Determine the input and output objects. <br> Solve a few sample problems.|
| Design    | Look for patterns to guide algorithm development.<br>  Write an algorithm—steps needed to solve the problem.<br>  Refine the steps in the algorithm and walk through it. |
| Implementation | Translate the design into a programming language.<br>  Fix errors.<br>  Create an executable program.<br> Test the program. |
| Maintenance | Update the program to keep up with a changing world.<br> Enhance it.<br> Correct bugs as they are found. |

* Some analysis and design tools were introduced:
    * naming the objects that help solve a problem
    * developing algorithms
    * refining one or more steps of an algorithm
    * using the Input/Process/Output pattern

* The sample program we presented previews the details to be discussed in the next chapter. C++ types were previewed: fundamental and compound.

* Testing is important, but it does not prove the absence of errors. Testing can and does detect errors, but it can only build confi dence that the program appears to work.

## EXERCISES

1. What activities can be performed when analyzing problems?
2. What are the characteristics of a good algorithm?
3. What is the diff erence between objects used to store output values and objects that store the values input by the user?
4. List the three characteristics of objects.
5. What activities can be performed when designing programs?
6. What is one “deliverable” of design?
7. What type of object would you use to store the number of students registered in a course?
8. What type of object would you use to store π?
9. What type of object would you use to store the words of a Shakespeare play?
10. What is the deliverable from the implementation phase of program development?
11. Does a program that runs work correctly? Justify your answer.
12. Write an algorithm that describes how to get to where you live.
13. Write an algorithm for fi nding any phone number in the phone book. Will the search always be successful?
14. Write an algorithm that instructs someone to arrive at your home on foot.
15. Obtain the instructions necessary to create, compile, link, and execute a C++ program on your system. You may need to seek out a login procedure and/or basic editing commands and compiling commands. After this, write a complete algorithm that provides all necessary steps to successfully guide a novice to complete a program through testing. Your algorithm may contain steps such as “Compare example output to program output,” “Create a new file,” and “Compile the program.”

## PROBLEM SOLVING: WRITING ALGORITHMS

### 1A SIMPLE AVERAGE

Write an algorithm that will compute the average of three test scores of equal weight.

### 1B WEIGHTED AVERAGE

Write an algorithm that will compute the course grade using this weighted scale:

| *Assessment* | *Weight* |
|--------------|----------|
| Quiz average | 20%      |
| Midterm      | 20%      |
| Lab grade    | 35%      |
| Final exam   | 25%      |

### 1C WHOLESALE COST

You happen to know that a store has a 25% markup on compact disc (CD) players. If the retail price (what you pay) of a CD player is \$189.98, how much did the store pay for that item (the wholesale price)? In general, what is the wholesale price for any item given its retail price and markup? Analyze the problem and design an algorithm that computes the wholesale price for any given retail price and any given markup. Use this formula and a little algebra to solve for wholesale price: retail price = wholesale price \* (1 + markup).

### 1D TIME DIFFERENCES

Write an algorithm that takes two diff erent train departure times (where 0 is midnight, 0700 is 7:00 a.m., 1314 is 14 minutes past 1:00 p.m., and 2200 is 10 p.m.) and prints the diff erence between the two times in hours and minutes. Assume both times are on the same date and that both times are valid. For example, 1099 is not a valid time because the last two digits are minutes, which should be in the range of 00 through 59. 2401 is not valid because the hours (the fi rst two digits) must be in the range of 0 through 23 inclusive. For example, if train A departs at 1255 and train B departs at 1305, the difference would be 0 hours and 10 minutes.

