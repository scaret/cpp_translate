# 第1章 用C++来解决问题

**本章提要**

在本章，我们将会介绍针对一个问题提出计算机解决方案需要做哪些事。首先，我们可能需要用一到两个段落来做一下问题的描述。然后，对于从理解这个问题的描述到具体实现一个可行的计算机解决方案的这个过程，我们就称之为解决问题。接下来，我们将在本章学习以下内容：

* 示范解决问题的过程。
* 介绍算法的特征。
* 介绍如何利用算法模式来辅助程序设计。
* 介绍类与其多个实体对象之间的关系，以及这些对象的名称、状态和操作集。
* 介绍在软件开发的实现阶段中可能出现的错误分类。

*****

## 1.1 解决问题

解决问题的方法有很多种。在本章，我们首先要研究的是一个三步走策略，即分析、设计、实现策略。

| 步骤 | 具体活动 |
|-----|---------|
| **分析** | 理解待解决问题。 |
| **设计** | 根据解决方案的概要设计出算法。|
| **实现** | 写出可执行程序的代码。 |

接下来，我们将通过一个“计算课程成绩”的示例来逐一示范这个三个步走策略中的各个步骤，看看它们在解决问题过程中所发挥的作用，并以此开始《计算基础》这门课的学习。

### 1.1.1 分析（提问、考察、研究）

程序的开发通常始于针对某个问题的研究或分析。这是很显然的，如果我们想要确定一个程序要执行哪些操作，当然先得理解该程序要解决的问题。如果该问题已经完成了书面化描述，我们就可以从阅读这个问题开始进入分析步骤了。

在分析一个问题的过程中，做好对程序所需信息数据的命名工作会是很有帮助的。例如，我们可能会被要求计算出特定飞机在特定气象条件（譬如温度、风向等）下，在指定机场跑到上可以成功起飞时的最大重量。这时，我们就可以在分析问题时将这项要计算的信息命名为```maximumWeight```，并将计算该信息所需的信息命名为```temperature``` 、```windDirection```等。

虽然这些数据并不代表整个解决方案，但它们的确表述了问题的某个重要部分。这些数据名称会是我们编写程序，以及在程序中进行计算工作时要用到的符号，譬如可能我们要计算的是飞机在```temperature```的值为19.0时的```maximumWeight```。总而言之，这些数据通常都要经过各种形式的操作或处理之后，才能得到我们所期待的结果。在这其中，有些数据得从用户那里获取，也有些数据得经过一些相乘或相加的运算，还有些数据得在计算机屏幕上显示。

在某些时候，这些数据的值会被存储在计算机的内存中。当程序运行时，相同内存位置上的值是会变化的。另外，这些数据值通常都会有一个类型，譬如整数类型、浮点数类型、字符串类型或其他各种存储类型。对于这种用于在程序运行时存储这些可变值的内存区块，我们称之为*变量*。

我们将会看到这些数据值施以某种特定行为意义的操作，这些特定的意义有助于我们将这些数据区分成由计算机显示的数据——*输出*，和计算出结果所需的数据——*输入*。这些变量帮我们总结出了一个程序必须得做的事情。

* **输入：** 用户在解决问题过程中必须提供的信息。
* **输出：** 计算机必须显示的信息。

通常情况下，我们都可以通过回答“给定输入能得到什么输出？”这个题目来更好地理解自己要解决的问题。因此，针对待解决的问题来进行举例往往是个不错的思路。下面就是两个通过变量名的选择来精准描述其存储值的问题：

| 待解决的问题 | 变量 | 输入/输出 | 问题样例 |
|------------|-----|----------|---------|
| 每月还贷计算 | amount <br> rate <br> months <br> payment | 输入 <br> 输入 <br> 输入 <br> 输出 | 12500.00 <br> 0.08 <br> 48 <br> 303.14 |
| 计算莎士比亚的<br>某指定剧本中<br>某特定词的<br>出现次数 | theWork <br> theWord <br> howOften | 输入 <br> 输入 <br> 输出 | 《无事生非》 <br> thee <br> 74 |

现在来总结一下，我们在分析问题过程中需要：

1. 阅读并理解待解决问题的书面说明。
2. 定义用来表示问题答案的数据，以作为输出。
3. 定义用户为获取问题答案必须要键入的数据，以作为输入。
4. 创建一些问题样例，以作汇总之用（就像上面做的那样）。

当然，教科书上的问题有时会提供清楚的变量名，以及输入/输出时用到的值类型（譬如字符串、整数、浮点数等）。如果没有的话，它们识别起来也往往是相对比较容易的。但在现实中，对于相当规模的问题来说，分析问题这个步骤通常是需要花费大量精力的。

*****

**自检题**

1-1. 请针对英镑与美元之间的汇率转换问题，分别为用于存储用户输入值，以及程序输出值的变量赋予有意义的命名。

1-2. 请针对“从拥有200张CD的播放器中选取一张CD来播放”这个问题，分别设定用来表示所有CD，以及表示用户所选择的那张CD的变量名。

**问题分析示例**

*问题：* 请根据右侧的课程成绩估算表，用作业项目、期中考试和期末考试这三项的加权值计算出这一门课的成绩。

| 参考项 | 权重比 |
|-------|-------|
| 作业项目 | 50% |
| 期中考试 | 20% |
| 期末考试 | 30% |

如前所述，问题分析的工作要从理解问题的书面描述开始，然后确定解决该问题所需要的输入和输出。在这里，先定义并命名好输出的内容是一个不错的切入点。因为，输出内容中通常存储的就是这个待解决问题的答案，它会驱使我们去深入理解这个待解决的问题。

一旦我们定义好了解决问题所需的数据，并赋予它们有意义的变量名之后，就可以将注意力转向如何完成任务了。就这个特定的问题而言，它要输出应该就是实际的课程成绩，我们将这个要输出给用户的信息命名为```courseGrade```。然后为了让这个问题更具有通用性，我们要让用户自己键入产生计算结果所需的值。毕竟如果这个程序可以要求用户提供所需的数据，那它以后就可以用来计算多位学生任何一门课程的成绩了。在这里，我们将需要用户输入的这些数据命名为：```projects```、```midterm```和```finalExam```。这样一来，我们目前就已经完成了问题分析这一步骤中的前三个动作：

1. 理解待解决的问题。
2. 定义要输出的信息：```courseGrade```。
3. 定义要输入的数据：```projects```、```midterm```和```finalExam```。

接下来就需要有一个问题样例，它有助于我们创建一个测试用例（test case），以验证输入的数据和程序产生的输出结果。例如，当```projects```为74.0、```midterm```为79.0、```finalExam```为84.0时，其平均加权值应该为78.0：

```LaTeX
(0.50 × projects) + (0.20 × midterm) + (0.30 × finalExam)
   (0.5 × 74.0)   +   (0.2 × 79.0)   +  (0.30 × 84.0)
      37.0        +      15.8        +      25.2
                         78.0
```

到这里，问题的分析步骤就算完成了，我们确定了用于输入/输出的变量，这有助于我们了解计算机解决方案需要做哪些事，同时还获得了一个现成的测试用例。

| 待解决的问题 | 变量 | 输入/输出 | 测试用例 |
|------------|-----|---------|--------|
| 计算某门课的成绩 | projects | 输入 | 74.0  |
|    | midterm | 输入 | 79.0 |
|    | finalExam | 输入 | 84.0 |
|    | courseGrade | 输出 | 78.0 |

*****

**自检题**

1-3. 请完成对下面问题的分析，这里你可能会需要用到一个准确的计算器。

*Problem:* Show the future value of an investment given its present  value, the number of periods (years, perhaps), and the interest rate. Be consistent with the interest rate and the number of periods; if the periods are in years, then the annual interest rate must be supplied (0.085 for 8.5%, for example). If the period is in months, the monthly interest rate must be supplied (0.0075 per month for 9% per year, for example). The formula to compute the future value of money:

*问题：* 请针对某项投资的当前价值、投资期限（可能以年为单位）以及投资利率，估算出它的未来价值。在这里，投资利率和投资期限是一体的。也就是说，如果投资期限以年为单位，那这里的投资利率就是年利率（例如8.5%，就是0.085）；如果投资期限以月为单位，那这里的投资利率就是月利率（例如年利率是9%，那月利率就是0.075）。其未来价值的计算公式如下：

$$futureValue = presentValue * (1 + rate)^{periods}$$

### 1.1.2 DESIGN (MODEL, THINK, PLAN, DEVISE, PATTERN, OUTLINE)

*Design* refers to the set of activities that includes specifying an algorithm for each program component. An *algorithm* is a step-by-step procedure for solving a problem or accomplishing some end, especially by a computer. A good algorithm must

* list the activities that need to be carried out
* list those activities in the proper order

Consider an algorithm to bake a cake taken from directions for carrot cake:

* Preheat oven to 350° F.
* Grease sides and bottom of each pan.
* Blend ingredients in a large bowl.
* Pour batter into the pan and bake immediately. For cupcakes, fill to 2/3 full.
* Bake following the chart below.
* Cake is done when toothpick inserted in center comes out clean.

If the order of the steps is changed, the cook might get a very hot cake pan with raw cake batter in it. If one of these steps is omitted, the cook probably won’t get a baked cake—or there might be a fi re. An experienced cook may not need such an algorithm. However, cake-mix marketers cannot and do not presume that their customers have this experience. Good algorithms list the proper steps in the proper order and are detailed enough to accomplish the task.

*****

**SELF-CHECK**

1-4. Cake recipes typically omit a very important activity. Describe an activity that is missing from the algorithm above.

An algorithm often contains a step without much detail. For example, “Blend ingredients in a large bowl” isn’t very specifi c. What are the ingredients? If the problem is to write a recipe algorithm that humans can understand, this step could be refi ned a bit to instruct the cook on how to blend the ingredients. Th e refi nement to this step could be “Empty the cake mix into the bowl and mix in the milk until smooth,” or for scratch bakers:

* Sift the dry ingredients.
* Place the liquid ingredients in the bowl.
* Add the dry ingredients a quarter-cup at a time, whipping until smooth.

Algorithms may be expressed in *pseudocode*—instructions expressed in a language that even nonprogrammers understand. Pseudocode is written for humans, not for computers. Pseudocode algorithms are an aid to program design.

Pseudocode is very expressive. One pseudocode instruction may represent many computer instructions. Pseudocode algorithms are not concerned about issues such as misplaced punctuation marks or the details of a particular computer system. Pseudocode solutions make design easier by allowing details to be deferred. Writing an algorithm can be viewed as planning. A program developer can design with pencil and paper and sometimes in their head.

### 1.1.3 ALGORITHMIC PATTERNS

Problems often require input from the user in order to compute and display the desired information. This particular flow of activities—input/process/output—occurs so often, in fact, that it can be viewed as a pattern. It is one of several algorithmic patterns you will fi nd helpful in the design of programs.

A *pattern* is anything shaped or designed to serve as a model or a guide in making something else. An algorithmic pattern serves as a guide to help solve problems. For instance, the following Input/Process/Output (IPO) algorithmic pattern can be used to help design our fi rst problem. In fact, this IPO pattern can be used to help design almost all of the programs in the first five chapters of this textbook.

|Algorithmic Pattern: |  *Input/Process/Output* |
|------------|-----------------------------|
| Pattern:   | Input/Process/Output (IPO)  |
| Problem:   | The program requires input from the user in order to compute and display the                   desired information. |
| Outline:   | 1. Obtain the input data. <br> 2. Process the data in some meaningful way. <br> 3. Output the results. <br> |

**Code Example:**

```C++
int n1, n2, n3;
oat average;

// Input
cout << "Enter three numbers: ";
cin >> n1 >> n2 >> n3;

// Process
average = (n1 + n2 + n3) / 3.0;

// Output 
cout << "Average = " << average;
```

*****

This algorithmic pattern is the first of several. In subsequent chapters, you’ll see other algorithmic patterns such as Guarded Action, Alternative Action, and Indeterminate Loop. To use an algorithmic pattern eff ectively, you should first become familiar with it. Register this Input/Process/Output algorithmic pattern and look for this pattern while developing programs. Th is allows you to design programs more easily. For example, if you discover you have no meaningful values for the input data, it may be that you have placed the process step *before* the input step. Or you may have skipped the input step altogether.

Patterns help solve other kinds of problems. Consider this quote from Christopher Alexander’s book, *A Pattern Language* \[Alexander 77\]: 
> Each pattern describes a problem which occurs over and over again in our environment, and      then describes the core of the solution to that problem, in such a way that you can use this   solution a million times over, without ever doing it the same way twice. 

Even though Alexander was describing patterns in the design of furniture, gardens, buildings, and towns, his description of a pattern can also be applied to computational problem solving. The IPO pattern frequently pops up during program design. It guides the solution to many problems.

### 1.1.4 AN EXAMPLE OF ALGORITHM DESIGN

The Input/Process/Output pattern guides the design of the algorithm that relates to our course grade problem.

| **Three-Step Pattern** | **Pattern Applied to a Specifi c Algorithm** |
|-------------------------|----------------------------------------------|
| 1. Input <br>  2. Process <br> 3. Output | 1. Read in projects, midterm, and nalExam <br> 2. Compute courseGrade <br> 3. Display courseGrade |

Although algorithm development is usually an iterative process, a pattern provides an outline of the activities necessary to solve this problem.

*****

**SELF-CHECK**

1-5. Read the three activities of the algorithm above. Do you detect a missing activity?

1-6. Read the three activities of the algorithm above. Do you detect any activity out of order?

1-7. Would this previous algorithm work if the first two activities were switched?

1-8. Is the algorithm detailed enough to compute courseGrade?

There currently is not enough detail in the process step of the course grade problem. Th e algorithm needs further refi nement. Specifi cally, exactly how should the input data be processed to compute the course grade? Th e algorithm omits the weighted scale described in the problem specifi cation. The process step should be refined a bit more as shown in step 2:

1. Obtain projects, midterm, and nalExam from the user
2. Compute courseGrade = (50% projects) + (20% midterm) + (30% nalExam)
3. Display the value of courseGrade

It has been said that good artists know when to put down the brush. Deciding when a painting is done is critical for its success. By analogy, a designer must decide when to stop designing. This is a good time to move on to the third phase of problem solving, which is implementation.

In summary, here is what has been accomplished so far:

* The problem is understood
* Variables have been identifi ed
* Expected output of a sample problem is known (78.0%)
* An algorithm has been developed

### 1.1.5 IMPLEMENTATION (FULFILLMENT, OPERATION, USAGE)

A computer is a programmable electronic device that can store, retrieve, and process data. Programmers can simulate an electronic version of an algorithm by following the algorithm and manually performing the activities of storing, retrieving, and processing data using pencil and paper. The following algorithm walkthrough is a human (non-electronic) execution of the algorithm:

1. Retrieve some example values from the user and store them as shown:<br> projects = 80 <br> midterm = 90 <br>nalExam = 100

2. Retrieve the values and compute courseGrade as follows:<br>

```
   courseGrade = (0.5 × projects) + (0.2 × midterm) + (0.3 × nalExam)
                   (0.5 × 80.0)   +   (0.2 × 90.0)  +  (0.3 × 100.0)
                        40.0      +     18.0        +     30.0 
                                courseGrade = 88.0
```

3. Display the value stored in courseGrade to show 88%

### 1.1.6 A C++ PROGRAM

The following complete C++ program previews many programming language details presented in the next chapter. You are not expected to understand this C++ source code. For now, just peruse the source code as an implementation of the pseudocode algorithm. The three variables—projects, midterm, and nalExam—represent user input. The output variable is named courseGrade. The object cout, pronounced "see-out," stands for *common output* and allows a program to generate output. Input is made possible using the object cin, pronounced "see-in," which stands for *common input*.

```C++
/*
 * This program computes and displays a nal course grade as a 
 * weighted average after the user enters the appropriate input.
 *
 * File name: CourseGrade.cpp
 */

#include <iostream>         // for cin and cout
#include <string>           // for string
using namespace std;        // avoid writing std::cin std::cout std::string

int main() {
    // Explain what this program does.
    cout << "This program computes a weighted course grade." << endl;

    // Read in a string
    cout << "Enter the student's name: ";
    string name;
    cin >> name;

    // I)nput projects, midterm, and nalExam
    double projects, midterm, finalExam;

    cout << "Enter project score: ";
    cin >> projects;

    cout << "Enter midterm: "; 
    cin >> midterm;

    cout << "Enter finalexam: ";
    cin >> finalExam;

    // P)rocess
    double courseGrade = (0.5 * projects) +
                         (0.2 * midterm) +
                         (0.3 * finalExam);

    // O)utput the results
    cout << name << "'s grade: " << courseGrade << "%" << endl;
}
```

**Dialogue**

This program computes a weighted course grade.

> Enter the student's name: ***Dakota*** <br>
> Enter project score: ***80*** <br>
> Enter midterm: ***90*** <br>
> Enter nal exam: ***100*** <br>
> Dakota's grade: 88%       <br>  

### 1.1.7 TESTING

The important process of testing may, can, and should occur at any phase of problem solving. The actual work can be minimal, and it’s worth the eff ort. However, you may not agree until you have experienced the problems incurred by *not* testing. Testing activities can occur during all phases of program development:

* During analysis, establish test case problems to confirm your understanding of the problem.
* During design, walk through the algorithm to ensure that it has the proper steps in the proper order.
* During testing, run the program several times with diff erent sets of input data. Confirm that the results are correct.
* Review the problem specifi cation. Does the running program do what was requested?

You should have one or more test case problems before the program is coded—not after. Determine the input values and what you expect for output. Using 80, 90, and 100 as input and expecting the output to be 88% is one such test case. When the program fi nally does generate output, the expected result can then be compared to the output of the running program. Adjustments must be made any time the predicted output does not match the program output. Such a conflict indicates that the problem example, the program output, or perhaps both are incorrect.

Testing with several test cases helps avoid the misconception that a program is correct just because the program runs successfully and generates output. The output could be wrong! Simply executing a program does not make that program correct. Test cases provide confi dence that the program does work.

However, even exhaustive testing does not prove a program is correct. E. W. Dijkstra has argued that testing only reveals the presence of errors, not the absence of errors. Even with correct program output, the program is not proven correct. Testing reduces errors and increases confidence that the program works correctly.

*****

**SELF-CHECK**

1-9. If the programmer predicts courseGrade should be 100.0 when all three inputs are 100.0 and the program displays courseGrade as 75.0, what is wrong: the predicted output, the program, or both?

1-10. If the programmer predicts courseGrade should be 90.0 when projects is 80.0, midterm is 90.0, and nalExam is 100.0 and the program outputs courseGrade as 88, what is wrong: the prediction, the program, or both?

1-11. If the programmer predicts courseGrade should be 88 when projects is 80.0, midterm is 90.0, and nalExam is 100.0 and the program outputs courseGrade as 90.0, what is wrong: the prediction, the program, or both?

## 1.2 OBJECTS, TYPES, AND VARIABLES

To input something that can be used by a program, there must be a place to store it in the memory of the computer. Bjarne Stroustrup, the creator of C++, writes
> We call such a “place” an object. An object is a region of memory with type that specifi es what kind of information can be placed in it. A named object is called a variable. For example, character strings are put into string variables and integers are put into int variables. You can think of an object as a “box” into which you can put a value of the object’s type.

For example, the int type used in the previous program stores whole numbers, or integers. Some operations on int variables include addition, subtraction, multiplication, and division. Note that C++ uses \* for the multiplication operator (using x would be confusing).
> double courseGrade = 0.5\*projects + 0.2\*midterm + 0.5\* finalExam;

The oat and double types (double is twice the size of a oat) store numeric values with a fractional part. The C++ string type stores character sequences as "Firstname I. Lastname" along with an integer to maintain the number of characters in that string.

*Objects* are entities stored in computer memory. An object is understood by the types of values the object stores—its *attributes*—and the operations that can be applied to that object—its *behavior* \[Booch\]. Every object has

* a name to store and retrieve the values of that object
* values stored in computer memory, which is known as the object’s state
* a set of operations such as addition, input, output, assignment

These three characteristics of objects—name, state, and operations—were all illustrated in the course grade program. It used three numeric objects stored as projects, midterm, and finalExam that were read in from the keyboard. Each of these objects is capable of storing the value of an integer such as 79 or 90. Th ese objects, along with available operations such as input, multiplication, and addition, computed the courseGrade. An assignment operation was used to store it as a numeric object. An output operation with cout << was used so the user could see the results of the processing.

**Characteristics of Objects in the First Program**

|     |      |
|-----|------|
| Name: | Each of the four numeric objects has its own identity because each has its own name. The first of the four numeric objects was stored as the variable named projects. |
| State: | The value of projects was set with an input operation using cin >> The state of courseGrade was defi ned with an assignment operation using the = operator. The state of courseGrade was retrieved during output with cout. |
| Operations: | Other operations available for the int objects included addition (+) and multiplication (\*). |

C++ has fundamental types and compound types. Th e *fundamental* types store one value that corresponds directly to hardware with a fixed size. The type determines what values can be stored into that object and what operations can be performed. With numeric types such as int and double, the number of bytes, which varies for different computers, determines the range of values that can be stored in it.

| **Data Type** | **size** | **Typical Range of Values (varies)** |
|---------------|----------|--------------------------------------|
| short         | 2 bytes (16 bits) |  -32768 to 32767            |
| unsigned short |  2 bytes  |         0 to 65,535                |
| int            |  4 bytes  |         -2147483648 to 2147483647  |
| unsigned int   |  4 bytes  |         0 to 4294967295            |
| unsigned long  |  8 bytes  |         0 to 18446744073709551615  |
| float          |  4 bytes  |         3.4E +/- 38 (7 digits)     |
| double         |  8 bytes  |         1.7E +/- 308 (15 digits)   |
| char           |  1 byte   |         0 to 255                   |
| bool           |  1 byte   |         true or false              |

A *compound* type is a type that is defi ned in terms of another type. C++ has these compound types presented in this textbook: references, functions, classes, arrays, and pointers. For example, string is a reference type made up of characters and other data. It has operations to find the length of the sequence of characters and another operation to create a substring from a string given the starting and ending indexes (there are many more operations that will be explored in a later chapter):

```C++
string aString = "A sequence of characters"; // Output: 
cout << aString.length() << endl;            // 24 
cout << aString.substr(2, 8) << endl;        // sequence 
```

In addition to the string type, two other reference types are used immediately. Th e istream type object named cin has operations to read from an input source such as the keyboard or a fi le on disk. The ostream type object named cout helps generate output.

**SELF-CHECK**

1-12. Describe the values stored in objects of type double.

1-13. Name two operations for double objects.

1-14. Describe the values stored in objects of the int type.

1-15. Name two operations for int objects.

1-16. Describe the values stored in string objects.

1-17. Which of the types above store precisely one value?

## CHAPTER SUMMARY

This chapter presented a three-step problem-solving strategy of analysis, design, and implementation. The table below shows some of the activities performed during each of these three phases. The maintenance phase has been added to show how the three steps fit into the complete program life cycle. Th e maintenance phase actually requires the majority of the time, energy, and money of the program’s life cycle.

| **Phase** | **Activities You Might Perform** |
|-----------|----------------------------------|
| Analysis  | Read and understand the problem statement. <br> Determine the input and output objects. <br> Solve a few sample problems.|
| Design    | Look for patterns to guide algorithm development.<br>  Write an algorithm—steps needed to solve the problem.<br>  Refine the steps in the algorithm and walk through it. |
| Implementation | Translate the design into a programming language.<br>  Fix errors.<br>  Create an executable program.<br> Test the program. |
| Maintenance | Update the program to keep up with a changing world.<br> Enhance it.<br> Correct bugs as they are found. |

* Some analysis and design tools were introduced:
    * naming the objects that help solve a problem
    * developing algorithms
    * refining one or more steps of an algorithm
    * using the Input/Process/Output pattern

* The sample program we presented previews the details to be discussed in the next chapter. C++ types were previewed: fundamental and compound.

* Testing is important, but it does not prove the absence of errors. Testing can and does detect errors, but it can only build confi dence that the program appears to work.

## EXERCISES

1. What activities can be performed when analyzing problems?
2. What are the characteristics of a good algorithm?
3. What is the diff erence between objects used to store output values and objects that store the values input by the user?
4. List the three characteristics of objects.
5. What activities can be performed when designing programs?
6. What is one “deliverable” of design?
7. What type of object would you use to store the number of students registered in a course?
8. What type of object would you use to store π?
9. What type of object would you use to store the words of a Shakespeare play?
10. What is the deliverable from the implementation phase of program development?
11. Does a program that runs work correctly? Justify your answer.
12. Write an algorithm that describes how to get to where you live.
13. Write an algorithm for fi nding any phone number in the phone book. Will the search always be successful?
14. Write an algorithm that instructs someone to arrive at your home on foot.
15. Obtain the instructions necessary to create, compile, link, and execute a C++ program on your system. You may need to seek out a login procedure and/or basic editing commands and compiling commands. After this, write a complete algorithm that provides all necessary steps to successfully guide a novice to complete a program through testing. Your algorithm may contain steps such as “Compare example output to program output,” “Create a new file,” and “Compile the program.”

## PROBLEM SOLVING: WRITING ALGORITHMS

### 1A SIMPLE AVERAGE

Write an algorithm that will compute the average of three test scores of equal weight.

### 1B WEIGHTED AVERAGE

Write an algorithm that will compute the course grade using this weighted scale:

| *Assessment* | *Weight* |
|--------------|----------|
| Quiz average | 20%      |
| Midterm      | 20%      |
| Lab grade    | 35%      |
| Final exam   | 25%      |

### 1C WHOLESALE COST

You happen to know that a store has a 25% markup on compact disc (CD) players. If the retail price (what you pay) of a CD player is \$189.98, how much did the store pay for that item (the wholesale price)? In general, what is the wholesale price for any item given its retail price and markup? Analyze the problem and design an algorithm that computes the wholesale price for any given retail price and any given markup. Use this formula and a little algebra to solve for wholesale price: retail price = wholesale price \* (1 + markup).

### 1D TIME DIFFERENCES

Write an algorithm that takes two diff erent train departure times (where 0 is midnight, 0700 is 7:00 a.m., 1314 is 14 minutes past 1:00 p.m., and 2200 is 10 p.m.) and prints the diff erence between the two times in hours and minutes. Assume both times are on the same date and that both times are valid. For example, 1099 is not a valid time because the last two digits are minutes, which should be in the range of 00 through 59. 2401 is not valid because the hours (the fi rst two digits) must be in the range of 0 through 23 inclusive. For example, if train A departs at 1255 and train B departs at 1305, the difference would be 0 hours and 10 minutes.

