**C H A P T E R T E N**

Vectors

SUMMING UP

> Almost all objects studied so far either store one element of a
> specifi c value such as double and int or are made up of two or more
> possibly dissimilar elements such as Employee and

BankAccount.

COMING UP

> To get interesting things done, we often use a collection of data. For
> example, we might need a list of students, a list of phone contacts, a
> list of text threads, a list of prices at diff erent online stores,
> and so on. Th e ability to store many elements as one object is used
> to solve a wide variety of programming problems. In this chapter, we
> begin with one of the simplest, and arguably the most useful, way of
> storing data: the C++ vector type. After studying this chapter you
> will be able to

-   construct and use vector objects that store collections of any type

-   implement algorithms to process a collection of objects

-   use the sequential search algorithm to locate a specifi c element in
    > a vector

-   pass vector objects to functions

-   sort vector elements into ascending or descending order understand
    > how to search with the classic binary search algorithm

10.1 THE STANDARD C++ vector CLASS

> Th e vector class constructs objects that store *collections* of
> objects. All vector objects are considered *homogeneous* because the
> objects in the collection are of the same type—a collection of numbers
> or a collection of string objects, for example. Th e objects in the
> collection may be any one of the standard types such as int, double,
> or string. Additionally, any programmer-defi ned class that has a
> default constructor can be contained in a vector. You can have a
> collection of any objects that you can dream up. Here are two general
> forms for initializing vector objects:
>
> 279
>
> General Form 10.1 vector *initialization*
>
> vector <*type*> *vector-name*(*capacity*);

- or vector <*type*> *vector-name*(*capacity*, *initial-value*);

-   *type* specifi es the class of objects stored in the vector.

-   *vector-name* is any valid C++ identifi er.

-   *capacity* is an integer expression representing the maximum number
    > of elements that can be stored into the vector.

-   Th e optional *initial-value* is the value that will be assigned to
    > every element in the vector. If there is only one argument
    > (*capacity*), then the default constructor for that class sets the
    > initial values (recall that with double and int, the default
    > values will be garbage).

> Examples of vector Initializations
>
> vector <int> garbage(1000000); // A million integers of unknown
> value vector <double> x(100, 99.9); // Store 100 numbers, all
> equal to 99.9 vector <string> names(20, "TBA"); // Store 20
> strings, all equal to "TBA"
>
> To use vector, include <vector>, and when using namespace std;
> you can write vector instead of std::vector.
>
> \#include <vector> // For the vector<type> class using
> namespace std;
>
> It should be noted that the vector syntax and algorithms that follow
> apply to primitive C++ arrays declared, such as int garbage\[100\] and
> string names\[20\]. Th e main benefi ts of using vectors include:

-   vector objects check for invalid indexes such as accessing the
    > element at index -1.

-   vector has several useful member functions like resize(200).

-   vector objects can have all elements initialized when constructed,
    > while primitive C++ arrays require an additional for loop to do
    > the same thing.

10.1.1 ACCESSING INDIVIDUAL ELEMENTS IN A COLLECTION

> Any vector object supports access to any element by using an index
> into the vector. An individual vector element can be referenced
> directly through subscripts that are written with square brackets \[
> and \].

**General Form 10.2** *Accessing one* vector *element*

> *vector-name* \[*integer-expression*\]
>
> Th e subscript range of a C++ vector is an integer value in the range
> of 0 through its capacity - 1. Th erefore, the individual objects of x
> declared as vector <double> x(8, 0.0);
>
> may be referenced using the integer subscripts 0, 1, 2, 3, . . . 7,
> but not 8. Values can be stored into the fi rst two vector elements of
> x with these two assignment statements:
>
> // Assign new values to the rst two elements of vector named x x\[0\]
> = 2.6; x\[1\] = 5.7;
>
> Because C++ has zero-based indexing, the fi rst vector element is
> referenced with subscript 0 or as x\[0\], and the fi fth element with
> subscript 4 or x\[4\]. Th is subscript notation allows individual
> vector elements to be displayed, used in expressions, and modifi ed
> with assignment and input operations. In fact, you can do anything to
> an individual vector element that can be done to an object of the same
> class.
>
> Th e familiar assignment rules apply to vector elements. For example,
> a string constant cannot be assigned to a double, and a string
> constant cannot be stored in a vector element declared to store int
> values.
>
> x\[2\] = "Wrong type of constant"; // ERROR: x stores numbers
>
> Since any two doubles can be added with +, subscripted vector elements
> can also be used in arithmetic expressions like this:
>
> x\[2\] = x\[0\] + x\[1\]; // Store 8.3

Keyboard input can also be used to set the state of vector elements like
this:

> cout << "Enter two numbers: "; cin >> x\[3\] >>
> x\[4\];
>
> Dialogue
>
> Enter two numbers: ***9.9 5.1***
>
> After this user input of ***9.9*** and ***5.1*** into the fourth and
> fi fth vector elements and the previous assignments to the fi rst
> three vector elements, the state of x now looks like the following.
>
> capacity ()

x\[0\] x\[1\] x\[2\] x\[3\] x\[4\] x\[5\] x\[6\] x\[7\]

> elements of x:

10.1.2 vector PROCESSING WITH DETERMINATE for LOOPS

> Programmers must frequently reference many consecutive vector
> elements. Th e simplest case might be to display all the meaningful
> elements of a vector. Th e C++ for loop provides a convenient way to
> do this. Th is program includes the same vector assignments as above,
> with a for loop added at the end to display the fi rst n = 5 elements.
> Notice that x\[5\], x\[6\], and x\[7\] still have the initial value of
> 0.0.
>
> \#include <iostream>
>
> \#include <vector> // For the vector<type> class using
> namespace std;
>
> int main() { vector<double> x(8, 0.0);
>
> // Assign new values to the rst two elements of vector named x x\[0\]
> = 2.6; x\[1\] = 5.7;
>
> x\[2\] = x\[0\] + x\[1\]; // Store 8.3
>
> cout << "Enter two numbers: "; cin >> x\[3\] >>
> x\[4\];
>
> int n = 5; // assert: n represents the number of meaningful elements
>
> // Display the meaningful elements of x--the rst n elements cout
> << "\\nThe rst " << n << " elements of x: " <<
> endl; for (int index = 0; index < n; index++) { cout << "x\["
> << index << "\]: "; cout << x\[index\] <<
> endl; }
>
> return 0; }
>
> Dialogue
>
> Enter two numbers: ***9.9 5.1***
>
> The rst 5 elements of x:
>
> x\[0\]: 2.6 x\[1\]: 5.7 x\[2\]: 8.3 x\[3\]: 9.9 x\[4\]: 5.1
>
> Th e fi rst n elements of x are easily referenced by altering the int
> named index, which acts both as the counter in the for loop and as the
> subscript inside the for loop (x\[index\]). With index serving both
> roles—as shown in the code above—the specifi c vector element
> referenced as x\[index\] will depend on the value of index. For
> example, when index is 0, x\[index\] is a reference to the fi rst
> element in x; when index is 4, x\[index\] is a reference to the fi fth
> element of x.

10.1.3 PROCESSING THE FIRST n ELEMENTS IN A vector

> Here is another example of a for loop that compares the fi rst n
> vector elements to fi nd the largest fl oating-point value using the
> vector x in the preceding program.
>
> // First set the largest as the rst element . . . double largest =
> x\[0\];
>
> // . . . then compare all other vector elements x\[1\] through
> x\[n-1\] for(int i = 1; i < n; i++) { if (x\[i\] > largest)
> largest = x\[i\]; }
>
> // Display the largest cout << "The largest element in vector x
> = " << largest;
>
> Output
>
> The largest element in vector x = 9.9

A vector often stores fewer meaningful elements than its capacity. Th
erefore, you usually need to have an object that stores the number of
elements in the vector that are currently under consideration. In the
previous code, n was used to limit the elements being referenced. Only
the fi rst fi ve elements were searched to fi nd the largest. Imagine
trying to fi nd the largest number in x without limiting the search to
the fi rst n elements. Th e largest could incorrectly be some garbage
value at index 5, 6, or 7.

> Th e Determinate Loop pattern with for loops conveniently performs
> vector processing, which is the inspection of, reference to, or modifi
> cation of a selected number of vector elements. Th e number of
> elements (n here) is the predetermined number of vector elements that
> must be processed. Algorithms that include vector processing in this
> chapter include

-   displaying some or all elements of a vector

-   fi nding the sum, average, or largest of all vector elements
    > searching for a particular object in the vector

-   arranging elements in a certain order (ordering elements from
    > largest to smallest or alphabet-izing a vector of string objects
    > from smallest to largest)

10.1.4 OUT-OF-RANGE SUBSCRIPT CHECKING

> Th e standard vector class does not check subscripts to ensure that
> they are within the proper range of 0 through its capacity 1. Th
> erefore, the programmer must be careful to avoid subscripts that are
> not in the range specifi ed at initialization. If you are using the
> standard vector class without subscript range checking, the following
> assignments may destroy some other portion of memory, such as another
> object’s state:
>
> x\[-2\] = 4.5; // Careful! These out-of-range subscripts are not
> x\[8\] = 7.8; // guarded against and could crash your computer.
>
> Th e result could be seemingly unrelated errors, bugs, or even a
> system crash. All subscripts should be in the range of 0 through the
> vector’s capacity 1.
>
> Without range checking, an out-of-range subscript destroys other areas
> of memory. Th is creates diffi cult-to-detect bugs. More dramatically,
> your computer may “hang” or crash. Even worse, with a workstation that
> runs all the time, you may get a latency error that aff ects computer
> memory now, but won’t crash the system perhaps for weeks.
>
> As an example of a problem an out-of-range subscript may create,
> consider what might happen with the following assignment:
>
> result = x\[n\];
>
> Th e value stored at x\[n\] is one beyond the vector’s capacity. It is
> some random garbage value.
>
> On one system, this statement produced the output shown in the
> comment:
>
> // There is no warning or error with the statement cout <<
> "x\[n\]: " << x\[n\] << endl;
>
> Output
>
> x\[n\]: -33686019
>
> Th e standard vector class provides the at member function to avoid
> out-of-range subscripts. Th e result may look diff erent, but this
> message will gracefully terminate the program rather than store some
> random value into result:
>
> result = x.at(n); // Gracefully terminates the program. Good.
>
> To ensure your program will not run with an out-of-range index, use
> the at(int) message. Your program will then terminate early with an
> error message indicating the reason. Th is is preferable to fi xing
> errors that are diffi cult to locate. Here is what will happen with
> the vector class when using the at member function:
>
> \#include <vector> // For the vector<type> class
>
> \#include <iostream> using namespace std;
>
> int main() { vector<double> x(8);
>
> // Attempt to assign 100 to all elements of vector named x
>
> for (int i = 1; i <= x.capacity(); i++) {
>
> x.at(i) = 100; } cout << "Program would terminated above with
> x\[8\]" << endl;
>
> return 0; }
>
> Output for a program that terminated early (this will vary among diff
> erent systems)
>
> libc++abi.dylib: terminating with uncaught exception of type
> std::out\_of\_range: vector
>
> Th ere may be a temptation to always use vector::at in subsequent
> examples. However, programmers have been using subscripts for a very
> long time. You will see a lot of code with the square brackets (\[
> \]), so this textbook will rely on subscripts. Feel free to use at
> messages when developing your own programs.

10.1.5 vector::capacity, vector::resize, =

> Many messages can be sent to a standard C++ vector object. Each vector
> object is responsible for knowing how many objects it can store—its
> capacity. A vector also knows how to increase or decrease that
> capacity—a vector can resize itself.
>
> After a vector has been initialized, the vector::capacity message
> returns the maximum number of elements that the vector can hold. Th e
> vector::resize message tells the vector to change to the new capacity
> supplied as the single argument. What is weird, however, is the
> capacity message returns a larger capacity when the argument is less
> than the capacity. In the example below, v2’s capacity still shows 100
> even though at(55) terminates the program with the error message
> shown:
>
> // Demonstrate capacity and resize
>
> \#include <vector> // For the standard vector<type> class
>
> \#include <iostream> using namespace std;
>
> int main() {
>
> vector <int> v1; // v1 cannot store any elements with 0 capacity
> vector <int> v2(100, -1);
>
> cout << "v1 can store " << v1.capacity() << endl;
> cout << "v2 can store " << v2.capacity() << endl;
>
> v1.resize(22);
>
> cout << "v1 can now store " << v1.capacity() <<
> endl;
>
> // Odd behavior when the argument is less than the current capacity.
>
> // at(55) shows you can not access past the smaller capacity.
> v2.at(55) = 123;
>
> cout << "v2.at(55): " << v2.at(55) << endl;
> v2.resize(55);
>
> cout << "v2 can now store " << v2.capacity() <<
> endl; cout << "v2 has this -1s: " << v2.size() <<
> endl; cout << "v2.at(55): " << v2.at(55) << endl;
>
> return 0; }
>
> Output
>
> v1 can store 0 v2 can store 100 v1 can now store 22 v2.at(55): 123 v2
> can now store 100 v2 this many meaningless -1s: 55
>
> v2.at(55): libc++abi.dylib: terminating with uncaught exception of
> type std::out\_of\_range: vector
>
> If you resize a vector to have more capacity, the original elements in
> the lower subscripts are still there. However, if you resize a vector
> to be smaller, the elements in the higher locations are lost.
> Truncation occurs.
>
> One vector can be assigned to another. Th e vector to the left of the
> = operator becomes an exact copy of the vector to the right of =. Th e
> vector on the left, like any other object to the left of =, is
> destroyed.
>
> // Demonstrate capacity and resize
>
> \#include <iostream>
>
> \#include <vector> // For the vector<type> class using
> namespace std;
>
> int main() { vector <int> v1(3, -999); vector <int> v2;
>
> v2 = v1;
>
> // assert: v2 now stores 3 elements == -999 for(int index = 0; index
> < v2.capacity(); index++) { cout.width(5); cout <<
> v2\[index\]; }
>
> return 0;
>
> }
>
> Output
>
> -999 -999 -999

SELF-CHECK

> Use this initialization to answer the questions that follow:
>
> vector <int> x(100, 0);

10-1 How many integers can be stored in x?

10-2 Which integer subscript references the fi rst element in x?

10-3 Which integer subscript references the last element in x?

10-4 What is the value of x\[23\]?

10-5 Write the code that stores 78 into the fi rst element of x.

> 10-6 Write code that stores 1 into x\[99\], 2 into x\[98\], 3 into
> x\[97\], . . ., 99 into x\[1\], and 100 into x\[0\]. Use a for loop.

10-7 Write code that displays all elements of x on separate lines. Use a
for loop.

> 10-8 What happens when this code executes: x\[-1\] = 100; 10-9 Name
> two vector member functions.
>
> 10-10 Write the output generated by the following program:
>
> \#include <vector> // For the standard vector<type> class
>
> \#include <iostream> using namespace std;
>
> int main() { int n = 5; vector <int> x(n, 0); for(int i = 0; i
> < n; i++) { x\[i\] = i; }
>
> x.resize(2 \* n);
>
> // Show the rst ve elements are still in x for(int i = 0; i < n;
> i++) { cout.width(5); cout << x\[i\];
>
> } cout << endl;
>
> for(int i = 0; i < x.capacity(); i++) { cout.width(5);
>
> cout << x\[i\];
>
> } cout << endl;
>
> return 0; }

10.2 SEQUENTIAL SEARCH

> One of the major reasons for using vector objects is to have
> individual elements retained in the computer’s fast memory, where they
> will be frequently accessed. Th is often means searching for the
> existence of some element in the collection. So another common
> vector-processing operation involves searching. Searching examples
> include, but are certainly not limited to, searching for a student
> name in the registrar’s database, looking up the price of an item in
> an inventory, or obtaining information about a bank account. One such
> algorithm used to look up a vector element is called *sequential
> search*.
>
> Th e sequential search algorithm attempts to locate a given element by
> comparing the item being sought with every object in the vector. Th e
> algorithm searches in a one-after-the-other (sequential) fashion.
> Sequential search continues as long as the search value has not been
> found or until there are no more elements left in the vector to
> compare.
>
> Th is sequential search algorithm is presented here within the context
> of a vector of string objects. Although the search element here will
> be a person’s name, the vector being searched could contain other
> kinds of objects—numbers, students, or employees, for example—as long
> as the object of the class can be compared with the == operator.
>
> // Initialize and show the rst n elements of vector named name
>
> \#include <iostream>
>
> \#include <string>
>
> \#include <vector> // For the standard vector<type> class
> using namespace std;
>
> // This free function uses the sequential search algorithm to return
>
> // the index of searchName in the vector or -1 if searchName is not
> found.
>
> int indexOf(string searchName, const vector<string> & names, int
> n) {
>
> // Just show the vector elements for now for (int i = 0; i < n;
> i++) { if (searchName == names\[i\]) return i;
>
> }
>
> // searchName not found return -1; }
>
> int main() {
>
> vector<string> myFriends(10); int n = 5; // Set the number of
> meaningful elements to be searched
>
> myFriends\[0\] = "Sage"; myFriends\[1\] = "Harley"; myFriends\[2\] =
> "Peyton"; myFriends\[3\] = "Quinn"; myFriends\[4\] = "Taylor";
>
> cout << "Sage is at index " << indexOf("Sage", myFriends,
> n) << endl; cout << "Peyton is at index " <<
> indexOf("Peyton", myFriends, n) << endl; cout << "Taylor
> is at index " << indexOf("Taylor", myFriends, n) << endl;
>
> if(indexOf("Not Here", myFriends, n) == -1) { cout << "Not Here
> was not found" << endl; }
>
> return 0; }
>
> Output
>
> Sage is at index 0
>
> Peyton is at index 2
>
> Taylor is at index 4
>
> Not Here was not found

SELF-CHECK

> 10-11 What value is returned if searchName is not in the vector
> referenced by names?
>
> 10-12 How many comparisons (iterations of the search loop) are
> necessary when searchName matches myFriends\[0\]?
>
> 10-13 How many comparisons (iterations of the search loop) are
> necessary when searchName matches myFriends\[n-1\]?
>
> 10-14 How many comparisons are necessary when searchName matches
> myFriends\[3\]?
>
> 10-15 How many comparisons are necessary when searchName isn’t in
> myFriends?
>
> 10-16 How many sequential search comparisons occur when the vector has
> no useful data in it—that is, when n == 0?

10.3 MESSAGES TO INDIVIDUAL OBJECTS IN A vector

> Subscript notation is used to send messages to individual elements. Th
> e vector name must be accompanied by a *subscript* to specify the
> particular vector element to which the message is sent. Th e subscript
> distinguishes the specifi c object to which the operation is to be
> applied. For example, the length of myFriends\[0\] "Sage" is
> referenced with this expression:
>
> myFriends \[0\].length(); // The length of the rst name in the vector
>
> Th e expression myFriends.length() would be an error because this
> would represent an attempt to fi nd the length of the entire vector.
> Th e length function is defi ned for string, but not for the vector
> class (although vector::resize and vector::capacity are defi ned).

Now consider determining the total assets of all BankAccount objects in
a vector of

> BankAccounts. Th e following program fi rst sets up a tiny database of
> four BankAccount objects.

Th erefore, this statement account\[0\] = BankAccount ("Baker", 0.00);

> fi rst constructs a BankAccount object with the name "Baker" and a
> balance of 0.00. Th e BankAccount object is then assigned to the fi
> rst vector element account\[0\].
>
> // Illustrates a vector of programmer-de ned objects
>
> \#include <iostream>
>
> \#include <vector> // For the vector<type> class using
> namespace std; \#include "BankAccount.h" // For the BankAccount class
>
> int main() {
>
> vector<BankAccount> account(100);
>
> // Initialize the rst n elements of account int n = 4;
>
> account\[0\] = BankAccount("Baker", 0.00); account\[1\] =
> BankAccount("Cook", 100.00); account\[2\] = BankAccount("Cartright",
> 200.00); account\[3\] = BankAccount("FensterMacher", 300.00); //
> assert: The rst n elements of account are initialized
>
> double assets = 0.0;
>
> // Accumulate balance of n BankAccount objects stored in account for
> (int i = 0; i < n; i++) { assets += account\[i\].getBalance(); }
> cout << "Assets: " << assets << endl;
>
> return 0; }
>
> Output
>
> Assets: 600

SELF-CHECK

> 10-17 Write the output generated by the following program:
>
> \#include <iostream>
>
> \#include <vector> // For the vector<type> class
>
> \#include <string> // For the string class using namespace std;
>
> int main() { vector<string> s(10);
>
> // Initialize the rst 4 elements of account s\[0\] = "First"; s\[1\] =
> "Second"; s\[2\] = "Third"; s\[3\] = "Fourth"; int n = 4;
>
> for (int i = 0; i < n; i++) {
>
> cout << s\[i\].substr(1, s\[i\].length() - 2) << " "; }
>
> return 0; }

10.3.1 INITIALIZING A VECTOR OF OBJECTS WITH FILE INPUT

> In some of the preceding programs, the vectors of objects were
> initialized in several assignment statements. vector objects can also
> be initialized through disk fi le input. To demonstrate, imagine the
> following is part of the input data fi le named bank.data with a total
> of 12 accounts on 12 lines:
>
> Cust0 0.00
>
> AnyName 111.11
>
> Alex 222.22
>
> Andy 333.33
>
> Ash 444.44
>
> Cust5 555.55
>
> . . . fi ve lines are omitted . . .
>
> Cust11 1111.11
>
> If the vector is declared with a maximum capacity of 20 like this,
> then the fi rst BankAccount object can be stored in account\[0\]:

vector <BankAccount> account(20); // assert: account could store
20 default BankAccount objects So an object named numberOfAccounts
starts at 0:

> int numberOfAccounts = 0;
>
> Th en the vector of BankAccount objects can be initialized one account
> at a time with these steps:

1.  Input two items per line—a name and a balance.

2.  Construct a BankAccount and store it into the next available
    > vector location.

3.  Increase the number of accounts by 1.

> Th e vector::capacity function will also be used to safeguard against
> using subscripts beyond the account’s boundaries of 0 through 19.
>
> Th e following while loop test expression should be true before a
> BankAccount object can be added at the next available location in the
> vector. If there are no more data in the fi le, (inFile >> name
> >> balance) is false and the loop will terminate. Also, if there
> are more data in the fi le but no more room in the vector,
> (numberOfAccounts < account.capacity()) is false and the loop
> terminates for a diff erent reason—there is no room.
>
> while ((inFile >> name >> balance) &&
>
> (numberOfAccounts < account.capacity())) {
> account\[numberOfAccounts\] = BankAccount(name, balance);
> numberOfAccounts++; }
>
> While there is room for another element and there are more data in the
> fi le, the repeated part executes. Inside the loop, the two objects
> (name and balance) are passed on to the BankAccount constructor to
> construct a BankAccount, which is then stored in the next consecutive
> vector element. Th is initialization and assignment must occur before
> numberOfAccounts is incremented from 0 to 1 during the fi rst
> iteration of the loop.
>
> Now numberOfAccounts accurately indicates the number of accounts
> processed so far, and the fi rst BankAccount object is stored into
> account\[0\]. During each loop iteration, numberOfAccounts represents
> not only the total number of meaningful accounts stored in the vector,
> but also the next available vector subscript into which the next
> BankAccount object can be stored. When the end of the fi le is
> encountered, numberOfAccounts will have the correct value—one greater
> than the subscript storing the last account.
>
> Th is processing is shown in the context of a complete program which
> sets up a small database of bank customers:
>
> // Initialize a vector of BankAccount objects through le input
>
> \#include <vector> // For the vector<type> class
>
> \#include <fstream> // For the ifstream class
>
> \#include <iostream> // For cout and endl
>
> \#include <string> // For the string class using namespace std;
> \#include "BankAccount.h" // For the BankAccount class
>
> int main() { string leName = "bank.data"; ifstream inFile(
> leName.c\_str());
>
> if (!inFile) { cout << "\*\*Error\*\* " << leName <<
> " was not found" << endl;
>
> } else {
>
> vector<BankAccount> account(20); string name; double balance =
> 0.0; int numberOfAccounts = 0;
>
> while ((inFile >> name >> balance)
>
> && (numberOfAccounts < account.capacity())) {
> account\[numberOfAccounts\] = BankAccount(name, balance);
> numberOfAccounts++; }
>
> cout << "Number of accounts on le: " << numberOfAccounts
> << endl; cout << endl;
>
> cout << "The accounts" << endl; cout <<
> "===========================" << endl; for (int index = 0; index
> < numberOfAccounts; index++) { cout.width(2); cout << index
> << ". "; cout << account\[index\].getName();
>
> cout.width(20 - account\[index\].getName().length()); cout <<
> account\[index\].getBalance() << endl;
>
> }
>
> } // end else
>
> return 0; }
>
> Number of accounts on le: 12
>
> Cust0 0.00
>
> The accounts
>
> AnyName 111.11
>
> ===========================
>
> Alex 222.22

1.  Cust0 0

> Andy 333.33

1.  AnyName 111.11

> Ash 444.44

1.  Alex 222.22

> Cust5 555.55

1.  Andy 333.33

> Cust6 666.66

1.  Ash 444.44

> Cust7 777.77

1.  Cust5 555.55

> Cust8 888.88

1.  Cust6 666.66

> Cust9 999.99

1.  Cust7 777.77

> Cust10 1010.10

1.  Cust8 888.88

> Cust11 1111.11

1.  Cust9 999.9910. Cust10 1010.1

> 11\. Cust11 1111.11

SELF-CHECK

10-18 Write two assignment statements that initialize two additional
BankAccount objects with assignment statements in the next two vector
locations. Use any data you desire.

> 10-19 What would happen if the input fi le bank.data contained 21
> lines, each line representing one account? Remember,
> account.capacity() is 20.
>
> 10-20 Write code to initialize a vector of integers from a fi le named
> int.dat. Assume the fi le never has more than 1,000 integer values.
>
> 10-21 Which object in your code represents the number of initialized
> elements?
>
> 10-22 Write code that verifi es proper initialization of the vector of
> the previous two self-check questions.

10.4 vector ARGUMENT/PARAMETER ASSOCIATIONS

> Sometimes it may be necessary to pass a vector to either a member
> function or a nonmember function through argument/parameter
> association. Th is requires a diff erent syntax in the parameter list.
> Th ere are three ways to declare a vector parameter, but only these
> two should ever be used:
>
> Pass by Reference (when the function must modify the associated vector
> argument)
>
> *return-type* *function-name* (vector <*class*> & *vector-name)*
>
> Pass by const Reference (runtime effi cient with & and safe with
> const)
>
> *return-type* *function-name* (const vector <*class*> &
> *vector-name*)
>
> A vector object should not be passed by value. Th is parameter-passing
> mode is usually ineffi cient since vector objects can consume a large
> amount of memory.
>
> void inef cient(vector <BankAccount> accounts, int n) {
>
> // VALUE parameter (should not be used with vectors). All elements //
> of acct are copied after allocating additional memory.
>
> }
>
> Recall that passing by value causes the function to allocate memory
> for a copy of the object passed by value. Th is could be thousands or
> even millions of bytes. Th e program could terminate because of lack
> of memory. Additionally, every byte of the vector needs to be copied,
> which could noticeably slow down the program. Passing by const
> reference has the same meaning, but is more effi cient.
>
> Use pass by reference (with &) when a function is supposed to modify
> the associated argument:
>
> void initialize(vector <BankAccount> & accounts, int & n){
>
> // REFERENCE parameter (allows changes to argument)
>
> // Only a pointer to acct is copied // A change to acct here changes
> the argument in the caller
>
> }

10.4: vector Argument/Parameter Associations

> When a function requires a vector but should not modify the associated
> argument, pass the vector by const reference:
>
> void display(const vector <BankAccount> & accounts, int &
> numberOfAccounts)
>
> {
>
> // CONST REFERENCE parameter (for ef ciency and safety)
>
> // Only a reference to the acct is copied (4 bytes)
>
> // A change to acct does NOT change the argument
>
> }
>
> Th e next program passes a vector by reference to the function
> initialize in order to communicate the initialized array back to main.
> Th e main function passes by reference a vector of doubles to a void
> function named initialize. Because the vector and int parameters x and
> numberOfAccounts are declared as a reference parameter with &, any
> change to x or numberOfAccounts inside of initialize also changes the
> arguments in the main function test and n.
>
> \#include <vector> // For the vector<type> class
>
> \#include <iostream> using namespace std;
>
> void initialize(vector<int> & x, int & numberOfAccounts) { //
> Two reference parameters
>
> // post: Initialize the rst n elements of the argument
> numberOfAccounts = 5;
>
> x.resize(numberOfAccounts); x\[0\] = 75; x\[1\] = 88; x\[2\] = 67;
> x\[3\] = 92; x\[4\] = 51; // The arguments associated with x and n,
> test and n in main, // will also be modi ed.
>
> }
>
> void display(const vector<int> & x, int numberOfAccounts) { //
> Const reference
>
> // Display the vector with n meaningful values cout << "The
> vector: ";
>
> for (int i = 0; i < numberOfAccounts; i++) { cout.width(5); cout
> << x\[i\] << " ";
>
> }
>
> cout << endl; }
>
> int main() { vector<int> vec(10, 0); int n;
>
> // Initialize test and n initialize(vec, n); display(vec, n);
>
> return 0; }
>
> Output
>
> The vector: 75 88 67 92 51

10.4.1 const REFERENCE & PARAMETERS

> Th e preceding program showed that the arguments—test and n—were
> passed to function initialize by reference. Th is was done to allow
> the function to modify both arguments and communicate the changes back
> to main. However, sometimes a vector is passed as input to a function,
> where no changes should be made. In this case, the const reference
> form should be used like in the initialize function above. Part of the
> reason is effi ciency—the program executes more quickly. Th e other
> consideration is better memory utilization—less memory is required to
> store the vector in the called function. A vector object passed by
> value requires as much memory as the argument.
>
> // A vector should not be passed by value like this void
> display(vector <double> x, int n) { // Value parameter
>
> // This function must obtain the memory necessary to store x when x
>
> // could have a large capacity of large objects
>
> }
>
> So if the vector argument had a capacity of 100,000 elements, void
> display would need to consume an additional 100,000 elements.
> Additionally, every single element would need to be copied from the
> client code (the caller) to the called function. Th is can be time
> consuming, especially when the vector’s capacity is large and/or the
> size of each element is large. Th e computer has to do a lot of
> unnecessary work. Th e program would run noticeably slower and might
> exhaust available memory.
>
> Here are two alternatives to make any program more effi cient in terms
> of space (saves memory) and time (runs faster):

1.  Pass the vector by reference—effi cient but dangerous.

2.  Pass the vector by const reference—effi cient and safe.

> Th e second option is highly recommended—the computer program has much
> less work to do. Using const is also an antibugging technique that
> will let the compiler catch attempts to modify the constant objects.
> Any const member function may still be called— vector::capacity, for
> example. However, the compiler will fl ag any attempt to send a
> nonconst message:
>
> // precondition: x.capacity() > 0
>
> void display(const vector <int> & x, const int n) {
>
> cout << "\\nThe vector's capacity is " << x.capacity() //
> <- Okay cout << x\[0\]; // <- OKAY to reference vector
> element x\[0\] = 123; // <- ERROR caught during compilation
>
> }
>
> error: cannot assign to return value because function 'operator\[\]'
> returns a const value
>
> Pass vector objects or any large object by const reference.

SELF-CHECK

> 10-23 Why should vector and Grid objects be passed by const reference
> when you have always seen int and double variables passed by value?
>
> 10-24 If the average size of the BankAccount objects in a vector of
> capacity 100,000 is 57 bytes, how many bytes of additional memory
> would have to be reserved and then copied into each of the following
> functions? Remember, pass by reference typically requires four bytes
> of memory:

a.  void one(vector<BankAccount> v1)

b.  void two(vector<BankAccount> & v1)

c.  void one(const vector<BankAccount> & v1)

10.5 SORTING

> Th e elements of a vector are often arranged into either ascending or
> descending order through a process known as *sorting*. For example, a
> vector of test scores is sorted into ascending order by rearranging
> the numeric values in lowest-to-highest order. A vector of string
> objects sorted in ascending order establishes an alphabetized list
> (A’s before B’s, B’s before C’s). To sort a vector, the elements must
> be compared with the < operator. If one object can be less than
> another object of the same type, then the vector is *sortable*. For
> example, 85 < 79 and "A" < "B" are valid expressions.
>
> Th e following code declares and gives meaningful values to a part of
> the vector named data to demonstrate sorting a vector of integers:
>
> vector<int> data(10, 0); // Store up to 10 integers int n = 5;
> data\[0\] = 76; data\[1\] = 74; data\[2\] = 100; data\[3\] = 62;
> data\[4\] = 89;
>
> Th ere are many sorting algorithms. Even though others are more effi
> cient (run faster), the relatively simple selection sort algorithm is
> presented here. Th e goal here is to arrange a vector of integers into
> ascending order, the natural ordering of integers.

  > **Object Name **   **Unsorted vector **   **Sorted vector**
  -------------------- ---------------------- -------------------
  data\[0\]            76.0                   > 62.0
  data\[1\]            91.0                   > 76.0
  data\[2\]            100.0                  > 89.0
  data\[3\]            62.0                   > 91.0
  data\[4\]            89.0                   > 100.0

> With the selection sort algorithm, the largest integer must end up in
> data\[n - 1\] (where n is the number of meaningful vector elements).
> Th e smallest number should end up in data\[0\]. In general, a vector
> x of size n is sorted in ascending order if x\[i\] <= x\[i + 1\]
> for i = 0 to n-2. Th e selection sort begins by locating the smallest
> element in the vector by searching from the fi rst element (data\[0\])
> through the last (data\[4\]). Th e smallest element, data\[3\] in this
> vector, is then swapped with the top element, data\[0\]. Once this is
> done, the vector is sorted at least through the fi rst element.
>
> Th e task of fi nding the smallest element is accomplished by
> examining all vector elements and keeping track of the index with the
> smallest integer. After this, the smallest vector element is swapped
> with data\[top\] where top will range from 0 to n-1. Here is an
> algorithm that accomplishes these two tasks:
>
> **Algorithm:** *Finding the smallest element in the vector and
> switching it with the topmost element*

(a) *top* = 0

> *// At rst, assume that the rst element is the smallest*

(a) *indexOfSmallest* = *top*

> *// Check the rest of the vector (data*\[*top + 1*\] *through
> data*\[*n - 1*\]*) *

(a) for *index ranging from top* + 1 *through* n - 1 (c1) if
    *data*\[*index*\] < *data*\[*indexOfSmallest*\] *indexOfSmallest*
    = *index*

*// Place the smallest element into the rst position and place the rst
vector // element into the location where the smallest vector element
was located.*

(a) swap *data*\[*indexOfSmallest*\] *with data*\[*top*\]

> Th e following algorithm walkthrough shows how the vector is sorted
> through the fi rst element. Th e smallest integer in the vector will
> be stored at the "top" of the vectordata\[0\]. Notice that
> indexOfSmallest changes only when a vector element is found to be less
> than the one stored in data\[indexOfSmallest\]. Th is happens the fi
> rst and third times step (c1) executes.

**Step top indexOfSmallest index \[0\] \[1\] \[2\] \[3\] \[4\] n**

? ? ? 76.0 91.0 100.0 62.0 89.0 5

(a) 0 " " " " " " " "

(b) " 0 " " " " " " "

(c) " " 1 " " " " " "

(c1) " 1 " " " " " " "

\(c) " " 2 " " " " " "

(c1) " " " " " " " " "

\(c) " " 3 " " " " " "

(c1) " 2 " " " " " " "

\(c) " " 4 " " " " " "

(c1) " " " " " " " " "

(c) " " 5 " " " " " "

(d) " " " 62.0 " " 76.0 " "

> Th is algorithm walkthrough shows indexOfSmallest changing twice to
> represent the index of the smallest integer in the vector. After
> traversing the entire vector, the smallest element is swapped with the
> top vector element. Specifi cally, the preceding algorithm swaps the
> values of the fi rst and fourth vector elements, so 62.0 is stored in
> data\[0\] and 76.0 is stored in data\[3\].
>
> Th e vector is now sorted through the fi rst element!
>
> Th e same algorithm can be used to place the second-smallest element
> into data\[1\]. Th e second traversal must begin at the new "top" of
> the vector—index 1 rather than 0. Th is is accomplished by
> incrementing top from 0 to 1. Now a second traversal of the vector
> begins at the second element rather than the fi rst. Th e smallest
> element in the unsorted portion of the vector is swapped with the
> second element. A second traversal of the vector ensures that the fi
> rst two elements are in order. In this example vector, data\[3\] is
> swapped with data\[1\] and the vector is sorted through the fi rst two
> elements:

top == 1 Before After Sorted

  data\[4\] 89.0                                > 89.0       
  --------------------------------------------- ------------ ------------
  Th is process repeats a total of n-1 times:                
  top == 2 **Before **                          **After **   **Sorted**

> data\[2\] **100.0** **89.0** data\[3\] 91.0 91.0 data\[4\] **89.0**
> **100.0**

  An element may even be swapped with itself:   
  --------------------------------------------- ------------ ------ -------- --
  top == 3 **Before After **                    **Sorted**
                                                data\[0\]
                                                data\[1\]
                                                data\[2\]

> data\[3\] **91.0** **91.0** data\[4\] 100.0 100.0
>
> When top goes to data\[4\], the outer loop stops. Th e last element
> need not be compared to anything. It is unnecessary to fi nd the
> smallest element in a vector of size 1. Th is element in data\[n - 1\]
> must be the largest (or equal to the largest), since all of the
> elements preceding the last element are already sorted in ascending
> order:

  > top == 3 and 4   **Before **   **After **   **Sorted**
  ------------------ ------------- ------------ ------------
  > data\[0\]        62.0          > 62.0       
  > data\[1\]        76.0          **76.0**     
  > data\[2\]        89.0          > 89.0       
  > data\[3\]        91.0          > 91.0       
  > data\[4\]        100.0         100.0        

> Th erefore, the outer loop changes the index top from 0 through n - 2.
> Th e loop to fi nd the smallest index in a portion of the vector is
> nested inside a loop that changes top from 0 through n - 2 inclusive.
>
> **Algorithm:** *Selection Sort *

for *top ranging from 0 through n - 2* { *indexOfSmallest* = *top* for
*index ranging from top + 1 through n - 1* {

if *data*\[*indexOfSmallest*\] < *data*\[*index*\] then

*indexOfSmallest* = *index*

}

swap *data*\[*indexOfSmallest*\] with *data*\[*top*\]

}

> Here is the C++ code that uses selection sort to sort the vector of
> numbers shown. Th e vector is printed before and after the numbers are
> sorted into ascending order.
>
> \#include <vector> \#include <iostream> using namespace
> std;
>
> void sort(vector<int> & data, int n) { int indexOfSmallest = 0;
>
> for (int top = 0; top < n - 1; top++) {
>
> // First assume that the smallest is the rst element in the subvector
> indexOfSmallest = top;
>
> // Then compare all of the other elements, looking for the smallest
> for (int index = top + 1; index < data.capacity(); index++) {
>
> // Compare elements in the subvector if (data\[index\] <
> data\[indexOfSmallest\]) indexOfSmallest = index; }
>
> // Then make sure the smallest from data\[top\] through data.size
>
> // is in data\[top\]. This message swaps two vector elements. double
> temp = data\[top\]; // Hold on to this value temporarily data\[top\] =
> data\[indexOfSmallest\]; data\[indexOfSmallest\] = temp;
>
> }
>
> }
>
> vector<int> initialize() { vector<int> v(5); v\[0\] = 76;
> v\[1\] = 91; v\[2\] = 100; v\[3\] = 62; v\[4\] = 89; return v; }
>
> void display(vector<int> v) { for (int i = 0; i <
> v.capacity(); i++) { cout << v\[i\] << " ";
>
> }
>
> cout << endl; }
>
> int main() {
>
> vector<int> data = initialize();
>
> cout << "Before sorting: "; display(data);
>
> sort(data, data.capacity()); cout << " After sorting: ";
> display(data);
>
> return 0; }
>
> Output
>
> Before sorting: 76 91 100 62 89
>
> After sorting: 62 76 89 91 100
>
> Most sort routines arrange the elements from smallest to largest.
> However, with just a few simple changes, any type of elements that
> allow the < and > operators may be arranged into descending
> order using the > operator.
>
> if (data\[index\] < data\[indexOfSmallest\]) indexOfSmallest =
> index;
>
> becomes
>
> if (data\[index\] > data\[indexOfLargest\]) indexOfLargest = index;

SELF-CHECK

> 10-25 Alphabetizing a vector of string objects requires a sort in
> which order—ascending or descending?

10.6: Binary Search

> 10-26 If the largest element in a vector already exists as the fi rst,
> what happens when the swap function is called for the fi rst time
> (when top = 0)?
>
> 10-27 Write code that searches for and stores the largest element of
> vector x into largest. Assume that all elements from x\[0\] through
> x\[n-1\] have been given meaningful values, so all vector elements
> should be considered.

10.6 BINARY SEARCH

> Th is chapter has shown the sequential search algorithm used to locate
> a string in a vector of string objects. Th is section examines the
> more effi cient binary search algorithm. Binary search accomplishes
> the same search task more quickly. It is faster than a sequential
> search, especially when the vector is large. However, one of its
> preconditions is that the vector must be sorted. By contrast, the
> slower sequential search does not require the vector to be sorted and
> the algorithm is simpler.
>
> In general, binary search works like this. If a vector of objects is
> sorted, half of the vector’s elements are eliminated from the search
> each time a comparison is made. Th is is summarized in the following
> algorithm that searches for any element:
>
> **Algorithm:** *Binary Search*

while *the element is not found and it still may be in the vector* {
*determine the position of the element in the middle of the vector* if
*the element in the middle is not the one being searched for: eliminate
the half of the vector that cannot contain the element*

}

> Each time the search element is compared to one vector element, the
> binary search eff ectively eliminates half the vector elements from
> the search fi eld. In contrast, the sequential search only eliminates
> one element from the search fi eld for each comparison. Assuming a
> vector of string objects is sorted in alphabetic order, sequentially
> searching for "Ableson" does not take long since "Ableson" is likely
> to be located as one of the fi rst vector elements. However,
> sequentially searching for "Zevon" would take much more time because
> the sequential search algorithm fi rst searches through all names
> beginning with A through Y before arriving at the Z’s. Binary search
> gets to "Zevon" much more quickly.

Th e binary search algorithm has these preconditions:

1.  Th e vector must be sorted (in ascending order for now).

2.  Th e subscripts that reference the fi rst and last elements must
    > represent the entire range of meaningful elements.

> Th e element in the middle of the vector is accessed by computing the
> vector subscript that is halfway between the fi rst and last positions
> of the meaningful elements. Th is is the average
>
> of the two subscripts that represent the fi rst and last elements in
> the vector. Th ese become subscripts in the search and will be
> referred to as rst, mid, and last. Here is the vector to be searched:
>
> vector <string> str(32); int n = 7;
>
> str\[0\] = "ABE"; // rst == 0 str\[1\] = "CLAY"; str\[2\] = "KIM";
> str\[3\] = "LAU"; // mid == 3 str\[4\] = "LISA"; str\[5\] = "PELE";
> str\[6\] = "ROE"; // last == 6

Th e binary search algorithm is preceded with several assignments to get
things going:

> searchString = the string being searched for rst = subscript of the fi
> rst meaningful vector element last = subscript of the last meaningful
> vector element mid = ( rst + last) / 2

At this point, one of three things can happen:

1.  Th e element in the middle of the vector matches the search name—the
    > search is complete.

2.  Th e search element precedes the middle element. Th e second half of
    > the vector can be eliminated from the search fi eld.

3.  Th e search element follows the middle element. Th e fi rst half of
    > the vector can be eliminated from the search fi eld.

> Th is is written algorithmically as:
>
> **Algorithm:** *Binary Search (more refi ned while assuming ascending
> sort)*
>
> if *searchString* == *str*\[*mid*\] then *searchString is found* else
>
> if *searchString* < *str*\[*mid*\] *eliminate mid...last elements
> from the search* else *eliminate rst...mid elements from the search*
>
> Th e binary search algorithm is implemented here as a free function
> assuming the vector named str has been constructed, initialized, and
> sorted:

10.6: Binary Search

> \#include <vector>
>
> \#include <iostream>
>
> \#include <string> using namespace std;
>
> vector<string> initialize() { vector<string> str(7);
> str\[0\] = "ABE"; str\[1\] = "CLAY"; str\[2\] = "KIM"; str\[3\] =
> "LAU"; str\[4\] = "LISA"; str\[5\] = "PELE"; str\[6\] = "ROE"; return
> str; }
>
> // pre: The vector named str is sorted in ascending order.
>
> // str\[0\] through str\[6\] are de ned vector elements.
>
> // string de nes < and ==. int indexOf(string searchString,
> vector<string> str, int n) { int rst = 0;
>
> int last = n - 1; // last = 6;
>
> while (( rst <= last)) {
>
> int mid = ( rst + last) / 2; // (0 + 6) / 2 = 3 if (searchString ==
> str\[mid\]) // Check the three possibilities return mid; // 1)
> searchString is found else if (searchString < str\[mid\]) // 2)
> It's in rst half so last = mid - 1; // eliminate second half else
>
> // 3) It's in second half so eliminate rst half
>
> rst = mid + 1;
>
> }
>
> return -1; // searchString not found }
>
> void display(vector<string> v) { for (int i = 0; i <
> v.capacity(); i++) cout << v\[i\] << " "; cout <<
> endl; }
>
> int main() {
>
> vector<string> data = initialize(); cout <<
> indexOf("LISA", data, data.capacity()); return 0; }
>
> Objects Before Comparing searchString ("LISA") to str\[mid\] ("LAU")
>
> str\[0\] "ABE" rst == 0 str\[1\] "CLAY" str\[2\] "KIM"
>
> str\[3\] "LAU" mid == 3 str\[4\] "LISA" str\[5\] "PELE" str\[6\] "ROE"
> last == 6
>
> After comparing searchString to str\[mid\], rst is increased and a new
> mid is computed:
>
> ~~str\[0\] "ABE"~~ // Because "LISA" is greater than str\[mid\], the
> ~~str\[1\] "CLAY"~~ // the objects str\[0\] through str\[3\] no longer
> need ~~str\[2\] "KIM"~~ // to be searched and can now be eliminated
> from ~~str\[3\] "LAU"~~ // subsequent search str\[4\] "LISA" rst == 4
> str\[5\] "PELE" mid == 5 str\[6\] "ROE" last == 6
>
> Since searchString < str\[mid\] or "LISA" < "PELE" is true, last
> is decreased and a new mid is computed:
>
> ~~str\[0\] "ABE"~~ ~~str\[1\] "CLAY"~~ ~~str\[2\] "KIM"~~ ~~str\[3\]
> "LAU"~~
>
> str\[4\] "LISA" rst == 5 last == 5 mid == 5 ~~str\[5\] "PELE"~~ //
> Because "LISA" is less than str\[mid\], eliminate ~~str\[6\] "ROE"~~
> // str\[5\] through str\[6\] from the search eld
>
> Now str\[mid\] does equal searchString, so the algorithm will break
> out of the loop.
>
> Th e binary search algorithm can be more effi cient than the
> sequential search that only eliminates one element per comparison.
> Binary search eliminates half the elements for each comparison. For
> example, when n == 1,024, a binary search eliminates 512 elements from
> further search after the fi rst comparison.
>
> Now consider the possibility that the element being searched for is
> not in the vector. For example, to search for "CARLA", the values of
> rst, mid, and last progress as follows:

  > **Comparison **   rst   mid   last   **Comment**
  ------------------- ----- ----- ------ -----------------------------------------------------
  1                   0     3     6      Compare "CARLA" to "LAU"
  2                   0     1     2      Compare "CARLA" to "CLAY"
  3                   0     0     0      Compare "CARLA" to "ABE"
  4                   1     0     0      rst <= last is false and the function returns -1

> Th e loop test ( rst <= last) evaluates to false when searchString
> ("CARLA") is not stored in the vector. Notice that last is less than
> rst—the two subscripts have crossed each other.
>
> str\[0\] "ABE" last == 0 mid == 0 str\[1\] "CLAY" rst == 1 str\[2\]
> "KIM" str\[3\] "LAU"

Chapter Summary

> str\[4\] "LISA" str\[5\] "PELE" str\[6\] "ROE"
>
> After searchString ("CARLA") is compared to str\[1\] ("ABE"), no
> further comparisons are necessary. Th is is the second of two
> conditions that terminate the loop. Since rst is no longer less than
> or equal to last, searchString cannot be in the vector.

SELF-CHECK

> 10-28 Write at least one precondition for a successful binary search.
>
> 10-29 What is the maximum number of comparisons (approximately)
> performed on a list of 1,024 elements during a binary search? (*Hint:*
> After one comparison, only 512 vector elements need be searched; after
> two searches, only 256 elements need be searched and so on.)
>
> 10-30 During a binary search, what condition signals that the search
> element does not exist in a vector?
>
> 10-31 What changes must be made to the binary search when the elements
> are sorted in descending order?

CHAPTER SUMMARY

-   Whereas objects may store data of many diff erent types at the same
    > time (a string, an int, and even a vector, for example), a vector
    > object stores collections of the same class (a vector of char,
    > int, string, or BankAccount objects, for example).

-   Individual vector elements are referenced with subscripts. With a
    > C++ vector, the int expression of a subscript reference should be
    > in the range of 0 through the capacity - 1. For example, the valid
    > subscript range of vector <double> x(100) is 0 through
    > 99 inclusive.

-   Out-of-range subscripts may not be detected at compile time and may
    > cause system crash-es, destruction of other objects, or some other
    > system-specifi c problems. It depends on the vector class you
    > are using. Programmers must guard against these potential hazards.
    > One of the easiest ways to do this is to use vector::at.

-   An integer named n or size is usually an important piece of data
    > that must be maintained in addition to the vector
    > elements themselves. Th e number of meaningful elements is
    > important in any vector-processing algorithm.

-   Any vector object can be resized to have a diff erent
    > maximum capacity. If it is resized to be bigger, the meaningful
    > elements remain. However, if a vector is resized to be smaller,
    > truncation of meaningful elements may occur.

-   Th e selection sort algorithm was used to arrange vector elements
    > into ascending order. Any object that can be compared with <
    > may be sorted.

-   vector objects may also be sorted in ascending order, which is more
    > appropriate sometimes, especially with string elements where
    > ascending order means alphabetical order.

-   Th e binary search algorithm is more effi cient than
    > sequential search. However, the vector must fi rst be sorted for
    > binary search to work properly.

EXERCISES

> 1\. Show the output generated by the following program:
>
> \#include <iostream>
>
> \#include <vector> using namespace std;
>
> int main() { const int MAX = 10; vector<int> x(MAX);
>
> for (int i = 0; i < 3; i++) x\[i\] = i \* 2; for (int i = 3; i <
> MAX; i++) x\[i\] = x\[i - 1\] + x\[i - 2\]; for (int i = 0; i <
> MAX; i++) cout << i << ". " << x\[i\] << endl;
> return 0; }

2.  How many elements must be given meaningful values for a vector with
    > 100 elements?

3.  Declare a C++ vector called vectorOfInts that stores 10 integers
    > with subscripts 0 through 9.

4.  Write code that determines the largest value of a vector named list.
    > Assume all elements from index 0 through list.size()-1 have been
    > assigned meaningful values.

5.  Write code to determine the average of integers in a vector
    > named list. Assume all elements from index 0 through list.size()-1
    > have been assigned meaningful values.

6.  Write the output generated by the following program:

> \#include <iostream>
>
> \#include <vector> \#include <string> using namespace std;
>
> void init(vector<char> & data, int & n) { // postcondition:
> Initialize data as a vector of chars.
>
> // Initialize n as the number of meaningful elements.

Exercises

> n = 5; data\[0\] = 'c'; data\[1\] = 'b'; data\[2\] = 'e'; data\[3\] =
> 'd'; data\[4\] = 'a'; }
>
> void display(const vector<char> & data, int n) { // post: Show
> all meaningful elements of data cout << endl;
>
> cout << "Vector of chars: "; for(int i = 0; i < n; i++) cout
> << data\[i\] << " "; cout << endl; }
>
> void mystery(vector<char> & data, int n) {
>
> // post: Reverse the order of data int last; char temp;
>
> last = n - 1;
>
> for(int i = 0; i < n / 2 + 1; i++) { temp = data\[i\]; data\[i\] =
> data\[last\]; data\[last\] = temp; last--;
>
> }
>
> }
>
> int main() {
>
> vector<char> characters(10, ' '); int n;
>
> init(characters, n); display(characters, n); mystery(characters, n);
> display(characters, n);
>
> return 0; }

7.  Write code to declare and initialize a vector of 10 string objects
    > with keyboard input. Your dialogue should look like this:

> Enter 10 strings
>
> \#0 First
>
> \#1 Second . . .
>
> \#9 Tenth

7.  Write code that sets found to true if a given string is found in the
    > following vector. If a string is not in the vector, let found
    > be false. Assume only the fi rst n vector elements are initialized
    > and are to be considered.

> vector<string> s(200); int n = 127; bool found = false;

7.  How many comparisons does a sequential search make when the search
    > element is stored in the fi rst vector element and there are 1,000
    > meaningful elements in the vector?

8.  How many comparisons does a sequential search make when the search
    > element does not match any vector element and there are 1,000
    > elements in the vector?

9.  Assuming a large number of searches are made on a vector, and it is
    > just as likely that an element will be found in the fi rst
    > position as the last position, approximate the average number of
    > comparisons after 1,000 searches when there are 1,000 elements in
    > the vector.

10. Write the output generated by the following program (trick
    > question):

> \#include <vector> // For the vector<type> class
>
> \#include <iostream> using namespace std;
>
> void init(vector<int> x, int n) {
>
> // post: Supposedly modify n and the rst n elements of test in main
> x\[0\] = 0; x\[1\] = 11; x\[2\] = 22; x\[3\] = 33; x\[4\] = 44; n = 5;
> }
>
> int main() {
>
> vector <int> test(100, 0); int n;
>
> // Initialize test and n init(test, n);
>
> // Display the vector with n meaningful values cout << "The
> vector: "; for(int i = 0; i < n; i++) cout << test\[i\]
> << " ";
>
> return 0; }

13. How would you change the code in exercise 12 so that the output is:

> The vector: 0 11 22 33 44

Exercises

13. Write the output generated by the following program:

> \#include <vector> // For the vector<type> class
>
> \#include <iostream> using namespace std;
>
> void f(const vector<int> & x) { cout << x\[0\] <<
> endl; cout << x.capacity() << endl; }
>
> int main() {
>
> vector <int> test(10000, -1); f(test); return 0; }

15. Which lines contain compile time errors?

> void f1(vector<int> x) {
>
> cout << x\[0\] << endl; // Line 1 cout <<
> x.capacity() << endl; // Line 2 x\[0\] = 999; // Line 3 }

15. Which lines contain compile time errors?

> void f2(const vector<int> & x) { cout << x\[0\] <<
> endl; // Line 1 cout << x.capacity() << endl; // Line 2
> x\[0\] = 999; // Line 3 }

15. Which of the previous two functions (exercises 15 and 16) is more
    > effi cient in terms of space and time—f1 or f2?

16. Write the output generated by the program segment below using the
    > initialized vector of string objects.

> \#include <iostream>
>
> \#include <string>
>
> \#include <vector> // For the vector<type> class using
> namespace std;
>
> int main() { vector<string> x(10); int j; int top = 0; int n =
> 5;
>
> x\[0\] = "Alex"; x\[1\] = "Andy"; x\[2\] = "Ari"; x\[3\] = "Ash";
> x\[4\] = "Aspen";
>
> for (top = 0; top < n - 1; top++) { int subscript = top; for (j =
> top + 1; j <= n - 1; j++) { if (x\[j\] < x\[subscript\])
> subscript = j;
>
> }
>
> string temp = x\[subscript\]; x\[subscript\] = x\[top\]; x\[top\] =
> temp;
>
> }
>
> for (int index = n - 1; index >= 0; index--) { cout <<
> x\[index\] << endl;
>
> } return 0; }
>
> 19\. Write the output of the program segment below using this initialized
> vector of string objects.
>
> vector <string> str(20); str\[0\] = "ABE"; str\[1\] = "CLAY";
> str\[2\] = "KIM"; str\[3\] = "LAU"; str\[4\] = "LISA"; str\[5\] =
> "PELE"; str\[6\] = "ROE"; str\[7\] = "SAM"; str\[8\] = "TRUDY";
>
> int rst = 0; int last = 8; int mid;
>
> string searchString("CLAY");
>
> cout << "First Mid Last" << endl; while ( rst <= last)
> { mid = ( rst + last) / 2; cout << rst << " " << mid
> << " " << last << endl; if (searchString ==
> str\[mid\]) break; else if (searchString < str\[mid\]) last = mid -
> 1; else rst = mid + 1;
>
> }

Programming Tips

> if ( rst <= last) cout << searchString << " found"
> << endl; else
>
> cout << searchString << " was not" << endl;

20. Write the output generated by the program segment in exercise 19
    > when searchString is assigned each of the following values:

    a.  searchString = "LISA" d. searchString = "ABLE"

    b.  searchString = "TRUDY" e. searchString = "KIM"

    c.  searchString = "ROE" f. searchString = "ZEVON"

21. List at least one condition that must be true before a successful
    > binary search can be implemented.

22. Using a binary search, what is the maximum number of
    > comparisons (approximately) that will be performed on a list of
    > 256 sorted elements? (*Hint*: After one comparison, only 128
    > vector elements need be searched; after two searches, only 64
    > elements need be searched; and so on.)

PROGRAMMING TIPS

1.  C++ begins to count at 0. Th e fi rst vector element is referenced
    > with subscript 0, not 1 as is done in some other
    > programming languages.

2.  A vector often has a capacity greater than its number of
    > meaningful elements. Sometimes vector objects are initialized to
    > store more elements than are actually needed. In this case, only
    > the fi rst n elements are meaningful.

3.  Use a second variable named n, perhaps to maintain the number of
    > meaningful vector elements. When vector objects are used as a data
    > member, consider using another data member to store the number of
    > meaningful elements. You may need to resize to allow
    > additional capacity. However, when using vector objects outside of
    > a class, make sure you have an integer that maintains the number
    > of meaningful elements. Consider the following code that counts
    > the number of elements from a fi le as individual vector elements
    > are initialized. Th e number of meaningful elements is maintained
    > in n, so it was necessary to initialize n to 0 and then increment
    > n by 1 for each number on fi le.

> vector <double> x(100, 0.0); double aNumber; int n = 0;
>
> while ((inFile >> aNumber) && (n < x.capacity())) { x\[n\] =
> aNumber; n++; }

1.  Consider using at(index) instead of \[index\]. Th e at message
    > is safer. You get a runtime error that is easier to track down
    > than a change to some memory in an unknown place.

2.  Th e last meaningful vector element is in x\[n-1\], not x\[n\].
    > Don’t reference x\[n\]. Th is can be done in the code of the third
    > programming tip by accidentally writing the for loop like this:

> int n = 10; vector<int> x(n, 123);
>
> for (int j = 0; j <= n; j++) { // Used <= instead of <
> cout.width(5);
>
> cout << x\[j\]; // Will eventually reference garbage }

1.  Prevent assignments to a vector with out-of-range subscripts. Th e
    > code of the third programming tip has a loop test that terminates
    > before assignment to x\[x.capacity()\]. When n equals the
    > capacity, the loop terminates.

> while ((inFile >> aNumber) && (n < x.capacity()) ) {
>
> // The loop test prevents assignment to x\[x.capacity()\] x\[n\] =
> aNumber; n++; }
>
> It would also be useful to notify the user that something went wrong
> in this case. Terminating the program prematurely is an easy (but
> awkward) way of doing this:
>
> if (n == x.capacity() && inFile) {
>
> cout << "\*\*Error\*\* Vector was too small. Terminating
> program" << endl; return 0; }
>
> 7\. Make your programs robust with vector::resize and vector::capacity.
> Th e code in programming tip 6 can be most irritating to users once they
> have purchased your software. A sounder way to handle the awkward
> situation of having too small a vector is to resize it when necessary.
> With the following code, the vector’s capacity will increase by 10
> elements every time the vector fi lls up. Th is code also demonstrates
> the advantage of keeping track of the number of meaningful values in a
> separate integer variable because size() and capacity() are 20 when
> there were only 17 numbers in the input fi le.
>
> int aNumber; ifstream inFile("numbers"); vector<int> x(10); int
> n = 0;

Programming Tips

> while (inFile >> aNumber) { if (n == x.capacity()) {
>
> x.resize(n + 10);
>
> } x\[n\] = aNumber; n++; }

cout << " n: " << n << endl; cout << " Size: "
<< x.size() << endl; cout << "Capacity: " <<
x.capacity() << endl; Output when the input fi le numbers has 17
integers:

> n: 17 Size: 20
>
> Capacity: 20

8.  Do not pass vector objects by value. Passing any big object by value
    > slows down program execution and requires unnecessary memory
    > runtime allocation. If a function needs the values of a vector but
    > is not supposed to modify the vector, pass the vector by const
    > reference like this:

> void constReferenceIsGood(const vector<double> & x, int n) {
>
> // This function can reference any element in x, but cannot change x
>
> }
>
> As usual, if a function is meant to modify the argument (a vector in
> this case), pass it by reference like this:
>
> void init(vector<double> & x, int & n) { // Reference parameter
>
> // This function can change any element in x
>
> }
>
> Even string objects should be passed by const reference rather than by
> value because they are sometimes big.

8.  Th e standard vector class does not check subscripts with \[\], but
    > it does with vector::at(int). Consider using x.at(subscript)
    > instead of x\[subscript\]. Th ey are equivalent expressions with
    > one notable exception—when the subscript is out of range,
    > vector::at reports it as an error. You’ll fi nd out about the
    > error right away during testing. Th is is preferable to using some
    > random value accessed with an out-of-range subscript. Your code
    > would look diff erent than other C++ programs due to the
    > historical use of \[\] and the newness of at.

> \#include <vector> // For the vector<type> class
>
> \#include <iostream> using namespace std; int main() { int n;
>
> cout << "Enter vector capacity: "; cin >> n; vector
> <int> x(n);
>
> for(int index = 0; index < n; index++) {
>
> x.at(index) = index; } cout << "First: " << x.at(0)
> << endl; cout << "Last: " << x.at(x.capacity() - 1)
> << endl;
>
> return 0; }
>
> Dialogue
>
> Enter vector capacity: ***100***
>
> First: 0
>
> Last: 99
>
> Th e previous code once again demonstrates that the fi rst element in
> the vector is referenced with a subscript of 0, and the last element
> with index capacity()-1. So the following statement code would
> generate a runtime error and terminate the program: cout <<
> "Last: " << x.at(x.capacity()) << endl; // Always an error

10. Th ere are many sorting algorithms other than selection sort.
    > Selection sort is only one of the many known sorting algorithms.
    > Several others have approximately the same runtime effi ciencies.
    > Some are even better. For example, quicksort is usually much more
    > effi cient. Th is chapter was not written to cover
    > sorting completely. It is only a very brief introduction to
    > another category of vector-processing algorithms.

11. Th ere are many searching algorithms. Sequential and binary search
    > are only two of the known searching algorithms. For small amounts
    > of data, sequential search works very nicely. For larger amounts
    > of data stored in sorted vectors, binary search works well. Other
    > ways to store very large amounts of data that can be searched
    > rapidly include hash tables and binary trees, for example. Th ese
    > are topics usually covered in a second course.

**PROGRAMMING PROJECTS**

10A REVERSE

> Write a complete C++ program that reads an undetermined number of
> integers (maximum of 100) and displays them in reverse order. Th e
> user may not supply the number of elements, so a sentinel loop must be
> used. Here is one sample dialogue:
>
> Enter up to 100 ints using -1 to quit:
>
> ***70***
>
> ***75***
>
> ***90***
>
> ***60***
>
> ***80***
>
> ***-1***
>
> Reversed: 80 60 90 75 70

10B SHOW THE ABOVE-AVERAGE ONES

> Write a complete program that inputs an undetermined number of
> positive numeric values, determines the average, and displays every
> value that is greater than or equal to the average. Th e user may not
> supply the number of elements, so use a sentinel loop. Here is one
> sample dialogue:
>
> Enter numbers or -1 to quit
>
> ***70***
>
> ***75***
>
> ***90***
>
> ***60***
>
> ***80***
>
> ***-1***
>
> Average: 75
>
> Inputs >= average: 75 90 80

10C SEQUENTIAL SEARCH FUNCTION

> Write a function named search that returns the subscript of the fi rst
> found search element in a vector of string objects. If the search
> element is not found, search should return -1.

10D A COLLECTION OF BANKACCOUNT OBJECTS

> Write a complete C++ program that creates an undetermined number of
> BankAccount objects and stores them in a vector. Th e input should
> come from an external fi le that looks like the following, but may
> contain 1, 2, 3, or up to exactly 20 lines (each line represents all
> data necessary to create one BankAccount object):
>
> Hall 100.00
>
> Solly 53.45
>
> Kirstein 999.99 . . .
>
> Pantone 8790.56
>
> Brendle 0.00
>
> Kentish 1234.45
>
> After initializing the vector and determining the number of
> BankAccount objects, display every BankAccount that has a balance
> greater than or equal to \$1,000.00. Th en display every
>
> BankAccount that has a balance less than or equal to \$100.00. Your
> output should look like this:
>
> Balance >= 1000.00
>
> Pantone: 8790.56
>
> Kentish: 1234.56
>
> Balance < 100.00:
>
> Solly: 53.45
>
> Brendle: 0.00

10E PALINDROME 1

> A *palindrome* is a collection of characters that read the same
> backward as forward. Write a program that extracts a string from the
> keyboard and determines whether or not the resulting string is a
> palindrome (recall that string objects reference individual characters
> with the subscript operator \[ \]). Some examples of palindromes are
> YASISAY, racecar, 1234321, ABBA, level, and MADAMIMADAM. Here are two
> sample dialogues. (*Note:* Do not use any blank characters! If you
> prefer, complete programming project 10F instead.)
>
> Enter string: ***MADAMIMADAM***

Reversed: MADAMIMADAM

> Palindrome: Yes
>
> Enter string: ***RACINGCAR***
>
> Reversed: RACGNICAR
>
> Palindrome: No

10F PALINDROME 2

> A *palindrome* is a collection of characters that read the same
> backward as forward. Write a program that extracts a line of
> characters from the keyboard using

getline(istream& is, string& aString)

> and then determines whether or not the resulting string is a
> palindrome. Th e blank characters should be ignored and it must be
> case-insensitive. (*Hint:* First convert the individual characters to
> uppercase with the toupper function from <cctype>, and then
> create a new string with no space characters.)
>
> Enter a line: A man a plan a canal Panama
>
> AMANAPLANACANALPANAMA is a palindrome

10G FIBONACCI NUMBERS

> Th e Fibonacci numbers start as 1, 1, 2, 3, 5, 8, 13, 21. Notice that
> the fi rst two are 1, and any successive Fibonacci number is the sum
> of the preceding two. Write an entire program that properly
> initializes a vector named b to represent the fi rst 20 Fibonacci
> numbers ( b\[1\] is the second Fibonacci number). Do not use 20
> assignment statements to do this. Th ree should suffi ce.

10H SALARIES

> Write a program that inputs an undetermined number of annual salaries
> from an input fi le. After this, display all salaries that are above
> average. Also show the percentage of salaries that are above average.
> If the input fi le contains this data:
>
> 30000.00
>
> 24000.00
>
> 35000.00
>
> 32000.00
>
> 25000.00 then your output should look like this:
>
> Average salary = 29200.00 Above average salaries:
>
> 30000.00
>
> 35000.00
>
> 32000.00
>
> 60% of reported salaries were above average

10I BINARY SEARCH FUNCTION

> Write a free function named search that returns the subscript location
> of the fi rst found search element in a vector. Use the binary search
> algorithm. If the search element is not found, search should return
> -1. Test your function, of course.

10J FREQUENCY

> Write a C++ program that reads integers from a fi le and reports the
> frequency of each integer. For example, if the input fi le contains
> the numbers as shown to the left below, your program should generate
> the output shown to the right below, with the highest numbers fi rst.
> Create the input fi le so that all numbers are in the range of 0
> through 100 inclusive. (*Hint*: Start with a vector of capacity 101
> with all elements set to 0.)

  --------------------------------------------------------
  **Th e File** test.dat   **Th e Program Dialogue**
  ------------------------ -------------------------------
  75 85 90 100             Enter le name: ***test.dat***

  60 90 100 85             > 100: 3

  75 35 60 90              > 90: 8

  100 90 90 90             > 85: 3

  60 50 70 85              > 75: 3

  75 90 90 70              > 70: 2
                           
                           60: 3
                           
                           50: 1
                           
                           35: 1
  --------------------------------------------------------

10K EIGHT VECTOR PROCESSING FUNCTIONS

1\. int numberOfPairs(const vector<string> & strs)

> Complete numberOfPairs to return the number of times a pair occurs in
> strs. A pair is any two string elements that are equal (case
> sensitive) at consecutive vector indexes. Th e vector may be empty or
> have only one element. In both of these cases, return 0. Here is some
> testing code that uses push\_back messages to add elements at the end
> of the vector (you need \#include <cassert> for the assert
> function).
>
> vector<string> strs; strs.push\_back("a"); assert(0 ==
> numberOfPairs(strs)); strs.push\_back("a"); assert(1 ==
> numberOfPairs(strs)); strs.push\_back("a"); assert(2 ==
> numberOfPairs(strs)); strs.push\_back("b"); strs.push\_back("b");
>
> // a a a b b
>
> assert(3 == numberOfPairs(strs));

2.  int numberOfVowels(const vector<char> & chars)

> Given a fi lled vector of char elements, complete numberOfVowels to
> return the number of vowels which could be the letters A, E, I, O, or
> U in either uppercase or lowercase. If the vector is empty, return 0.
> Here is some testing code to help explain the expected behavior:
>
> vector<char> chars; chars.push\_back('x'); assert(0 ==
> numberOfVowels(chars)); chars.push\_back('A'); chars.push\_back('a');
> assert(2 == numberOfVowels(chars)); chars.push\_back('I');
> chars.push\_back('o'); chars.push\_back('U'); chars.push\_back('e');
> assert(6 == numberOfVowels(chars));

2.  bool sumGreaterThan(const vector<double> & doubles,
    double sum)

> Given a fi lled vector of double elements, write function
> sumGreaterThan to return true if the sum of all vector elements is
> greater than sum. Return false if sum is less than or equal to the
> elements in doubles. Also return false if the vector is empty. Here is
> some testing code to help explain the expected behavior:
>
> vector<double> doubles; doubles.push\_back(4.0);
>
> assert(sumGreaterThan(doubles, 4.0)== false); doubles.push\_back(0.1);
>
> assert(sumGreaterThan(doubles, 4.0)== true);

2.  int howMany(const vector<string> & vec, string valueToFind)

> Complete function howMany to return the number of elements in a vector
> of strings that equals valueToFind. Th e vector may be empty.
>
> vector<string> strings; strings.push\_back("A");
> strings.push\_back("a"); strings.push\_back("A"); assert(0 ==
> howMany(strings, "x")); assert(1 == howMany(strings, "a")); assert(2
> == howMany(strings, "A"));

2.  void sortOfSort(vector <int> & nums)

> Complete function sortOfSort that modifi es the parameter nums to
> place the largest integer at index n-1 and the smallest integer at
> nums\[0\]. Th e other elements must still be in the vector, but not in
> any particular order. You must modify the given vector argument by
> changing nums in method sortOfSort.

  **Original vector **   **Modifi ed vector (some elements may diff er in order)**
  ---------------------- -----------------------------------------------------------
  {4, 3, 2, 0, 1, 2}     > {0, 3, 2, 1, 2, 4}
  {4, 3, 2, 1}           {1, 3, 2, 4}
  {4, 3, 1, 2}           {1, 3, 2, 4}

> vector<int> nums; nums.push\_back(4); nums.push\_back(3);
> nums.push\_back(1); nums.push\_back(2); sortOfSort(nums); assert(1 ==
> nums\[0\]); assert(4 == nums\[3\]);
>
> assert(nums\[1\] == 2 || nums\[1\] == 3); // depends on your algorithm
> assert(nums\[2\] == 2 || nums\[2\] == 3);
>
> (*Hint:* Get the smallest value at index 0 before you look for and
> swap the largest and the last index.)

6.  void evensLeft(vector<int> & nums)

> Modify the parameter nums so it still contains the exact same numbers
> as the given vector, but rearranged so that all the even numbers come
> before all the odd numbers. Other than that, the numbers can be in any
> order. You must modify the vector argument by changing nums in method
> evensLeft. Th e vector may be empty or have only one element. In both
> cases, no change should be made.

  **Original vector **      **Modifi ed vector **
  ------------------------- -------------------------
  > {1, 0, 1, 0, 0, 1, 1}   > {0, 0, 0, 1, 1, 1, 1}
  {3, 3, 2}                 {2, 3, 3}

> vector<int> ints; ints.push\_back(3); ints.push\_back(3);
> ints.push\_back(2); evensLeft(ints); assert(2 == ints\[0\]); assert(3
> == ints\[1\]); assert(3 == ints\[2\]);

6.  void shiftNTimes(vector<int> & nums, int numShifts)

> Complete shiftNTimes to modify nums so it is “left shifted” n times.
> So shiftNTimes({6, 2, 5, 3}, 1) changes the vector argument to {2, 5,
> 3, 6} and shiftNTimes({6, 2, 5, 3}, 2) changes the vector argument to
> {5, 3, 6, 2}. You must modify the vector argument by changing the
> parameter nums inside method shiftNTimes. Remember, a change to the
> parameter inside the method shiftNTimes changes the argument.
>
> shiftNTimes( {1, 2, 3, 4, 5, 6, 7}, 3 ) modifi es the vector to { 4,
> 5, 6,
>
> 7, 1, 2, 3 }
>
> shiftNTimes( {1, 2, 3, 4, 5, 6, 7}, 0 ) does not modify the vector
> shiftNTimes( {1, 2, 3}, 5) modifi es the vector to { 3, 1, 2 }
> shiftNTimes( {3}, 5) modifi es the vector to { 3 }
>
> vector<int> nums2; nums2.push\_back(1); nums2.push\_back(2);
> nums2.push\_back(3);
>
> nums2.push\_back(4); nums2.push\_back(5);
>
> shiftNTimes(nums2, 2); assert(3 == nums2\[0\]); assert(4 ==
> nums2\[1\]); assert(5 == nums2\[2\]); assert(1 == nums2\[3\]);
> assert(2 == nums2\[4\]);

8\) void replaced(char\[\] & vector, char oldChar, char newChar)

> Modify the vector arguments so all occurrences of oldChar are replaced
> by newChar.

replaced ({'A', 'B', 'C', 'D', 'B'}, 'B', '+') must modify the vector
argument to be {'A', '+', 'C', 'D', '+'}.

Original vector Modifi ed vector

> replaced({'A', 'B', 'C', 'D', 'B'}, 'C', 'L') { 'A', 'B', 'L', 'D',
> 'B' } replaced({'n', 'n', 'D', 'N'}, 'n', 'T') { 'T', 'T', 'D', 'N' }
>
> vector<char> chars2; chars2.push\_back('n');
> chars2.push\_back('n'); chars2.push\_back('D');
> chars2.push\_back('N'); replaced(chars2, 'n', 'T'); assert('T' ==
> chars2\[0\]); assert('T' == chars2\[1\]); assert('D' == chars2\[2\]);
> assert('N' == chars2\[3\]);

10L CLASS STATS

> First create the header fi le Stats.h to store all member function
> declarations and any instance variables you would need. You will
> certainly need a vector. Th en create a new fi le named Stats.cpp and
> implement all of the member functions of the class defi nition. Th e
> following test method must generate the output shown below when the
> input fi le numbers has these 10 integers:

5 1 6 2 3 8 9 4 7 10

> /\*

-   Stats.cpp

-   \* A test driver for class Stats

> \*/
>
> \#include <fstream>
>
> \#include <iostream>
>
> \#include "Stats.h"
>
> using namespace std;
>
> int main() { ifstream inFile("numbers"); int x = 0; Stats tests;
>
> while (inFile >> x) { tests.add(x); }
>
> cout << "Elements before sort: "; tests.display(); tests.sort();
>
> cout << endl << " Elements after sort: "; tests.display();
>
> cout << endl; cout << endl << "Statistics for the
> rst 10 integers" << endl; cout << " Size: " <<
> tests.size() << endl; cout << " Mean: " <<
> tests.mean() << endl; cout << " High: " <<
> tests.max() << endl; cout << " Low: " << tests.min()
> << endl; cout << " Median: " << tests.median()
> << endl;
>
> return 0; }
>
> Output
>
> Elements before sort: 5 1 6 2 3 8 9 4 7 10
>
> Elements after sort: 1 2 3 4 5 6 7 8 9 10
>
> Statistics for the rst 10 integers
>
> Size: 10
>
> Mean: 5.5
>
> High: 10
>
> Low: 1
>
> Median: 6
