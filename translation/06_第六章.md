## 第六章 类的定义与成员函数

### 前章回顾
Functions hide details, can be called many times, can be reused in other programs, and help in the design of larger programs. Each function performs a well-defined service.

函数隐藏了实现细节，并且可以调用很多次，也可以在其他的程序中重用，这在大型程序设计中非常有用。每个函数都实现了一个定义良好的服务。

### 本章提要

When a function belongs to a class, it becomes a class member function. Class member functions have a lot in common with their nonmember cousins. Chapter 6 presents an introduction to C++ class de nition and member function implementations. You will learn to read and understand classes by their de nitions—the collection of member function headings (the interface) and data members (the state). In the second part of this chapter, you will learn to implement class member functions. You will also see a few appropriate object-oriented design guidelines that help explain why classes are designed the way they are. After studying this chapter, you will be able to

+ read and understand class definitions (interface and state) 
+ implement class member functions using existing class defnitions 
+ apply some object-oriented design guidelines

当一个函数属于一个类时，它就成了这个类成员函数。类成员函数与非成员函数之间有很多共同之处。 第6章介绍了C++类定义和成员函数实现。您将学习通过其 ___定义___（成员函数头文件定义（接口）和数据成员（状态）的集合）来阅读和理解类。在本章的第二部分中，您将学习如何实现类成员函数。 您还将看到一些适当的面向对象设计指南，这些指南有助于解释为什么那些类要设计成那个样子。学完本章后，您将能够：

+ 阅读和理解类定义（接口和状态）

+ 使用现有的类定义实现类成员函数

+ 运用一些面向对象的设计指南

### 6.1 在头文件中定义类

Abstraction refers to the practice of using and understanding something without full knowledge of its implementation. Abstraction allows the programmer using a class to concentrate on the data characteristics and the messages that manipulate the state. For example, a programmer using the string class need not know the details of the internal data representation or how those opera- tions are implemented in the hardware and software.  e programmer can concentrate on the set of allowable messages—the interface.

This chapter presents some implementation issues that so far have been hidden. In the  rst part of this chapter, the BankAccount class will be studied at the implementation-detail level. However, before examining the physical side of class design, let’s consider some of the design decisions that were made for this textbook’s BankAccount class.

抽象是指在不完全了解其实现的情况下使用和理解某些东西的做法。抽象允许程序员集中于数据的特征和操纵状态的消息。例如，使用字符串类的程序员既不需要知道内部数据表示的细节，也不需要知道如何在硬件和软件中实现这些操作。 程序员可以专注于允许的消息集-- ___接口___。

本章介绍了迄今为止隐藏的一些实现问题。在本章的第一部分，我们会在实现细节层面进行研究`BankAccount`类。但是，在我们深入了解其实现细节之前，让我们考虑一下为本书的`BankAccount`类做出的一些设计上的决定。

All BankAccount objects have four allowable operations: deposit, withdraw, getBalance, and getName.  ere could have been more, or there could have been fewer.  e member functions for BankAccount were chosen to keep the class simple and to provide a collection of operations that are relatively easy to relate to. A compromise was made.  e design decisions were in uenced by the context—a  rst example of a C++ class used in a particular domain, the area of banking. e BankAccount member functions that make up the interface are only a subset of the operations named by students who were asked this question: what should we be able to do with bank accounts?  e data members are also a subset of the operations named by students who were asked this question: what should bank accounts know about themselves?
 
所有`BankAccount`的对象都允许四个操作：`deposit`，`withdraw`，`getBalance`和`getName`。我们当然也可以定义更多，或者更少的成员函数，但是我们在此遵从一个原则：应该保持`BankAccount`类的简洁，并且操作也应该是容易且相关的。于是我们在此做了妥协。设计决策也受到场景的影响——我们在定义特定领域（银行领域）中使用的C++类的第一个例子。
  
`BankAccount`的这四个成员函数是为了解决这个问题：我们应该如何处理银行账户？而数据成员则解决了这个问题：银行账户应该了解自己的哪些内容？

Many additional operations that were recognized by students (transfer, applyInterest, printMonthlyStatement) and many additional data members (type of account, record of trans- actions, address, Social Security number, and mother’s maiden name) were not included.  e design of these classes was a ected by the intention of keeping these objects as simple as pos- sible while retaining some realism. However, a group of object-oriented designers developing large-scale applications in the banking domain would likely retain many of the operations and attributes recognized by students.  ere is rarely one single design that is correct for all circum- stances.

学生们认可的许多其他操作（`transfer`，`applyInterest`，`printMonthlyStatement`）和许多其他数据成员（帐户类型，交易记录，地址，社会安全号码和母亲的婚前姓名）均未包括在内。在这里，类的设计是为了保持对象尽可能简单，同时保留一些实用性。相反地，在现实的银行领域的大规模应用程序中，很多面向对象的设计人员开发很可能会保留这些学生认可的许多操作和属性。很少有一种设计适合所有环境。

Designing anything requires making decisions in an e ort to make the thing “good.” Good might mean having a software component that is easily maintainable; it might mean classes that can be reused in other applications; or it might mean a system that is very robust—one that can recover from almost any disastrous event. Good might mean a design that results in something that is easier to use, prettier, etc.  ere is rarely ever a single perfect design.  ere are usually trade-o s. Design is an iterative process that evolves with time.

设计任何东西都需要做出决定以使事情变得“好”。“好”可能指拥有一个易于维护的软件组件;“好”也可能指可以在其他应用程序中重用的类; 或者“好”可能指一个非常强大的系统——强大到可以从几乎任何灾难性事件中恢复。“好”可能指一个更容易使用，更漂亮的设计。很少有一个完美的设计。通常它只是一种平衡。而设计是一个随时间演变的迭代过程。

Design is in uenced by personal opinion, evolving research, and the domain, which could be banking, information systems, process control, engineering, and so on. Fortunately, there are design guidelines to show the way, a few of which are presented later. Let’s now turn to the con- struct that captures many of these design decisions in object-oriented software development—the class de nition.

设计受个人意见，不断发展的研究和领域的影响。可能是银行，信息系统，过程控制，工程等。幸运的是，有一些设计指南可以总结出设计模式，其中一些将在后面介绍。现在，让我们转向在面向对象的软件开发中捕获许多这些设计决策的结构—— __类的定义__。

 e classes of objects under study—ostream, istream, string, BankAccount, and Grid—are building blocks of larger programs. However, programs typically require many other classes.  ey may be standard classes, classes that are bought o  the shelf, or other classes that must be de- signed and implemented by a programming team.Because it is di cult to have mastery of all classes in a large project, this section provides some general techniques for understanding unfamiliar classes.  e knowledge attained here also provides experience with the major component of object-oriented software development—the class.

我们所学习过的对象的类，通常是大型程序的基石，例如`study-ostream`，`istream`，`string`，`BankAccount`和`Grid`。但是，程序通常需要许多其他类。它们可能是标准类，常用的类，或者其他必须由编程团队设计和实现的类。
因为很难掌握大型项目中的所有类，所以本节提供了一些理解不熟悉的类的一般技巧。另外，我们还提供一些面向对象软件开发的重要经验。

 is process begins with learning to read class de nitions. You will also implement member functions and add new operations to existing classes.  is approach has the added bene t of mak- ing it easier to design and implement new classes of your own.A class de nition lists member functions after the keyword public:.  is set of operations represents the class interface.  e class de nition also lists the data members—the object declara- tions after private:.  is set of data members represents the state of the objects.A class de nition provides a lot of information. A class de nition stresses the what, not the how. It lists the messages understood by the objects. It speci es the number, type, and orderof arguments required when sending a message to one of the objects. When documented with preconditions, postconditions, and example messages, a class de nition also explains how to use instances of the class.  e documentation may provide other pertinent information. All of these things allow the programmer to use objects of the class without knowing the details of the imple- mentation.

这个过程从学着阅读类的定义开始。您还将实现成员函数，以及向现有类添加新操作。实现这一目标有一个额外的好处——它可以更容易地设计和实现自己的新类。

一个类的定义中，成员函数列在关键字`public:`之后。这组操作操作代表了类的接口。类定义还列出了`数据成员`——也就是那些`private:`关键字之后的对象声明。数据成员集表示了对象的状态。

类的定义提供了大量信息。类定义强调的是“它是什么”，而不是“它是如何实现的“。它列出了对象理解的消息。当消息发送给给对象时，它也指定了参数的数量、类型和顺序。文档可以说明前置条件、后置条件和示例消息，而类类的定义解释了如何使用类的实例。文档还可能提供其他相关信息。所有这些信息都使得程序员程序员能够在不知道实现细节的情况下使用类的对象。

【代码 6.1】

##### 6.1.1 定义`BankAccount`类
Now let’s get down to a concrete, familiar example. Recall that the data members in the private section represent the state. Every BankAccount object stores its own private name and balance data.  e public section has the member functions representing the messages each BankAccount understands: withdraw, deposit, getBalance, and getName.  ese are combined in the header  le BankAccount.h as a class de nition.

现在让我们来看一个具体、熟悉的例子。回想一下，标记为”私有“的数据成员代表了对象的状态。每个`BankAccount`对象都存储自己的私有名称和余额数据。标记为”公有“的成员函数代表每个`BankAccount`对象理解的消息的成员函数：`withdraw`，`deposit`，`getBalance`和`getName`。这些都作为类的定义，在头文件`BankAccount.h`中组合在一起。

【BankAccount头文件代码】

Most BankAccount member function headings in this BankAccount class de nition are similar to the nonmember function headings—they usually have return types and parameters. However, one of the member function headings above does not fall into this category. Can you spot some- thing di erent about the function heading with the name BankAccount?First of all, the BankAccount::BankAccount member function has no return type. It also has the same name as the class!  ese special member functions are referred to as constructors be- cause they are used to “build” objects. Speci cally, constructors associate the object name witha portion of memory and initialize the data members of the object as in a BankAccount object construction. For example, this code constructs a BankAccount object with an initial name of "Pat Barker" and an initial balance of 507.34, which can be referenced with the variable named anAccount.

在`BankAccount`类定义中的大多数成员函数的定义，都类似于其非成员函数——它们通常具有返回类型和参数。但是，上述成员函数之一不属于此类别。您能否找到名称为`BankAccount`的函数定义的不同之处？
首先，`BankAccount::BankAccount`成员函数没有返回类型。它也与类同名！这些特殊的成员函数被称为`构造函数`，因为它们用于“构建”对象。具体而言，构造函数将对象名称与内存的一部分关联在一起，并在`BankAccount`对象构造中初始化对象的数据成员。例如，以下代码会构造一个`BankAccount`对象，其初始名称为“Pat Barker”，初始余额为507.34，并且可以使用名为`anAccount`的变量引用。

```
BankAccount anAccount("Pat Barker", 507.34);
```

让我们再来构造一个对象：

```
BankAccount another("Skyler Boatwright", 437.05);
```

there exists a separate BankAccount object with its own balance of 437.05 and its own name of "Skyler Boatwright". So the return values of these two messages would be 507.34 followed by 437.05.

于是我们有了一个独立的`BankAccount`对象，它的名字是”Skyler Boatwright“，余额为437.05元。于是以下两个表达式的打印输出就是507.34和437.05：

```
cout << anAccount.balance() << endl;  // 507.34cout << another.balance() << endl;    // 437.05
```

#### 自我检查

请根据这个类的定义来回答以下问题：

【类的定义】

6-1 What is the name of the class de ned above?

6-2 Name all the member functions that modify the state of the objects.6-3 Name all the member functions that access the state of the objects and cannot change that state.

6-4 Name all data members.6-5 What type of value is returned by LibraryBook::getBorrower?6-6 What type of value is returned by LibraryBook::isAvailable?6-7 Initialize one LibraryBook object using your favorite book and author.6-8 Send the message that borrows your favorite book. Use your own name as the argument.6-9 Write the message that returns the borrower’s name of the book.

6-1 上述所定义的类的名称是什么？

6-2 写出会修改对象状态的所有成员函数。

6-3 写出访问对象状态，并且不能更改该状态的所有成员函数。

6-4 写出所有数据成员。

6-5 `LibraryBook::getBorrower`返回什么类型的值？

6-6 `LibraryBook::isAvailable`返回什么类型的值？

6-7 使用您喜欢的书籍和作者初始化一个`LibraryBook`对象。

6-8 发送借阅您最喜欢的书的消息。使用您自己的名称作为参数。

6-9 写出返回借书人名字的信息。


