## 第六章 类的定义与成员函数

### 前章回顾
Functions hide details, can be called many times, can be reused in other programs, and help in the design of larger programs. Each function performs a well-defined service.

函数隐藏了实现细节，并且可以调用很多次，也可以在其他的程序中重用，这在大型程序设计中非常有用。每个函数都实现了一个定义良好的服务。

### 本章提要

When a function belongs to a class, it becomes a class member function. Class member functions have a lot in common with their nonmember cousins. Chapter 6 presents an introduction to C++ class de nition and member function implementations. You will learn to read and understand classes by their de nitions—the collection of member function headings (the interface) and data members (the state). In the second part of this chapter, you will learn to implement class member functions. You will also see a few appropriate object-oriented design guidelines that help explain why classes are designed the way they are. After studying this chapter, you will be able to

+ read and understand class definitions (interface and state) 
+ implement class member functions using existing class defnitions 
+ apply some object-oriented design guidelines

当一个函数属于一个类时，它就成了这个类成员函数。类成员函数与非成员函数之间有很多共同之处。 第6章介绍了C++类定义和成员函数实现。您将学习通过其 ___定义___（成员函数头文件定义（接口）和数据成员（状态）的集合）来阅读和理解类。在本章的第二部分中，您将学习如何实现类成员函数。 您还将看到一些适当的面向对象设计指南，这些指南有助于解释为什么那些类要设计成那个样子。学完本章后，您将能够：

+ 阅读和理解类定义（接口和状态）

+ 使用现有的类定义实现类成员函数

+ 运用一些面向对象的设计指南

### 6.1 在头文件中定义类

Abstraction refers to the practice of using and understanding something without full knowledge of its implementation. Abstraction allows the programmer using a class to concentrate on the data characteristics and the messages that manipulate the state. For example, a programmer using the string class need not know the details of the internal data representation or how those opera- tions are implemented in the hardware and software.  e programmer can concentrate on the set of allowable messages—the interface.

This chapter presents some implementation issues that so far have been hidden. In the  rst part of this chapter, the BankAccount class will be studied at the implementation-detail level. However, before examining the physical side of class design, let’s consider some of the design decisions that were made for this textbook’s BankAccount class.

抽象是指在不完全了解其实现的情况下使用和理解某些东西的做法。抽象允许程序员集中于数据的特征和操纵状态的消息。例如，使用字符串类的程序员既不需要知道内部数据表示的细节，也不需要知道如何在硬件和软件中实现这些操作。 程序员可以专注于允许的消息集-- ___接口___。

本章介绍了迄今为止隐藏的一些实现问题。在本章的第一部分，我们会在实现细节层面进行研究`BankAccount`类。但是，在我们深入了解其实现细节之前，让我们考虑一下为本书的`BankAccount`类做出的一些设计上的决定。

All BankAccount objects have four allowable operations: deposit, withdraw, getBalance, and getName.  ere could have been more, or there could have been fewer.  e member functions for BankAccount were chosen to keep the class simple and to provide a collection of operations that are relatively easy to relate to. A compromise was made.  e design decisions were in uenced by the context—a  rst example of a C++ class used in a particular domain, the area of banking. e BankAccount member functions that make up the interface are only a subset of the operations named by students who were asked this question: what should we be able to do with bank accounts?  e data members are also a subset of the operations named by students who were asked this question: what should bank accounts know about themselves?
 
所有`BankAccount`的对象都允许四个操作：`deposit`，`withdraw`，`getBalance`和`getName`。我们当然也可以定义更多，或者更少的成员函数，但是我们在此遵从一个原则：应该保持`BankAccount`类的简洁，并且操作也应该是容易且相关的。于是我们在此做了妥协。设计决策也受到场景的影响——我们在定义特定领域（银行领域）中使用的C++类的第一个例子。
  
`BankAccount`的这四个成员函数是为了解决这个问题：我们应该如何处理银行账户？而数据成员则解决了这个问题：银行账户应该了解自己的哪些内容？

Many additional operations that were recognized by students (transfer, applyInterest, printMonthlyStatement) and many additional data members (type of account, record of trans- actions, address, Social Security number, and mother’s maiden name) were not included.  e design of these classes was a ected by the intention of keeping these objects as simple as pos- sible while retaining some realism. However, a group of object-oriented designers developing large-scale applications in the banking domain would likely retain many of the operations and attributes recognized by students.  ere is rarely one single design that is correct for all circum- stances.

学生们认可的许多其他操作（`transfer`，`applyInterest`，`printMonthlyStatement`）和许多其他数据成员（帐户类型，交易记录，地址，社会安全号码和母亲的婚前姓名）均未包括在内。在这里，类的设计是为了保持对象尽可能简单，同时保留一些实用性。相反地，在现实的银行领域的大规模应用程序中，很多面向对象的设计人员开发很可能会保留这些学生认可的许多操作和属性。很少有一种设计适合所有环境。

Designing anything requires making decisions in an e ort to make the thing “good.” Good might mean having a software component that is easily maintainable; it might mean classes that can be reused in other applications; or it might mean a system that is very robust—one that can recover from almost any disastrous event. Good might mean a design that results in something that is easier to use, prettier, etc.  ere is rarely ever a single perfect design.  ere are usually trade-o s. Design is an iterative process that evolves with time.

设计任何东西都需要做出决定以使事情变得“好”。“好”可能指拥有一个易于维护的软件组件;“好”也可能指可以在其他应用程序中重用的类; 或者“好”可能指一个非常强大的系统——强大到可以从几乎任何灾难性事件中恢复。“好”可能指一个更容易使用，更漂亮的设计。很少有一个完美的设计。通常它只是一种平衡。而设计是一个随时间演变的迭代过程。

Design is in uenced by personal opinion, evolving research, and the domain, which could be banking, information systems, process control, engineering, and so on. Fortunately, there are design guidelines to show the way, a few of which are presented later. Let’s now turn to the con- struct that captures many of these design decisions in object-oriented software development—the class de nition.

设计受个人意见，不断发展的研究和领域的影响。可能是银行，信息系统，过程控制，工程等。幸运的是，有一些设计指南可以总结出设计模式，其中一些将在后面介绍。现在，让我们转向在面向对象的软件开发中捕获许多这些设计决策的结构—— __类的定义__。

 e classes of objects under study—ostream, istream, string, BankAccount, and Grid—are building blocks of larger programs. However, programs typically require many other classes.  ey may be standard classes, classes that are bought o  the shelf, or other classes that must be de- signed and implemented by a programming team.Because it is di cult to have mastery of all classes in a large project, this section provides some general techniques for understanding unfamiliar classes.  e knowledge attained here also provides experience with the major component of object-oriented software development—the class.

我们所学习过的对象的类，通常是大型程序的基石，例如`study-ostream`，`istream`，`string`，`BankAccount`和`Grid`。但是，程序通常需要许多其他类。它们可能是标准类，常用的类，或者其他必须由编程团队设计和实现的类。
因为很难掌握大型项目中的所有类，所以本节提供了一些理解不熟悉的类的一般技巧。另外，我们还提供一些面向对象软件开发的重要经验。

 is process begins with learning to read class de nitions. You will also implement member functions and add new operations to existing classes.  is approach has the added bene t of mak- ing it easier to design and implement new classes of your own.A class de nition lists member functions after the keyword public:.  is set of operations represents the class interface.  e class de nition also lists the data members—the object declara- tions after private:.  is set of data members represents the state of the objects.A class de nition provides a lot of information. A class de nition stresses the what, not the how. It lists the messages understood by the objects. It speci es the number, type, and orderof arguments required when sending a message to one of the objects. When documented with preconditions, postconditions, and example messages, a class de nition also explains how to use instances of the class.  e documentation may provide other pertinent information. All of these things allow the programmer to use objects of the class without knowing the details of the imple- mentation.

这个过程从学着阅读类的定义开始。您还将实现成员函数，以及向现有类添加新操作。实现这一目标有一个额外的好处——它可以更容易地设计和实现自己的新类。

一个类的定义中，成员函数列在关键字`public:`之后。这组操作操作代表了类的接口。类定义还列出了`数据成员`——也就是那些`private:`关键字之后的对象声明。数据成员集表示了对象的状态。

类的定义提供了大量信息。类定义强调的是“它是什么”，而不是“它是如何实现的“。它列出了对象理解的消息。当消息发送给给对象时，它也指定了参数的数量、类型和顺序。文档可以说明前置条件、后置条件和示例消息，而类类的定义解释了如何使用类的实例。文档还可能提供其他相关信息。所有这些信息都使得程序员程序员能够在不知道实现细节的情况下使用类的对象。

【代码 6.1】

##### 6.1.1 定义`BankAccount`类
Now let’s get down to a concrete, familiar example. Recall that the data members in the private section represent the state. Every BankAccount object stores its own private name and balance data.  e public section has the member functions representing the messages each BankAccount understands: withdraw, deposit, getBalance, and getName.  ese are combined in the header  le BankAccount.h as a class de nition.

现在让我们来看一个具体、熟悉的例子。回想一下，标记为”私有“的数据成员代表了对象的状态。每个`BankAccount`对象都存储自己的私有名称和余额数据。标记为”公有“的成员函数代表每个`BankAccount`对象理解的消息的成员函数：`withdraw`，`deposit`，`getBalance`和`getName`。这些都作为类的定义，在头文件`BankAccount.h`中组合在一起。

【BankAccount头文件代码】

Most BankAccount member function headings in this BankAccount class de nition are similar to the nonmember function headings—they usually have return types and parameters. However, one of the member function headings above does not fall into this category. Can you spot some- thing di erent about the function heading with the name BankAccount?First of all, the BankAccount::BankAccount member function has no return type. It also has the same name as the class!  ese special member functions are referred to as constructors be- cause they are used to “build” objects. Speci cally, constructors associate the object name witha portion of memory and initialize the data members of the object as in a BankAccount object construction. For example, this code constructs a BankAccount object with an initial name of "Pat Barker" and an initial balance of 507.34, which can be referenced with the variable named anAccount.

在`BankAccount`类定义中的大多数成员函数的定义，都类似于其非成员函数——它们通常具有返回类型和参数。但是，上述成员函数之一不属于此类别。您能否找到名称为`BankAccount`的函数定义的不同之处？
首先，`BankAccount::BankAccount`成员函数没有返回类型。它也与类同名！这些特殊的成员函数被称为`构造函数`，因为它们用于“构建”对象。具体而言，构造函数将对象名称与内存的一部分关联在一起，并在`BankAccount`对象构造中初始化对象的数据成员。例如，以下代码会构造一个`BankAccount`对象，其初始名称为“Pat Barker”，初始余额为507.34，并且可以使用名为`anAccount`的变量引用。

```
BankAccount anAccount("Pat Barker", 507.34);
```

让我们再来构造一个对象：

```
BankAccount another("Skyler Boatwright", 437.05);
```

there exists a separate BankAccount object with its own balance of 437.05 and its own name of "Skyler Boatwright". So the return values of these two messages would be 507.34 followed by 437.05.

于是我们有了一个独立的`BankAccount`对象，它的名字是”Skyler Boatwright“，余额为437.05元。于是以下两个表达式的打印输出就是507.34和437.05：

```
cout << anAccount.balance() << endl;  // 507.34cout << another.balance() << endl;    // 437.05
```

#### 自我检查

请根据这个类的定义来回答以下问题：

【类的定义】

6-1 What is the name of the class de ned above?

6-2 Name all the member functions that modify the state of the objects.6-3 Name all the member functions that access the state of the objects and cannot change that state.

6-4 Name all data members.6-5 What type of value is returned by LibraryBook::getBorrower?6-6 What type of value is returned by LibraryBook::isAvailable?6-7 Initialize one LibraryBook object using your favorite book and author.6-8 Send the message that borrows your favorite book. Use your own name as the argument.6-9 Write the message that returns the borrower’s name of the book.

6-1 上述所定义的类的名称是什么？

6-2 写出会修改对象状态的所有成员函数。

6-3 写出访问对象状态，并且不能更改该状态的所有成员函数。

6-4 写出所有数据成员。

6-5 `LibraryBook::getBorrower`返回什么类型的值？

6-6 `LibraryBook::isAvailable`返回什么类型的值？

6-7 使用您喜欢的书籍和作者初始化一个`LibraryBook`对象。

6-8 发送借阅您最喜欢的书的消息。使用您自己的名称作为参数。

6-9 写出返回借书人名字的信息。

6.2 IMPLEMENTING CLASS MEMBER FUNCTIONS
Class member function implementations are similar to those of their nonmember relatives—with these differences:
1. Class member functions implemented outside of the class definition must be quali- fied with the class name and the scope resolution operator ::. This tells the compiler they are member functions of a particular class and as such, they are allowed to di- rectly reference the private data members.
2. The constructors are class member functions with the same name as the class and they do not have a return type. The return type is not needed because constructors return a new object of the type specified in the constructor and class name.
The relatively familiar BankAccount class will be used to demonstrate member function implementations. For each .h file there will be a .cpp file that #includes the .h (header) file with the class definition. This .cpp file implements the member functions.

### 6.2 实现类的成员函数

类的成员函数实现类似于非成员函数，不过有以下差异：

1. 在类定义之外实现的类成员函数必须使用类名和作用域解析运算符::来定义。这告诉编译器它们是特定类的成员函数，因此，它们可以直接引用私有数据成员。

2. 构造函数也是是类的成员函数，特殊之处在于它与类具有相同的名称，并且没有返回类型。返回类型是不必要的，因为构造函数总是返回类的新实例。

我们将使用相对熟悉的`BankAccount`类,来演示成员函数实现。对于每个`.h`文件，都会有一个`.cpp`文件，其中使用`#include`关键字引用了带有类定义的.h（头文件）文件。 这个`.cpp`文件实现了成员函数。


6.2.1 IMPLEMENTING CONSTRUCTORS
A constructor is a special member function that always has the same name as the class. It never has a return type. Although member functions can be defined within a class definition, this textbook uses the software engineering principle of separating interface from implementation by implementing the member functions in a separate file. In this case, the member functions must begin with class-name ::.

The following code implements the two-parameter constructor:

### 6.2.1 实现构造函数

构造函数是一个特殊的成员函数，它始终与该类具有相同的名称。构造函数永远不会有返回类型。虽然可以在类定义中定义成员函数，但是本书中会遵循软件工程原则，即在单独的文件中实现成员函数，以将接口与实现分离。在这种情况下，成员函数必须以`类名::`开头。

以下代码实现了一个构造函数，它接收两个变量输入：

【代码】

This is the function that executes whenever a BankAccount is initialized with two arguments: a string followed by a number.
In the following code, the account name "Corker" is passed to the parameter initName, which in turn is assigned to the private data member name. The starting balance of 250.55 is also passed to the parameter named initBalance, which in turn is assigned to the private data mem- ber balance. After an object is constructed, the state of the object is initialized.


每当`BankAccount`被创建时，这个函数都会被执行。它有两个参数，第一个参数为字符串，第二个为数字。

在以下代码中，帐户名称`Corker`将会被传递给参数`initName`，而参数`initName`又分配给私有数据成员`name`。起始余额 250.55 也会被传递给参数`initBalance`，该参数又分配给私有数据成员`balance`。对象被创建后，对象的状态也将被初始化。

【代码】

There is a major difference between implementing class member functions and their non- member cousins. Class member function implementations must be preceded with the class name and the :: operator. For example, the BankAccount constructor is preceded with BankAccount:: to inform the compiler that it is a member function and as such, has access to the object’s private data members. Failure to add BankAccount:: results in a nonmember function that cannot refer- ence the data members. For example, the compiler will generate error messages at any attempt to access private data members (name and balance). BankAccount:: is missing.

实现类的成员函数和非成员函数之间存在一个重大差异，那就是类的成员函数实现必须以类名和::运算符开头。例如，BankAccount构造函数前面有`BankAccount::`，然后编译器会知道它是一个成员函数，于是这个函数就可以访问该对象的私有数据成员了。如果没有`BankAccount::`，那么这个函数就无法引用数据成员的非成员函数。例如，如果尝试访问私有数据成员（`name`和`balance`），那么编译器就会抛出错误消息：`BankAccount ::缺少`。

【代码】

Scope Rule for C++ Classes
The scope of private members is limited to the class member functions.

__C++类的作用域规则__

私有成员的作用域局限于类的成员函数。只有类的成员函数才能访问私有成员。

6.2.2 IMPLEMENTINGMODIFYINGMEMBERFUNCTIONS
A member function may either modify the state or access the state of an instance of the class. For example, consider BankAccount::deposit, which modifies the private data member balance.

### 6.2.2 使用成员函数修改成员变量

成员函数可以修改或访问类实例的状态。例如，考虑`BankAccount::deposit`，它会修改私有数据成员`balance`。

【代码】

When the following deposit message is sent, the argument 157.42 is copied by value to the
parameter depositAmount, which is then added to this object’s balance:

发送以下`deposit`消息时，参数157.42将被赋值给参数`depositAmount`，然后被赋值给此对象的`balance`成员：

【代码】

Notice that the function headings match the class definition. Specifically, the return type of BankAccount::deposit is void and there is one double argument.

请注意，函数标题（heading）需与类的定义匹配。具体来说，`BankAccount::deposit`的返回类型为void，并且有一个类型为double的参数。

【代码】

The BankAccount::withdraw function is another modifying member function that changes the state of a BankAccount object. Specifically, a withdraw message deducts withdrawalAmount from balance:

`BankAccount::withdraw`函数是另一个会修改实例状态的成员函数。具体而言，`widhdraw`消息会从`balance`变量中扣除`withdrawAmount`：

【代码】

When the following withdraw message is sent, the argument 50.00 is copied by value to the
parameter withdrawalAmount, which is then subtracted from balance:

当发送以下`withdraw`消息时，参数50.00会被赋值给变量`withdrawAmount`，然后从`balance`中减去：

【代码】

As you are implementing class member functions, make sure all function headings match the appropriate function heading in the class definition. Your member function implementations, stored in a different file, must have the same exact return type, function name, number, type, and order of parameters as exist in the class definition. A good idea is to copy all the member func- tions to your implementation file. That will ensure you keep member function headings the same and you won’t miss implementing a member function. Then replace the semicolon at the end of each member function heading with a function body and add the class name:: to the start of each member function name.
It should be noted here that there could be much more processing within the body of a class member function. The member function implementations in this chapter have been kept inten- tionally simple during this introduction to member function implementations.


在实现类成员函数时，请确保所有函数标题与类定义中的相应函数标题匹配。存储在不同文件中的成员函数的实现必须具有与类定义中存在的、完全相同的返回类型，函数名称，数量，类型和参数顺序。一般可以将所有成员函数复制到同一个实现文件中。这将确保您保持成员函数标题相同，并且您不会忘记实现某个成员函数。然后用函数体替换每个成员函数标题末尾的分号，并将`类名::`添加到每个成员函数名的开头。

这里应该注意，在类成员函数的主体内可以有更多的处理方式。在介绍成员函数实现的过程中，本章中的成员函数实现一直保持较为简单的形式。

6.2.3 IMPLEMENTING ACCESSING MEMBER FUNCTIONS
It is good design to make the data members private and have functions that allow access to that state. Some of these accessing functions simply return the value of a data member.

#### 6.2.3 使用成员函数访问成员变量

将数据成员设为私有并具有允许访问该状态的函数是一种很好的设计。其中一些访问函数仅用于返回数据成员的值。

【代码】

Because these accessing functions in the class definition have the keyword const, the imple- mentation of the member function must also include const after the function heading and before the block start at {. The keyword const denotes a member function that does not modify state.
If you examine the accessor implementations above, you’ll notice no data members get changed in the block. getName and getBalance simply return the values of those data members. If you pass an object by const & reference, these const methods can be used in that other function. On the other hand, the modifying functions withdraw and deposit change the state of the object, balance specifically. If you pass an object by const & reference, an attempt to use these modify- ing (non const) methods will be the source of a compile time error. The const function can be used when passed by const reference.

因为类定义中的这些访问函数具有关键字`const`，所以成员函数的实现还必须在函数标题之后、块（从`{`开始的部分）之前包含`const`。关键字`const`表示这个成员函数不修改状态。
如果您仔细查看上面的访问器实现，您就会注意到，函数块中没有数据成员被更改。 `getName`和`getBalance`只返回这些数据成员的值。如果通过`const ＆`传递对象的引用，则可以在其他函数中使用这些const方法。另一方面，修改功能`withdraw`和`deposit`改变了对象的状态，具体而言也就是`balance`变量。如果通过`const＆`传递对象引用，则尝试使用这些会产生修改的（非`const`）方法将成为编译时错误的来源。 可以使用`const`的引用来使用`const`函数。

Remember to make sure all member function headings exactly match the headings in the class definitions (without ;). And remember to type the class name and :: before the class mem- ber function name in the .cpp files. To summarize, here is the complete implementation of all of BankAccount member functions in the file BankAccount.cpp.

需要谨记的是，应确保所有成员函数标题与类定义中的标题完全匹配（不带;）。并且要记得，在`.cpp`文件中的类成员函数名之前应写上类名和::。以下是`BankAccount.cpp`文件中所有`BankAccount`成员函数的完整实现。

【代码】


SELF-CHECK
6-10 How does a function implementation become a member of a class?
6-11 Can class member functions reference the private data members?
6-12 Can nonmember functions reference private data members?
6-13 Use this implementation of the LibraryBook member functions to write the output gener- ated by the program below:

自我检查

6-10 一个函数的实现如何成为一个类的成员？

6-11 类的成员函数可以引用私有数据成员吗？

6-12 非成员函数可以引用私有数据成员吗？

6-13 使用`LibraryBook`的成员函数的实现来编写由以下程序生成的输出：

【代码】

Here is the program that uses this new type LibraryBook now implemented as a C++ class.

这端代码使用了这种新类型的`LibraryBook`：

【代码】

6.3 DEFAULT CONSTRUCTORS

Every class requires at least one constructor. A class can have more than one, as long as they have a different number, type and/or order of parameters. Consider this simple class Adder that
has two constructors. The constructor with no parameters is known as the default constructor. The programmer can specify whatever default state seems appropriate in the default constructor, which in this case sets the data member sum to 0.0.

6.3 默认构造函数

每个类至少需要一个构造函数。一个类也可以有多个构造函数，只要它们具有不同的数量、类型或顺序的参数。考虑一下这个简单的类`Adder`。它有两个构造函数。没有参数的构造函数称为默认构造函数。程序员可以在默认构造函数中指定任何默认状态，在以下例子中，我们将数据成员总和设置为0.0。

【代码】


Because class Adder has two constructors, Adder objects can be constructed two different
ways.

因为类`Adder`有两个构造函数，所以`Adder`对象可以使用两种方式来构造。

【代码】

The object referenced by adder1 gets built using the one argument constructor Adder::Adder(double start). The object referenced by adder2 gets built using the default con- structor Adder::Adder(), which initializes sum to 0.0 as shown in the class implementation file Adder.cpp.


`adder1`所引用的对象使用“一个参数版本的构造函数”`Adder::Adder（double start）`构建。`adder2`引用的对象使用默认的构造函数`Adder::Adder()`构建，它将sum初始化为0.0，如类实现文件`Adder.cpp`中所示。

【代码】

The following program uses both constructors to show the difference.

以下程序同时使用两个构造函数以示区别：

【代码】

Here are the reasons to have a default constructor in addition to other constructors:
yThey are required to have collections of objects (see Chapter 10, “Vectors”).
yThey guarantee initialization to a specific state. Programmers always know what to expect
(more vivid examples are yet to come).
yThey define the default values used when another default constructor is called. For example,
the default state for string is the empty string "".

除了其他构造函数之外，还需要默认构造函数的原因有：

+ 他们需要有对象集合（参见第10章“向量”）。
+ 他们保证初始化到特定的状态。程序员总是知道会发生什么（更生动的例子还未到来）。
+ 他们定义了在调用另一个默认构造函数时使用的默认值。 例如，`string`的默认状态是空字符串`""`。

6.3.1 FUNCTION OVERLOADING
You may be wondering how there could be two constructors since they have the same name. Through a technique known as function overloading, more than one function with the same name is allowed to exist. However, there has to be something that distinguishes two functions with the same name. One of these distinguishing characteristics is having a different number of parameters. Function overloading allows the programmer to have a default constructor with zero parameters in the same scope as a constructor with one or more parameters. In other words, C++ distinguishes between the two constructor function headings inside the class definition.
Function overloading also occurs when the type of parameters differs, even if there are the same number of parameters. These three functions may exist in the same scope because the types of the one parameter are different.

#### 6.3.1 函数重载

您可能想知道，为什么会出现有两个构造函数，因为它们具有相同的名称。通过称为`函数重载`的技术，允许存在多个具有相同名称的函数。但是，必须有一些特征来区分两个具有相同名称的函数。这些区别特征之一是具有不同数量的参数。函数重载允许程序员在具有一个或多个参数的构造函数的同一范围内具有零参数的默认构造函数。换句话说，C++可以区分类定义中的两个构造函数标题。

当参数类型不同时，即使参数数量相同，也会发生函数重载。以下三个函数可能存在于同一作用域内，因为一个参数的类型不同。

【代码】

These functions may exist in the same scope because the order of parameters is different.

这两个函数可以存在于同一作用域内，因为参数的顺序不同。

【代码】

However, functions that differ only in their return type cannot be overloaded.

然而，以下两个函数仅有返回值有差异，他们无法被重载。

【代码】


6.4 THE STATE OBJECT PATTERN
Even though quite different in specific operations and state, string, BankAccount, and LibraryBook objects have the following common characteristics:
yprivate data members store the state of the object yconstructors initialize the state
ysome messages modify the state
yother messages allow access to the current state of the object
These commonalities guide the effective use of these and similar classes of objects. These patterns also help programmers understand how to use new objects. The constructors, modifiers, and ac- cessors in the public: section of a class definition are the operations available to all instances of the class.

#### 6.4 State Object模式

尽管在特定操作和状态方面有很大不同，但`string`，`BankAccount`和`LibraryBook`对象具有以下共同特征：

+ 使用私有数据成员存储对象的状态
+ 使用构造函数初始化状态
+ 有一些消息可以修改状态
+ 其他消息允许访问对象的当前状态

这些共性指导了这些和类似对象类的有效使用。这些模式还有助于程序员了解如何使用新对象。`public:`段中的构造函数、修改函数和访问函数是可用于该类的所有实例的操作。

6.4.1 CONSTRUCTORS
Constructors are present for many reasons, including initializing the state of any instance of the class. As shown earlier, objects are initialized like this:

#### 6.4.1 构造函数
构造函数存在的原因有很多，包括初始化类的任何实例的状态。如前所示，对象可以像这样初始化：

【代码】

6.4.2 MODIFIERS
Modifying methods change the state of an object. Modifiers are part of the State Object pattern for a variety of reasons. Perhaps it’s best to simply show some example messages that modify the state of an object:

#### 6.4.2 修改函数

修改函数会更改对象的状态。由于各种原因，修改函数是State Object模式的一部分。也许最好只显示一些修改对象状态的示例消息：

【代码】

Sending a modifier message results in a change of state. Modifiers are not declared with const after the function heading—accessors are.

发送修改消息会导致状态发生变化。在函数头中，修改函数不会用const声明——但是访问函数可以。

6.4.3 ACCESSORS
Accessors are part of the state object pattern simply because programmers often need to access the state of an object. An accessor message returns information related to the state of an object. An accessor may simply return the value of a data member as with LibraryBook::borrower and BankAccount::balance. Accessors may also need to do some internal processing using the state of an object to return the information (employee::incomeTax, for instance). Here are some example messages that access the state of objects:

#### 6.4.3 访问函数

访问函数是State Object模式的一部分，因为程序员经常需要访问对象的状态。访问函数返回与对象状态有关的信息。访问函数可以像`LibraryBook::borrower`和`BankAccount::balance`一样简单地返回数据成员的值。访问者可能还需要使用对象的状态进行一些内部处理以返回信息（例如，`employee::incomeTax`）。以下是一些访问对象状态的示例消息：

【代码】

6.4.4 NAMING CONVENTIONS
Modifying operations are typically given a name that indicates the message will change the state of the object. This is easily accomplished if the designer of the class simply gives a descriptive name to the operation. The name should describe—as best as possible—what the operation actually does. Another way to help programmers who use a class to distinguish modifiers from accessors is to give the modifiers names that can be used as verbs such as withdraw, deposit, borrowBook, and returnBook, for example. The accessors are given names that often begin with “get,” such as getBorrower and getBalance. Considering that the constructor has the same name as the class, some guidelines are established for designing and reading class definitions. These three categories of operations—typical of state objects—can be distinguished by using the follow- ing naming conventions.

6.4.4 命名约定

通常我们会为修改操作取一个易懂的名字，这个名字可以暗示消息将更改对象的状态。如果类的设计者只是为操作提供描述性名称，那么这很容易实现。该名称应该尽可能最好地描述操作实际上做了什么。帮助程序员使用类来区分修改函数和访问函数的另一种方法是使用动词来命名修改函数，例如，`withdraw`，`deposit`，`borrowBook`和`returnBook`。访问器的名称通常以“get”开头，例如`getBorrower`和`getBalance`。考虑到构造函数与类具有相同的名称，这里有一些用于设计和阅读类定义的准则。这三类操作（典型的状态对象）可以通过使用以下命名约定来区分。

操作		名称
构造函数	与类名称相同
修改函数	能够当动词使用的名称
访问函数	以get开头的名称

Above all, always try to use identifiers that describe what the object is. For example, don’t use x as the name of the operation to withdraw money from a BankAccount or turnRight to make the mover turn left.

最重要的是，我们应该尽量使用能够描述对象是什么的标识符。例如，不要使用`x`作为从`BankAccount`对象中取款的函数名，也不要使用`turnRight`表示向左转向。

6.4.5 public: OR private:
One of the considerations in the design of a class is the placement of member functions and data members under the most appropriate access mode, either public: or private:. Whereas public members of a class can be called from another function outside of the class, the scope of private members is limited to the class member functions. For example, the BankAccount data member balance is only known to the member functions of the BankAccount class. On the other hand, any member declared in the public: section of a class is known everywhere in the class and also in the block of source code where the object is declared (or globally, if defined outside of a block).

6.4.5 使用`public:`还是`private:`

设计类的一个考虑因素是将成员函数和数据成员放在`public:`合适还是`private:`合适。类的公共成员可以从类外部的另一个函数调用，而私有成员的范围仅限于类成员函数。例如，`BankAccount`数据成员`balance`仅为`BankAccount`类的成员函数所知。另一方面，在`public:`段中声明的任何成员在类中的任何地方都是可访问的，并且在声明对象的源代码块中也是已知的（如果在块之外定义，则为全局的）。

访问模式		成员可以在多大的作用域被访问？
public:		在所有类成员函数中以及在声明对象的客户端代码块中（例如，在main中）。
private:		只在类的成员函数内部。因为这些在类中的任何地方都是已知的，所以您不必在类成员函数中传递或返回这些值。

Although the data members representing state could have been declared under public:, it is highly recommended that all data members be declared under the private: access mode. There are several reasons for this.
The consistency helps simplify some design decisions. More importantly, when data members are made private:, the state can be modified only through a member function. This prevents client code from indiscriminately changing the state of objects. For example, it’s impossible to accidentally make a credit like this from anywhere outside of the class:

尽管表示状态的数据成员也可以在`public:`下声明，但强烈建议在`private:`下声明所有数据成员。这么做有以下几个原因。
一致性有助于简化一些设计决策。更重要的是，当数据成员变为`private:`时，只能通过成员函数修改状态。这可以防止客户端代码不加区别地更改对象的状态。例如，不可能在类之外的任何地方意外地设置余额：

【代码】

6.4.6 SEPARATING INTERFACE FROM IMPLEMENTATION
The practice of studying a class through its interface represents a principle in software engineer- ing. It allows one to separate the interface from the implementation—the details of how the operations actually work. In C++, the completed member function implementations are often separated from the class definition by placing them in separate files. Historically, class definitions have been kept in .h (header) files with member function implementations in .cpp files (file extensions vary). Some programmers implement the member functions directly in the same file as the class definitions.
The convention used in this textbook is to separate the class definition from the implemen- tation. This is done by storing the class definition in a .h file and the member function imple- mentations in a .cpp file. It is often the case that several files are combined together to make an executable program. There are several ways to do this. The following figure illustrates one way to do this with these commands using the GNU compiler:

#### 6.4.6将接口从实现中分离

软件工程的一个原则就是可以通过接口来了解类。它允许人们将接口与实现（操作实际工作的细节）分开。在C++中，已完成的成员函数实现通常通过将它们放在单独的文件中而与类定义分离。从历史上看，类定义通常保存在.h（头）文件中，然后在.cpp文件中存放成员函数实现（文件扩展名各不相同）。一些程序员也直接在与类定义相同的文件中实现成员函数。

本教材中使用的约定是将类定义与实现分开。也就是说，将类定义存储在.h文件中，并将成员函数的实现存储在.cpp文件中。通常情况是将几个文件组合在一起以形成可执行程序。有几种方法可以做到这一点。下图说明了使用GNU编译器使用这些命令执行此操作的一种方法：

【代码】
【大图】

SELF-CHECK
6-14 What is meant when the const keyword is part of the function heading in a class defini- tion?
6-15 Which member functions have the same name as the class?
6-16 What do accessors do?
6-17 What do modifiers do?
6-18 What do constructors do?
6-19 What are the data members for?

### 自我检查

6-14 “const关键字是类定义中函数标题的一部分”是什么意思？
6-15 哪种成员函数与类同名？
6-16 访问函数有什么作用？
6-17 修改函数有什么作用？
6-18 构造函数有什么作用？
6-19 数据成员是用来做什么的？


6.5 OBJECT-ORIENTED DESIGN GUIDELINES
One particular object-oriented design decision involves determining where to place the data members that store object state. More specifically, since this text uses C++ as the implementation language, the designer has to decide if data member functions go in the public: or the private: section of a C++ class. The following design guideline states that a good design protects object state from the outside world:

#### 6.5 面向对象设计指南
面向对象的设计决策的决策之一，就是要确定存储对象状态的数据成员的放置位置。更具体地说，由于本文使用C++作为实现语言，因此设计人员必须决定数据成员函数是否在`public:`或C++类的`private:`部分中。以下设计指南指出，良好的设计可以保护对象状态不受外界影响：


Object-Oriented Design Guideline
All data should be hidden within its class.

面向对象设计指南
所有的数据都应该隐藏在类中。

Although data members could be public:, the convention used in this text—and in any well-designed class—is to hide the data members. C++ data members are easily hidden when declared in the private: section of the class definition. This simplifies some design decisions. A private: data member can then only be modified or accessed through messages.
This prevents users of the class from indiscriminately changing certain data such as an ac- count balance. The state of an object can be protected from accidental or improper alteration. With data members declared in the private: section, the state of any object can only be altered through a message. It becomes impossible to accidentally make a false debit like this:

虽然数据成员可以是公共的（放在`public`段中），本文中使用的约定——以及任何设计良好的类——都会选择隐藏数据成员。在类定义的`private:`部分中声明时，可以轻松隐藏C++数据成员。这简化了一些设计决策。`private:`部分的数据成员只能通过消息进行修改或访问。
这可以防止类的用户不加区别地更改某些数据，例如帐户余额(`balance`)。可以保护对象的状态免于意外或不正确的更改。对于在`private:`部分中声明的数据成员，任何对象的状态只能通过消息进行更改。不可能像这样意外地进行操作：

【代码】

However, if balance had been declared in the public: section, the compiler would not protest. The resulting program would allow you to destroy the state of any object. The hidden balance is more properly modified only when the transaction is allowed according to some policy. What happens, for instance, if a withdrawal amount exceeds the account balance in a withdraw message? Some accounts allow this by transferring money from a savings account. Other bank accounts may generate loans in increments of $100.00.

但是，如果在`public:`段中声明了`balance`，则编译器就不会做出这种提醒。生成的程序将允许您销毁任何对象的状态。只有在根据某些策略允许交易时，才能更正确地修改隐藏余额。例如，如果提款金额超过提款消息中的帐户余额，会发生什么？有些账户允许从储蓄账户转账。其他银行账户可能会以100.00美元的增量产生贷款。

With balance declared in the private: access section, users of the class must instead send a withdraw message. The client code relies on the BankAccount to determine if the withdrawal is to be allowed. Perhaps the BankAccount object will ask some other object if the withdrawal is to be allowed. Perhaps it delegates authority to some unseen bankManager object. Perhaps the BankAccount object itself can decide what to do. Although this text’s implementation of BankAccount doesn’t do much, real-world withdrawals do.

在`private:`段中声明`balance`变量后，该类的用户必须改为发送`withdraw`消息。 客户端代码依赖于`BankAccount`来确定是否允许提款。也许BankAccount对象会询问其他对象是否允许提款。也许它将权限委托给一些看不见的`bankManager`对象。也许BankAccount对象本身可以决定做什么。虽然本文对`BankAccount`的实施并没有做太多，但实际的取款操作确实如此。

By hiding data and other details, all credits and debits must “go through the proper chan- nels.” This might be quite complex. For example, each withdrawal or deposit may be recorded in a transaction file to help prepare monthly statements for each BankAccount. The withdraw and deposit operations may have additional processing to prevent unauthorized credits and debits. Part of the hidden red tape might include manual verification of a deposit or a check-clearing operation at the host bank; there may be some sort of human or computer intervention before any credit is actually made. Such additional processing and protection within the deposit and withdraw operations help give BankAccount a “safer” design. Because all hidden processing and protection is easily circumvented when data members are exposed in the public: section, the object designer must enforce proper object use and protection by hiding the data members.

通过隐藏数据和其他细节，所有借记和债务必须“通过适当的渠道”。这可能相当复杂。例如，每个提款或存款可以记录在交易文件中，以帮助为每个BankAccount准备月度报表。提款和存款操作可能有额外的处理，以防止未经授权的信贷和借记。还有可能有一些隐藏的繁文缛节，例如在主办银行手动核实存款或支票清算操作;在实际获得任何信贷之前，可能会进行某种人或计算机干预。存款和取款操作中的这种额外处理和保护有助于使得`BankAccount`设计“更安全”。由于在`public:section`中公开数据成员时，所有隐藏的处理和保护都很容易被规避，因此对象设计者必须通过隐藏数据成员来强制执行适当的对象使用和保护。


6.5.1 COHESION WITHIN A CLASS
The set of messages described in the class interface should be strongly related. A class stores data, and that data should be strongly related. In fact, all elements of a class should have a persuasive affiliation with each other. These ideas relate to the preference for tight cohesion (solidarity, hang- ing together, adherence, unity) within a class. For example, don’t expect a BankAccount object to understand the message isPreheated. This may be an appropriate message for an oven object, but certainly not for a BankAccount object. Here is one guideline related to the desirable attribute of cohesion:

6.5.1 类的凝聚
类接口中描述的消息集应该是密切相关的。类存储数据，并且这些数据应该紧密相关。事实上，一个类的所有元素应该相互之间强相关。这就引出了了类的高内聚（团结，团结，坚持，团结）的设计概念。例如，不要指望`BankAccount`对象理解消息`isPreheated`。这可能是烤箱对象的适当消息，但肯定不适用于`BankAccount`对象。这是一个关于凝聚的指南：

Object-Oriented Design Guideline
Keep related data and behavior in one place.

面向对象的设计指南
吧相关的数据和行为放在同一个位置


The BankAccount class should hide certain policies such as handling withdrawal requests greater than the balance. The system’s design improves when behavior and data combine to ac- complish the withdrawal algorithm. This makes for nice clean messages from the client code, like this:

`BankAccount`类应隐藏某些策略，例如处理大于余额的提款请求。当行为和数据相结合以完成提款的算法时，系统的设计就会得到改进。这样可以从客户端代码中获得干净的消息，如下所示：

【代码】

This client code relies on the BankAccount object to determine what should happen. The
behavior should be built into the object that has the necessary data. Perhaps the algorithm al-lows a withdrawal amount greater than the balance—with the extra cash coming as a loan or as a transfer from a savings account. Even though the BankAccount class of this textbook does very little, a real bank account class might have eight different actions that are triggered for every with- drawal—all behind the scenes.

此客户端代码依赖于BankAccount对象来确定应该发生的事情。应该将行为构建到具有必要数据的对象中。也许算法允许提取金额大于余额——额外的现金作为贷款或来自储蓄账户的转账。虽然这本教科书的`BankAccount`类做得很少，但真正的银行帐户类可能会有8种不同的操作，这些操作会在背后为所有动作触发。

6.5.2 WHY ARE ACCESSORSconstAND MODIFIERS NOT?
You may be wondering why const is added to function headings intended to access, rather than modify, the object’s state. The answer has to do with the three different parameter modes.
When an object is passed by value or by reference to a function, that function can send any and all possible messages to that object inside the other function. However, when the const refer- ence parameter mode is utilized, the function promises not to change that object. In fact, it can- not. To illustrate, consider the following function that will not compile—there is a compile time error at the attempt to withdraw from the const reference parameter ba. This is actually a good thing. The reason for using const reference parameters is to avoid accidental modification of the associated argument.

#### 6.5.2 为什么`const`只用来修饰读取函数，却不用于修饰修改函数？

您可能想知道为什么将`const`添加到旨在访问而不是修改对象状态的函数标题中。答案与三种不同的参数模式有关。

当一个对象通过值或通过引用函数传递时，该函数可以将任何和所有可能的消息发送到另一个函数内的该对象。但是，当使用const时，该函数承诺不会更改该对象。事实上，它也不能修改对象。为了说明这个问题，我们来看一下这个无法编译通过的函数——当从`const`修饰的参数`ba`中尝试提款操作时，会抛出一个编译时错误。这实际上是件好事。使用const修饰参数的原因是为了避免意外修改相关参数。

【代码】

This protection works fine for standard classes such as string. The same protection will only work with your new classes if care is taken to tag the accessors as const and leave the modifiers as non-const.
A consistent use of const accessors allows the accessing messages to be sent to the const parameters. At the same time, by not using const with modifiers, a const parameter prevents use of a message that will change the object.

这种保护适用于标准类，如字符串。如果将读取函数标记为`const`并将修改函数保留为非`const`，则相同的保护仅适用于您的新类。
`const`读取函数的一致使用允许将消息发送到`const`参数。同时，通过不使用`const`修饰修改函数，`const`参数可以防止使用将更改对象的消息。

Object-Oriented Design Guideline
Only const messages are allowed on const parameters.
  
面向对象设计指南
只有const函数才允许使用const参数。

On the other hand, it is okay to send messages that do not modify the object. This safety net is possible only when the programmer diligently tags accessing class member functions with const and always remembers not to tag a modifier that way.

另一方面，也可以发送不修改对象的消息。只有当程序员努力使用const标记访问类成员函数并始终记住不以这种方式标记修饰符时，这个整体设计才算安全。

【代码】

This leads to another design guideline:
Object-Oriented Design Guideline
Always declare accessor member functions as const.

于是我们可以引出另一个设计指南：
面向对象的设计指南
应该始终将访问器成员函数声明为const。

Perhaps the biggest problem with this guideline is in remembering the guideline. It is easily violated. You’ll never know the ramifications until an instance of your class is passed as a const reference parameter. As another example, consider the Grid class modifiers, which are non-const, and some accessors, which are declared as const functions.

也许这个指南的最大问题在于记住指南。它很容易被破坏。在将类的实例作为const引用参数传递之前，您永远不会知道这么做的后果。下面让我们来看另一个例子，考虑`Grid`类的修改函数（非const）和一些访问函数（声明为const函数）。

【代码】

The presence of const tells the compiler to allow the message to be sent even for objects passed by const reference (g here):

const的存在告诉编译器，可以允许发送消息，即使对象是通过`const`引用传递的（在这里就是`g`）：

【代码】

On the other hand, the attempt to send non-const messages such as Grid::move results in a
compile time error like these (more cryptic error messages exist) depending on the compiler used:

另一方面，取决于使用的编译器，尝试发送非常量消息（`如Grid::move`）会导致像这些编译时错误（存在更多神秘的错误消息）：

【代码】

Declaring accessors as const functions allows existing objects to be safely passed to a const parameter. However, it takes diligence to maintain the same safety net for the new classes that you write. Remember these two class design guidelines:

1. Modifiers should not be declared const so the compiler can catch attempts to modify const objects.

2. Accessors should be declared const so objects can be safely passed to const param- eters and still allow non-modifying messages.

将访问函数声明为`const`函数允许将现有对象安全地传递给const参数。但是，为您编写的新类维护相同的安全网需要尽职尽责。请记住这两个类设计指南：

1. 修改函数不应该声明为`const`，因此编译器可以捕获修改`const`对象的尝试。

2. 访问函数应该被声明为`const`，因此对象可以安全地传递给`const`参数，并且仍然允许非修改消息。

It would be easier to completely ignore these rules, but the only way to get away with it would be to never pass objects to const parameters. This textbook uses const in a member func- tion because it says something about whether or not a function modifies the state of an object. And this is something object-oriented programmers must know about. The designer of the class must still decide if the message will modify an instance of the class or not.

完全忽略这些规则会更容易，但逃避它的唯一方法就是永远不要将对象传递给`const`参数。 这本教科书在成员函数中使用`const`，因为它说明了函数是否修改了对象的状态。这是面向对象程序员必须了解的东西。该类的设计者仍然必须决定该消息是否会修改该类的实例。

SELF-CHECK
6-20 Using the class definition of the BankAccount class, list the lines that cause errors in a stand-
ard C++ compiler (1, 2, 3, and/or 4).

### 自我检查

6-20 使用`BankAccount`类的类定义，列出导致错误的行。这里使用标准C++编译器。

【代码】

## CHAPTER SUMMARY

This chapter showed class definitions with a collection of function headings that represent the class interface. These are the message names that any object of the class will understand.
yA class definition lists:
ythe class member functions with parameters and return types, collectively known as
the interface
ythe data members, known collectively as the state
yEach object of a class may store many values, which may be of different classes. For example, each BankAccount object stores string data for the name and numeric data for the balance. yThe state object pattern guides class design when the primary need for the object is to store
state and provide adequate access to it. The state object pattern in C++ recommends that the following items be included in a class definition:
ya constructor to initialize objects with programmer-supplied state ymodifying functions
yaccessor functions
yprivate data members to store the state of every object

+ 本章展示了类的定义，其中包含表示类接口的函数标题集合。这些是类的任何对象都能理解的消息名称。
+ 类定义的列表：
	+ 具有参数和返回类型的类的成员函数，统称为接口
	+ 数据成员，统称为状态
+ 类的每个对象可以存储许多值，这些值可以是不同的类。例如，每个`BankAccount`对象都存储string类型的变量`name`、数字类型的变量`balance`。
+ 当对象的主要功能为存储及读取数据时，state-object模式就可以用来指导类的设计。C++中的state-object模式建议在类定义中包含以下项：
+ 构造函数，通过编程人员提供的状态初始化对象
+ 修改函数
+ 访问函数
+ 私有数据成员，用于存储每个对象的状态

Modifying class member functions changes the state of the object.
yAccessor functions provide access to the state of an object.
y Accessors have the keyword const attached at the end of the function heading. yRamifications of adhering to Object-Oriented Design Guideline “All data should be hidden
within its class” include:
yGood: can’t mess up the state (compiler complains)
yBad: need to implement additional accessors (getBalance, for example)
yThe ramifications of adhering to Design Guideline “Keep related data and behavior in one place” include:
yGood: results in a more intuitive design
yGood: easier to maintain
yThe ramifications of adhering to Design Guideline “Always declare accessor member func-
tions as const” include:
yGood: helps the user distinguish between modifiers and accessors
yGood: adheres to the principle that objects passed as const reference parameters
cannot be accidentally modified by the function while allowing the function to send const messages
Bad: it is easy to forget to use const and the error will not show up until the object is passed in the three different modes—the result is more extensive testing to ensure the safety of const and the efficiency of const reference parameters

+ 修改性地类的成员函数会更改对象的状态。
+ 访问函数提供了对对象状态的访问。
+ 访问函数在函数标题的末尾附加了关键字const。
+ 面向对象设计指南的原则“应将所有数据隐藏在类中“，包括：
	+ Good：不要混淆状态（编译会出错）
	+ Bad：需要实现额外的访问函数（例如`getBalance`）
+ 设计指南“将相关数据和行为保存在一个地方”,包括：
	+ Good：产生更直观的设计
	+ Good：更容易维护
+ 设计指南“始终声明访问函数为const“,包括：
	+ Good：帮助用户区分修改函数和访问函数
	+ Good：坚持对象作为const引用参数传递的原则：在允许函数发送const消息时，函数不会意外地修改。
	+ Bad: 很容易忘记使用`const`，并且在对象以三种不同模式传递之前不会显示错误 ——结果需要更广泛的测试以确保const的安全性和const参考参数的效率。
		
Class member functions are implemented in a manner similar to nonmember functions. However, class member functions must be qualified with the class name and :: (the scope resolution operator). This gives the function access to the private data members.
y Class definitions have historically been stored in .h files.
y Member function implementations have historically been stored in .cpp files. yA class should be designed to exhibit high cohesion:
ythe data should be related to the operations ythe messages should be related to each other

+ 类的成员函数以类似于非成员函数的方式实现。但是，类成员函数必须使用类名和::（范围解析运算符）进行限定。这使函数可以访问私有数据成员。
+ 类定义历来存储在.h文件中。
+ 成员函数实现历来存储在.cpp文件中。
+ 类应设计为高度聚合：
	+ 数据应与操作相关
	+ 消息应相互关联

EXERCISES
1. Does the interface of a class refer to its member functions or its data members?
2. Does the client code need to know the names of data members to use objects of the class?
3. Describe the scope of the public members of a class.
4. Describe the scope of the private members of a class.
5. Give one justification for making the data members of a class private.
6. If the designer of BankAccount class changed the name balance to my_Balance, would pro- grams using BankAccount need to be changed?
7. If a designer changed the name of the withdraw message to withdrawThisAmount after the class was already in use by dozens of programs, would these dozens of programs need to be changed?
8. What is responsible for deciding if a particular LibraryBook is available for lending, the LibraryBook or the program using LibraryBook?
9. Should a BankAccount object understand the message isThisBrakeLockingUp?
10. If an object is passed by value, which messages can be sent: modifiers, accessors, or both?
11. If an object is passed by reference (with &), which set of messages can be sent: modifiers, ac- cessors, or both?
12. If an object is passed by const reference as in (const Grid & aGrid), which set of messages can be sent: modifiers, accessors, or both?
13. Given this definition for a class Counter class, predict the output from the test driver be- low:

### 练习

1. 类的接口是指其成员函数还是其数据成员？

2. 客户端代码是否需要知道使用该类对象的数据成员的名称？

3. 描述一个类的公共成员的作用域。

4. 描述一个类私有成员的作用域。

5. 给出使一个类的数据成员私有的一个理由。

6. 如果`BankAccount`类的设计者将名称`balance`更改为`my_Balance`，那么是否需要更改使用`BankAccount`的程序？

7. 如果设计师在几十个程序中已经使用该类之后将撤消消息的名称更改为`withdrawThisAmount`，那么这几十个程序是否需要更改？

8. 负责决定特定`LibraryBook`是否可调用`withdraw`的是谁？是`LibraryBook`类还是使用`LibraryBook`的程序？

9. BankAccount对象是否应该理解消息`isThisBrakeLockingUp`？

10. 如果按值传递对象，可以发送哪些消息：修改消息，访问消息或两者？

11. 如果通过引用传递对象（使用＆），可以发送哪组消息：修改消息，访问消息或两者？

12. 如果一个对象通过const引用传递，如（const Grid＆aGrid），可以发送哪组消息：修改消息，访问者或两者？

13. 给定类`Counter`类的这个定义，预测如下测试驱动程序的输出：

【代码】

14. Write all code that would go into Counter.cpp that completely implements all member func-
tions defined in Counter.h so that the program above generates the correct output.

14. 写出将进入`Counter.cpp`文件的所有代码，完全实现`Counter.h`中定义的所有成员函数，以便上面的程序生成正确的输出。

### PROGRAMMING TIPS

1. Working with three files is more difficult than working with one, but some programming projects will now require that you work with three files, not just one. This takes a little pa- tience as you grow accustomed to working with multiple files. Remember, the .h file contains the class definition; the .cpp file contains the member function implementations. The third file has the main function.

2. There is a variety of ways to make classes available. Even though the convention of having one file include the .h and .cpp files is atypical, it makes things easier and matches the stand- ard (many #include files do not have .h anymore). However, someday you may be asked to create object files or project files to compile and link programs using author-supplied classes. Then your program may just include the .h file so it can compile. Linking comes later.
	
### 编程提示

1. 使用三个文件比使用一个文件更难，但是现在的一些编程项目要求您使用三个文件，而不仅仅是一个。随着您习惯于使用多个文件，这需要一点点的经验。请记住，`.h`文件包含类定义; `.cpp`文件包含成员函数实现。第三个文件具有主要功能。

2. 有多种方法可以提供类。我们也经常遇到使用一个文件包含`.h`和`.cpp`的内容，有时，它也会使代码更容易，并且与标准相匹配（许多#include文件不再具有.h）。但是，有一天可能会要求您创建对象文件或项目文件，以使用作者提供的类编译和链接程序。name你的程序可以只包含.h文件，以便它可以编译。链接器在这之后才开始工作。

【代码】

The nonmember function syntax applies to member function headings also. The function heading in the implementation must match the function heading in the class definition in terms of
yreturn type (none for constructors) yfunction name
ynumber of parameters
ytype of parameters
yorder of parameters
y use of const in both places (or neither)

3. 非成员函数语法也适用于成员函数标题。 实现中的函数标题必须与类定义中的函数标题相匹配，具体而言需匹配：

+ 返回类型类型（没有构造函数）
+ 函数名称
+ 参数的数量
+ 参数的类型
+ 参数的顺序
+ 在两个地方使用const（或两者都不使用）

4. Don’t write using namespace std; in header files. Once you use a namespace you can’t un- use it. While it may not cause any problems in the programs in this textbook, you should get in the habit now to avoid future programming problems.
5. Function headings in the implementation file (.h) differ from the function headings in the implementation file (.cpp).

4. 不要在头文件中打`using namespace std;`。使用命名空间后，您无法取消使用它。虽然它可能不会导致本教材中的程序出现任何问题，但您现在应养成习惯以避免将来的编程问题。

5. 头文件（.h）中的函数标题与实现文件（.cpp）中的函数标题不同。

  + 函数名前需要加`类名::`
  + 函数体`{}` 需要用分号代替

【代码】

PROGRAMMING PROJECTS

6A ADD int getTransactionCountTOBankAccount
Allow BankAccount objects to keep track of and report the number of transactions, deposits, and withdrawals made since the initialization of any BankAccount object. Name this new function int getTransactionCount(). Use this test driver and ensure your output matches and compiles:

### 编程项目

#### 6A 为`BankAccount`类增加 int getTransactionCount成员

该成员允许`BankAccount`对象跟踪并报告自初始化任何`BankAccount`对象以来所做的事务，存款和取款的数量。将此新函数命名为`getTransactionCount()`。使用此测试驱动程序并确保输出匹配并编译：

【代码】

#### 6B 为`Grid`对象增加turnAroundANDturnRight方法

将以下操作添加到名为`Grid.h`的文件中`Grid`类的定义中：

【代码】

Also add both class member functions at the top of the file named Grid.cpp. Please try to ignore all the other stuff in that rather large file. You will find it easier to use the existing member function turnLeft to implement these two new functions.

然后在名为`Grid.cpp`的文件顶部添加两个类成员函数。请尝试忽略那个相当大的文件中的所有其他内容。您会发现使用现有的成员函数`turnLeft`更容易实现这两个新功能。

【代码】

6C CLASS AVERAGER
Given the following definition of class Averager in the file Averager.h, implement all mem- ber functions in a new file Averager.cpp. You should be able to add any number of test or quiz scores and find the average and number of scores added at any time.

#### 6C AVERAGER类 

给定文件`Averager.h`中以下类`Averager`的定义，在新文件`Averager.cpp`中实现所有成员函数。您应该能够添加任意数量的测试或测验分数，并查找平均分数和任意时间增加的分数的数量。

【代码】

#### 6D class PiggyBank

A PiggyBank object encapsulates the contents of a piggy bank with messages associated with real world actions. It knows how many of each coin—pennies, nickels, dimes, and quarters—are in it along with total cash value. A PiggyBank object can also be emptied with a drainTheBank mes- sage, which also returns the amount of money at that moment. Here is the class definition:

#### 6D `PiggyBank`类

`PiggyBank`对象使用与现实世界动作相关联的消息来封装存钱罐的内容。它认识每一种硬币，以及它们的总现金价值。`PiggyBank`对象也可以使用`drainTheBank`消息清空，该消息也返回当时的金额。这是类定义：

【代码】

6E class Employee
Note: This type asks for a new member function in Chapter 7: Selection
While programmers at Chrystal Bends, Inc., were designing the payroll system, they realized they needed an Employee type. An Employee object is responsible for maintaining the information necessary to complete an employee’s paycheck for employees who get paid on an hourly basis. This Employee object is responsible for computing its own gross and net pay and computing how much to withhold for Social Security tax (6.2% of the gross pay) and Medicare tax (1.45% of the gross pay) for the week. The Chrystal Bends, Inc. programming team has designed this C++ class definition, which you are asked to use to implement and test the member functions.

#### 6E `Employee`对象

注意：此类型在`第7章：选择`中要求新的成员函数

`Chrystal Bends公司`的程序员正在设计薪资系统。们意识到他们需要一种`Employee`类型。`Employee`对象负责维护为每小时获得报酬的员工完成员工薪水所需的信息。该`Employee`对象负责计算自己的总薪资和净工资，并计算本周扣缴社会保障税（总薪酬的6.2％）和医疗保险税（总薪酬的1.45％）的金额。`Chrystal Bends公司`的编程团队设计了这个C++类定义，要求您使用它来实现和测试成员函数。

【代码】

The following test driver sends all possible messages to one Employee. The hours worked per week must be set with a setHoursWorked message in order for the gross pay taxes and net pay to be computed. This test driver should generate the expected output below:

以下测试驱动程序将所有可能的消息发送给一个`Employee`实例。必须使用`setHoursWorked`消息设置每周工作小时数，以便计算总工资税和净工资。此测试驱动程序应生成以下预期输出：

【代码】