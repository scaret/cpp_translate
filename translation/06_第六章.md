**C H A P T E R S I X**

Class Defi nitions and Member Functions

SUMMING UP

> Functions hide details, can be called many times, can be reused in
> other programs, and help in the design of larger programs. Each
> function performs a well-defi ned service.

COMING UP

> When a function belongs to a class, it becomes a class member
> function. Class member functions have a lot in common with their
> nonmember cousins. Chapter 6 presents an introduction to C++ class
> defi nition and member function implementations. You will learn to
> read and understand classes by their *defi nitions*—the collection of
> member function headings (the interface) and data members (the state).
> In the second part of this chapter, you will learn to implement class
> member functions. You will also see a few appropriate object-oriented
> design guidelines that help explain why classes are designed the way
> they are. After studying this chapter, you will be able to

-   read and understand class defi nitions (interface and state)

-   implement class member functions using existing class defi nitions

-   apply some object-oriented design guidelines

6.1 DEFINING A CLASS IN A HEADER FILE

> Abstraction refers to the practice of using and understanding
> something without full knowledge of its implementation. Abstraction
> allows the programmer using a class to concentrate on the data
> characteristics and the messages that manipulate the state. For
> example, a programmer using the string class need not know the details
> of the internal data representation or how those operations are
> implemented in the hardware and software. Th e programmer can
> concentrate on the set of allowable messages—*the interface*.
>
> Th is chapter presents some implementation issues that so far have
> been hidden. In the fi rst part of this chapter, the BankAccount class
> will be studied at the implementation-detail level. However, before
> examining the physical side of class design, let’s consider some of
> the design decisions that were made for this textbook’s BankAccount
> class.
>
> 141
>
> All BankAccount objects have four allowable operations: deposit,
> withdraw, getBalance, and getName. Th ere could have been more, or
> there could have been fewer. Th e member functions for BankAccount
> were chosen to keep the class simple and to provide a collection of
> operations that are relatively easy to relate to. A compromise was
> made. Th e design decisions were infl uenced by the context—a fi rst
> example of a C++ class used in a particular domain, the area of
> banking. Th e BankAccount member functions that make up the interface
> are only a subset of the operations named by students who were asked
> this question: what should we be able to do with bank accounts? Th e
> data members are also a subset of the operations named by students who
> were asked this question: what should bank accounts know about
> themselves?
>
> Many additional operations that were recognized by students (transfer,
> applyInterest, printMonthlyStatement) and many additional data members
> (type of account, record of transactions, address, Social Security
> number, and mother’s maiden name) were not included. Th e design of
> these classes was aff ected by the intention of keeping these objects
> as simple as possible while retaining some realism. However, a group
> of object-oriented designers developing large-scale applications in
> the banking domain would likely retain many of the operations and
> attributes recognized by students. Th ere is rarely one single design
> that is correct for all circumstances.
>
> Designing anything requires making decisions in an eff ort to make the
> thing “good.” Good might mean having a software component that is
> easily maintainable; it might mean classes that can be reused in other
> applications; or it might mean a system that is very robust—one that
> can recover from almost any disastrous event. Good might mean a design
> that results in something that is easier to use, prettier, etc. Th ere
> is rarely ever a single perfect design. Th ere are usually trade-off
> s. Design is an iterative process that evolves with time.
>
> Design is infl uenced by personal opinion, evolving research, and the
> domain, which could be banking, information systems, process control,
> engineering, and so on. Fortunately, there are design guidelines to
> show the way, a few of which are presented later. Let’s now turn to
> the construct that captures many of these design decisions in
> object-oriented software development—the *class defi nition*.
>
> Th e classes of objects under study—ostream, istream, string,
> BankAccount, and Grid—are building blocks of larger programs. However,
> programs typically require many other classes. Th ey may be standard
> classes, classes that are bought off the shelf, or other classes that
> must be designed and implemented by a programming team.
>
> Because it is diffi cult to have mastery of all classes in a large
> project, this section provides some general techniques for
> understanding unfamiliar classes. Th e knowledge attained here also
> provides experience with the major component of object-oriented
> software development—the class.

6.1: Defi ning a Class in a Header File

> Th is process begins with learning to read class defi nitions. You
> will also implement member functions and add new operations to
> existing classes. Th is approach has the added benefi t of making it
> easier to design and implement new classes of your own.
>
> A class defi nition lists member functions after the keyword public:.
> Th is set of operations represents the class interface. Th e class
> defi nition also lists the *data members*—the object declarations
> after private:. Th is set of data members represents the state of the
> objects.
>
> A class defi nition provides a lot of information. A class defi nition
> stresses the *what*, not the *how*. It lists the messages understood
> by the objects. It specifi es the number, type, and order of arguments
> required when sending a message to one of the objects. When documented
> with preconditions, postconditions, and example messages, a class defi
> nition also explains how to use instances of the class. Th e
> documentation may provide other pertinent information. All of these
> things allow the programmer to use objects of the class without
> knowing the details of the implementation.
>
> General Form 6.1 *Class defi nition*
>
> class *class-name* {
>
> public: // MEMBER FUNCTIONS (the interface)
>
> //--constructor
>
> *class-name*(*parameter-list*) ;
>
> //--modi ers
>
> *function-heading*; // Member functions that *function-heading*; //
> modi es the state
>
> //--accessors
>
> *function-heading* const; // Member function that access
> *function-heading* const; // but can't change state . . .
>
> private: // DATA MEMBERS (the state) *object-declaration* // Data
> member *object-declaration* // Data member . . .
>
> }; // Class de nitions must end with a semicolon

6.1.1 DEFINING class BankAccount

> Now let’s get down to a concrete, familiar example. Recall that the
> data members in the private section represent the state. Every
> BankAccount object stores its own private name and balance data. Th e
> public section has the member functions representing the messages each
> BankAccount understands: withdraw, deposit, getBalance, and getName.
> Th ese are combined in the header fi le BankAccount.h as a class defi
> nition.
>
> Class Defi nition: *BankAccount*

File BankAccount.h

> \#include &lt;string&gt;
>
> // Do not place using statements in header les. Use std::
>
> class BankAccount { public: BankAccount(std::string initName, double
> initBalance); // post: Construct with two arguments, example:
>
> // BankAccount anAcct("Hall", 100.00);
>
> void deposit(double depositAmount); // post: Credit depositAmount to
> the balance
>
> void withdraw(double withdrawalAmount); // post: Debit
> withdrawalAmount from the balance
>
> double getBalance() const; // post: Return this account's current
> balance
>
> std::string getName() const; // post: Return this account's name
>
> private:
>
> std::string name; double balance; }; // Don't forget the semicolon
>
> Most BankAccount member function headings in this BankAccount class
> defi nition are similar to the nonmember function headings—they
> usually have return types and parameters. However, one of the member
> function headings above does not fall into this category. Can you spot
> something diff erent about the function heading with the name
> BankAccount?
>
> First of all, the BankAccount::BankAccount member function has no
> return type. It also has the same name as the class! Th ese special
> member functions are referred to as *constructors* because they are
> used to “build” objects. Specifi cally, constructors associate the
> object name with a portion of memory and initialize the data members
> of the object as in a BankAccount object construction. For example,
> this code constructs a BankAccount object with an initial name of "Pat
> Barker" and an initial balance of 507.34, which can be referenced with
> the variable named anAccount.
>
> BankAccount anAccount("Pat Barker", 507.34); When another object is
> constructed like this:
>
> BankAccount another("Skyler Boatwright", 437.05);

6.1: Defi ning a Class in a Header File

> there exists a separate BankAccount object with its own balance of
> 437.05 and its own name of "Skyler Boatwright". So the return values
> of these two messages would be 507.34 followed by 437.05.
>
> cout &lt;&lt; anAccount.balance() &lt;&lt; endl; // 507.34 cout
> &lt;&lt; another.balance() &lt;&lt; endl; // 437.05

SELF-CHECK

> Use this class defi nition to answer the self-check questions that
> follow:
>
> /\*

-   Class de nition for LibraryBook

-   le: LibraryBook.h

> \*/
>
> \#include&lt;string&gt;
>
> class LibraryBook { public:
>
> //--constructor
>
> LibraryBook(std::string initTitle, std::string initAuthor);
>
> // post: Initialize a LibraryBook object
>
> //--modi ers void borrowBook(std::string borrowersName);
>
> // post: Records the borrower's name // and makes this book not
> available
>
> void returnBook(); // post: The book becomes available
>
> //--accessors
>
> bool isAvailable() const; // post: returns true if this book is not
> borrowed
>
> std::string getBorrower() const; // post: Return borrower's name if
> this book is not available
>
> std::string getBookInfo() const; // post: Returns this book's title
> and author
>
> private:
>
> std::string author; std::string title; std::string borrower; bool
> available; };

6-1 What is the name of the class defi ned above?

6-2 Name all the member functions that modify the state of the objects.

> 6-3 Name all the member functions that access the state of the objects
> and cannot change that state.

6-4 Name all data members.

> 6-5 What type of value is returned by LibraryBook::getBorrower? 6-6
> What type of value is returned by LibraryBook::isAvailable?

6-7 Initialize one LibraryBook object using your favorite book and
author.

6-8 Send the message that borrows your favorite book. Use your own name
as the argument.

6-9 Write the message that returns the borrower’s name of the book.

6.2 IMPLEMENTING CLASS MEMBER FUNCTIONS

> Class member function implementations are similar to those of their
> nonmember relatives—with these diff erences:

1.  Class member functions implemented outside of the class defi nition
    > must be qualifi ed with the class name and the scope resolution
    > operator ::. Th is tells the compiler they are member functions of
    > a particular class and as such, they are allowed to directly
    > reference the private data members.

2.  Th e constructors are class member functions with the same name as
    > the class and they do not have a return type. Th e return type is
    > not needed because constructors return a new object of the type
    > specifi ed in the constructor and class name.

> Th e relatively familiar BankAccount class will be used to demonstrate
> member function implementations. For each .h fi le there will be a
> .cpp fi le that \#includes the .h (header) fi le with the class defi
> nition. Th is .cpp fi le implements the member functions.

6.2.1 IMPLEMENTING CONSTRUCTORS

> A constructor is a special member function that always has the same
> name as the class. It never has a return type. Although member
> functions can be defi ned within a class defi nition, this textbook
> uses the software engineering principle of separating interface from
> implementation by implementing the member functions in a separate fi
> le. In this case, the member functions must begin with class-name ::.

Th e following code implements the two-parameter constructor:

> // File name: BankAccount.cpp
>
> \#include "BankAccount.h" // Allows for separate compilation
>
> BankAccount::BankAccount(string initName, double initBalance) { name =
> initName;

6.2: Implementing Class Member Functions

> balance = initBalance; } // . . . more member functions need to be
> implemented . . .
>
> Th is is the function that executes whenever a BankAccount is
> initialized with two arguments: a string followed by a number.
>
> In the following code, the account name "Corker" is passed to the
> parameter initName, which in turn is assigned to the private data
> member name. Th e starting balance of 250.55 is also passed to the
> parameter named initBalance, which in turn is assigned to the private
> data member balance. After an object is constructed, the state of the
> object is initialized.
>
> // Call the two-parameter constructor
>
> BankAccount anInitializedAccount("Corker", 250.55);
>
> // Output: cout &lt;&lt; anInitializedAccount.getName() &lt;&lt; endl;
> // Corker cout &lt;&lt; anInitializedAccount.getBalance() &lt;&lt;
> endl; // 250.55
>
> Th ere is a major diff erence between implementing class member
> functions and their nonmember cousins. Class member function
> implementations must be preceded with the class name and the ::
> operator. For example, the BankAccount constructor is preceded with
> BankAccount:: to inform the compiler that it is a member function and
> as such, has access to the object’s private data members. Failure to
> add BankAccount:: results in a nonmember function that cannot
> reference the data members. For example, the compiler will generate
> error messages at any attempt to access private data members (name and
> balance). BankAccount:: is missing.
>
> BankAccount(string initName, double initBalance) { // &lt;-- WHOOPS
> name = initName; // ERROR: name is not known balance = initBalance; //
> ERROR: balance is not known }
>
> Scope Rule for C++ Classes

Th e scope of private members is limited to the class member functions.

> So remember to precede a class member function implementation with the
> class to which it belongs and the special symbol ::. Th is defi nes
> the function as a class member function that can access the private
> data members. A member function can do whatever it has to do with the
> state.

6.2.2 IMPLEMENTING MODIFYING MEMBER FUNCTIONS

> A member function may either modify the state or access the state of
> an instance of the class. For example, consider BankAccount::deposit,
> which modifi es the private data member balance.
>
> void BankAccount::deposit(double depositAmount) { balance = balance +
> depositAmount;
>
> }
>
> When the following deposit message is sent, the argument 157.42 is
> copied by value to the parameter depositAmount, which is then added to
> this object’s balance:
>
> anAcct.deposit(157.42);
>
> Notice that the function headings match the class defi nition. Specifi
> cally, the return type of BankAccount::deposit is void and there is
> one double argument.
>
> // function headings in BankAccount.h//--modi ers void deposit(double
> depositAmount); void withdraw(double withdrawalAmount); // . . .
>
> Th e BankAccount::withdraw function is another modifying member
> function that changes the state of a BankAccount object. Specifi
> cally, a withdraw message deducts withdrawalAmount from balance:
>
> void BankAccount::withdraw(double withdrawalAmount) { balance =
> balance - withdrawalAmount; }
>
> When the following withdraw message is sent, the argument 50.00 is
> copied by value to the parameter withdrawalAmount, which is then
> subtracted from balance:
>
> anAcct.withdraw(50.00);
>
> As you are implementing class member functions, make sure all function
> headings match the appropriate function heading in the class defi
> nition. Your member function implementations, stored in a diff erent
> fi le, must have the same exact return type, function name, number,
> type, and order of parameters as exist in the class defi nition. A
> good idea is to copy all the member functions to your implementation
> fi le. Th at will ensure you keep member function headings the same
> and you won’t miss implementing a member function. Th en replace the
> semicolon at the end of each member function heading with a function
> body and add the class name:: to the start of each member function
> name.
>
> It should be noted here that there could be much more processing
> within the body of a class member function. Th e member function
> implementations in this chapter have been kept intentionally simple
> during this introduction to member function implementations.

6.2.3 IMPLEMENTING ACCESSING MEMBER FUNCTIONS

> It is good design to make the data members private and have functions
> that allow access to that state. Some of these accessing functions
> simply return the value of a data member.
>
> string BankAccount::getName() const { return name; }
>
> double BankAccount::getBalance() const { return balance;
>
> }

6.2: Implementing Class Member Functions

> Because these accessing functions in the class defi nition have the
> keyword const, the implementation of the member function must also
> include const after the function heading and before the block start at
> {. Th e keyword const denotes a member function that does not modify
> state. If you examine the accessor implementations above, you’ll
> notice no data members get changed in the block. getName and
> getBalance simply return the values of those data members. If you pass
> an object by const & reference, these const methods can be used in
> that other function. On the other hand, the modifying functions
> withdraw and deposit change the state of the object, balance specifi
> cally. If you pass an object by const & reference, an attempt to use
> these modifying (non const) methods will be the source of a compile
> time error. Th e const function can be used when passed by const
> reference.
>
> Remember to make sure all member function headings exactly match the
> headings in the class defi nitions (without ;). And remember to type
> the class name and :: before the class member function name in the
> .cpp fi les. To summarize, here is the complete implementation of all
> of BankAccount member functions in the fi le BankAccount.cpp.
>
> Member Function Implementation: *BankAccount*

File BankAccount.cpp

> /\*

-   Implement the member functions de ned in BankAccount.h

> \*

-   File name: BankAccount.cpp

> \*/
>
> \#include "BankAccount.h" using namespace std;
>
> //--constructor
>
> BankAccount::BankAccount(string initName, double initBalance) { name =
> initName; balance = initBalance; }
>
> //--modi ers void BankAccount::deposit(double depositAmount) { balance
> = balance + depositAmount; }
>
> void BankAccount::withdraw(double withdrawalAmount) { balance =
> balance - withdrawalAmount; }
>
> //--accessors
>
> double BankAccount::getBalance() const { return balance; } string
> BankAccount::getName() const { return name; }

SELF-CHECK

> 6-10 How does a function implementation become a member of a class?
>
> 6-11 Can class member functions reference the private data members?
>
> 6-12 Can nonmember functions reference private data members?
>
> 6-13 Use this implementation of the LibraryBook member functions to
> write the output generated by the program below:
>
> /\*

-   Implement the member functions de ned in LibraryBook.h

> \*

-   File name: LibraryBook.cpp

> \*/
>
> \#include &lt;string&gt; using namespace std; \#include
> "LibraryBook.h" const std::string AVAILABLE\_MESSAGE = "CAN BORROW";
>
> //--two argument constructor
>
> LibraryBook::LibraryBook(std::string bookTitle, std::string
> bookAuthor) { title = bookTitle; author = bookAuthor; available =
> true;
>
> borrower = AVAILABLE\_MESSAGE; }
>
> // -- modi ers -void LibraryBook::borrowBook(std::string
> borrowersName) { borrower = borrowersName; available = false; }
>
> void LibraryBook::returnBook() { borrower = AVAILABLE\_MESSAGE;
> available = true; }
>
> //--accessors
>
> bool LibraryBook::isAvailable() const { return available; }
>
> std::string LibraryBook::getBorrower() const { return borrower;
>
> }

6.3: Default Constructors

> std::string LibraryBook::getBookInfo() const { return "'" + title + "'
> by " + author; }
>
> Here is the program that uses this new type LibraryBook now
> implemented as a C++ class.
>
> // Send every possible message to a LibraryBook object
>
> \#include &lt;iostream&gt; using namespace std;
>
> \#include "LibraryBook.h" // For class LibraryBook de nition
>
> int main() {
>
> LibraryBook aBook("Tinker Tailor Soldier Spy", "John le Carre"); cout
> &lt;&lt; aBook.getBookInfo() &lt;&lt; endl; cout &lt;&lt;
> aBook.getBorrower() &lt;&lt; endl;
>
> cout &lt;&lt; aBook.isAvailable() &lt;&lt; endl; // 1 if true, 0 if
> false aBook.borrowBook("Charlie Archer"); cout &lt;&lt;
> aBook.getBorrower() &lt;&lt; endl; cout &lt;&lt; aBook.isAvailable()
> &lt;&lt; endl; aBook.returnBook();
>
> cout &lt;&lt; aBook.isAvailable() &lt;&lt; endl; cout &lt;&lt;
> aBook.getBorrower() &lt;&lt; endl; return 0; }
>
> Output
>
> 'Tinker Tailor Soldier Spy' by John le Carre
>
> CAN BORROW
>
> 1
>
> Charlie Archer
>
> 0
>
> 1
>
> CAN BORROW

6.3 DEFAULT CONSTRUCTORS

> Every class requires at least one constructor. A class can have more
> than one, as long as they have a diff erent number, type and/or order
> of parameters. Consider this simple class Adder that has two
> constructors. Th e constructor with no parameters is known as the
> default constructor. Th e programmer can specify whatever default
> state seems appropriate in the default constructor, which in this case
> sets the data member sum to 0.0.
>
> // File: Adder.h
>
> \#include &lt;string&gt; class Adder { public:
>
> // Default constructors have no parameters.
>
> // Construct an Adder with sum staring at 0.0
>
> Adder();
>
> // Construct an Adder with sum starting at start
>
> Adder(double start);
>
> void add(double number); // post: add number to sum
>
> double getSum() const; // post: Return the sum of all added numbers
>
> private:
>
> double sum; // total of all scores added };
>
> Because class Adder has two constructors, Adder objects can be
> constructed two diff erent ways.
>
> Adder adder1(123.45); // Call one argument constructor
>
> Adder adder2; // New: Call the default constructor, no ()

Th e object referenced by adder1 gets built using the one argument
constructor

> Adder::Adder(double start). Th e object referenced by adder2 gets
> built using the default constructor Adder::Adder(), which initializes
> sum to 0.0 as shown in the class implementation fi le Adder.cpp.
>
> \#include "Adder.h" using namespace std;
>
> Adder::Adder() { sum = 0.0; }
>
> Adder::Adder(double start) { sum = start; }
>
> void Adder::add(double number) { sum = sum + number; }
>
> double Adder::getSum() const { return sum; }

Th e following program uses both constructors to show the diff erence.

> \#include &lt;iostream&gt; using namespace std; \#include "Adder.h"
>
> int main() {
>
> Adder adder1(123.45);
>
> cout &lt;&lt; " Initial sum: " &lt;&lt; adder1.getSum() &lt;&lt; endl;

6.3: Default Constructors

> Adder adder2;
>
> cout &lt;&lt; " Default sum: " &lt;&lt; adder2.getSum() &lt;&lt; endl;
>
> adder2.add(1.1); adder2.add(2.2); adder2.add(3.3);
>
> cout &lt;&lt; "After 3 adds: " &lt;&lt; adder2.getSum() &lt;&lt; endl;
>
> return 0; }
>
> Output
>
> Initial sum: 123.45
>
> Default sum: 0
>
> After 3 adds: 6.6
>
> Here are the reasons to have a default constructor in addition to
> other constructors:

-   Th ey are required to have collections of objects (see Chapter
    > 10, “Vectors”).

-   Th ey guarantee initialization to a specifi c state. Programmers
    > always know what to expect (more vivid examples are yet to come).

-   Th ey defi ne the default values used when another default
    > constructor is called. For example, the default state for string
    > is the empty string "".

6.3.1 FUNCTION OVERLOADING

> You may be wondering how there could be two constructors since they
> have the same name. Th rough a technique known as *function
> overloading*, more than one function with the same name is allowed to
> exist. However, there has to be something that distinguishes two
> functions with the same name. One of these distinguishing
> characteristics is having a diff erent number of parameters. Function
> overloading allows the programmer to have a default constructor with
> zero parameters in the same scope as a constructor with one or more
> parameters. In other words, C++ distinguishes between the two
> constructor function headings inside the class defi nition. Function
> overloading also occurs when the type of parameters diff ers, even if
> there are the same number of parameters. Th ese three functions may
> exist in the same scope because the types of the one parameter are
> diff erent.
>
> void aFunction(int n); void aFunction(long n); void aFunction(string
> str);
>
> Th ese functions may exist in the same scope because the order of
> parameters is diff erent.
>
> void aFunction(int n, string s); void aFunction(string s, int n);
>
> However, functions that diff er only in their return type cannot be
> overloaded.
>
> void aFunction(int n); string aFunction(int n); // &lt;- Error

6.4 THE STATE OBJECT PATTERN

> Even though quite diff erent in specifi c operations and state,
> string, BankAccount, and LibraryBook objects have the following common
> characteristics:

-   private data members store the state of the object

-   constructors initialize the state

-   some messages modify the state

-   other messages allow access to the current state of the object

> Th ese commonalities guide the eff ective use of these and similar
> classes of objects. Th ese patterns also help programmers understand
> how to use new objects. Th e constructors, modifi ers, and accessors
> in the public: section of a class defi nition are the operations
> available to all instances of the class.

6.4.1 CONSTRUCTORS

> Constructors are present for many reasons, including initializing the
> state of any instance of the class. As shown earlier, objects are
> initialized like this:
>
> string aString("initial string"); // State is "initial string"
> BankAccount anAcct("Xi Grey", 215); // name and balance are set
>
> LibraryBook aBook("Tale of Two Cities", "Charles Dickens");
>
> // Title and author are set and this book is available to borrow

6.4.2 MODIFIERS

> Modifying methods change the state of an object. Modifi ers are part
> of the State Object pattern for a variety of reasons. Perhaps it’s
> best to simply show some example messages that modify the state of an
> object:
>
> aString.replace(1, 3, "NEW"); // assert: s2 is "iNEWial string"
>
> g.move(5);
>
> // assert: The mover is ve spaces forward
>
> anAcct.withdraw(50.00); // assert: The balance of anAcct is 50.00 less
>
> aBook.borrowBook("Fred Featherstone");
>
> // assert: aBook's borrower has become Fred Featherstone

6.4: The State Object Pattern

> Sending a modifi er message results in a change of state. Modifi ers
> are not declared with const after the function heading—accessors are.

6.4.3 ACCESSORS

> Accessors are part of the state object pattern simply because
> programmers often need to access the state of an object. An accessor
> message returns information related to the state of an object. An
> accessor may simply return the value of a data member as with
> LibraryBook::borrower and BankAccount::balance. Accessors may also
> need to do some internal processing using the state of an object to
> return the information (employee::incomeTax, for instance). Here are
> some example messages that access the state of objects:
>
> s2.length() // Return the number of characters in s2
>
> g.row() // Return the mover's current row anAcct.getBalance() //
> Return the current balance of anAcct aBook.getBorrower() // Return the
> borrower's name of aBook

6.4.4 NAMING CONVENTIONS

> Modifying operations are typically given a name that indicates the
> message will change the state of the object. Th is is easily
> accomplished if the designer of the class simply gives a descriptive
> name to the operation. Th e name should describe—as best as
> possible—what the operation actually does. Another way to help
> programmers who use a class to distinguish modifi ers from accessors
> is to give the modifi ers names that can be used as verbs such as
> withdraw, deposit, borrowBook, and returnBook, for example. Th e
> accessors are given names that often begin with “get,” such as
> getBorrower and getBalance. Considering that the constructor has the
> same name as the class, some guidelines are established for designing
> and reading class defi nitions. Th ese three categories of
> operations—typical of state objects—can be distinguished by using the
> following naming conventions.

  > **Operation **   **Name **
  ------------------ -----------------------------------------------
  > Constructor      Same name as the class
  Modifi er          Identifi er name that could be used as a verb
  Accessor           Identifi er name that begins with “get”

> Above all, always try to use identifi ers that describe what the
> object is. For example, don’t use x as the name of the operation to
> withdraw money from a BankAccount or turnRight to make the mover turn
> left.

**6.4.5 public: OR private:**

> One of the considerations in the design of a class is the placement of
> member functions and data members under the most appropriate access
> mode, either public: or private:. Whereas public members of a class
> can be called from another function outside of the class, the scope of
> private members is limited to the class member functions. For example,
> the BankAccount data member balance is only known to the member
> functions of the BankAccount class. On the other hand, any member
> declared in the public: section of a class is known everywhere in the
> class and also in the block of source code where the object is
> declared (or globally, if defi ned outside of a block).

  > **Access Mode **   **Where Is the Member Known? **
  -------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  > public:            In all class member functions and in the block of the client code where the object has been declared (in main, for instance).
  > private:           Only inside the class member functions. Because these are known everywhere in the class, you do not have to pass or return those values among the class member functions.

> Although the data members representing state could have been declared
> under public:, it is highly recommended that all data members be
> declared under the private: access mode. Th ere are several reasons
> for this.
>
> Th e consistency helps simplify some design decisions. More
> importantly, when data members are made private:, the state can be
> modifi ed only through a member function. Th is prevents client code
> from indiscriminately changing the state of objects. For example, it’s
> impossible to accidentally make a credit like this from anywhere
> outside of the class:
>
> // An error occurs: attempting to modify private data myAcct.balance =
> myAcct.balance + 100000.00; // &lt;- ERROR
>
> or a debit like this:
>
> // An error occurs: attempting to modify private data myAcct.balance =
> myAcct.balance - 100.00;

6.4.6 SEPARATING INTERFACE FROM IMPLEMENTATION

> Th e practice of studying a class through its interface represents a
> principle in software engineering. It allows one to separate the
> interface from the implementation—the details of how the operations
> actually work. In C++, the completed member function implementations
> are often separated from the class defi nition by placing them in
> separate fi les. Historically, class defi nitions have been kept in .h
> (header) fi les with member function implementations in .cpp fi les
> (fi le extensions vary). Some programmers implement the member
> functions directly in the same fi le as the class defi nitions.
>
> Th e convention used in this textbook is to separate the class defi
> nition from the implementation. Th is is done by storing the class
> defi nition in a .h fi le and the member function implementations in a
> .cpp fi le. It is often the case that several fi les are combined
> together to make an executable program. Th ere are several ways to do
> this. Th e following fi gure illustrates one way to do this with these
> commands using the GNU compiler:

6.4: The State Object Pattern

g++ -c BankAccount.cpp g++ -c main.cpp g++ -o main main.o BankAccount.o

SELF-CHECK

> 6-14 What is meant when the const keyword is part of the function
> heading in a class defi nition?
>
> 6-15 Which member functions have the same name as the class?
>
> 6-16 What do accessors do?
>
> 6-17 What do modifi ers do?
>
> 6-18 What do constructors do?
>
> 6-19 What are the data members for?

6.5 OBJECT-ORIENTED DESIGN GUIDELINES

> One particular object-oriented design decision involves determining
> where to place the data members that store object state. More specifi
> cally, since this text uses C++ as the implementation language, the
> designer has to decide if data member functions go in the public: or
> the private: section of a C++ class. Th e following design guideline
> states that a good design protects object state from the outside
> world:
>
> Object-Oriented Design Guideline

All data should be hidden within its class.

> Although data members could be public:, the convention used in this
> text—and in any well-designed class—is to hide the data members. C++
> data members are easily hidden when declared in the private: section
> of the class defi nition. Th is simplifi es some design decisions. A
> private: data member can then only be modifi ed or accessed through
> messages.
>
> Th is prevents users of the class from indiscriminately changing
> certain data such as an account balance. Th e state of an object can
> be protected from accidental or improper alteration. With data members
> declared in the private: section, the state of any object can only be
> altered through a message. It becomes impossible to accidentally make
> a false debit like this:
>
> // Compile time error: attempt to modify private data
>
> // If balance is public:, what is the new balance? myAcct.balance =
> myAcct.balance - myAcct.balance;
>
> However, if balance had been declared in the public: section, the
> compiler would not protest. Th e resulting program would allow you to
> destroy the state of any object. Th e hidden balance is more properly
> modifi ed only when the transaction is allowed according to some
> policy. What happens, for instance, if a withdrawal amount exceeds the
> account balance in a withdraw

6.5: Object-Oriented Design Guidelines

> message? Some accounts allow this by transferring money from a savings
> account. Other bank accounts may generate loans in increments of
> \$100.00.
>
> With balance declared in the private: access section, users of the
> class must instead send a withdraw message. Th e client code relies on
> the BankAccount to determine if the withdrawal is to be allowed.
> Perhaps the BankAccount object will ask some other object if the
> withdrawal is to be allowed. Perhaps it delegates authority to some
> unseen bankManager object. Perhaps the BankAccount object itself can
> decide what to do. Although this text’s implementation of BankAccount
> doesn’t do much, real-world withdrawals do.
>
> By hiding data and other details, all credits and debits must “go
> through the proper channels.” Th is might be quite complex. For
> example, each withdrawal or deposit may be recorded in a transaction
> fi le to help prepare monthly statements for each BankAccount. Th e
> withdraw and deposit operations may have additional processing to
> prevent unauthorized credits and debits. Part of the hidden red tape
> might include manual verifi cation of a deposit or a check-clearing
> operation at the host bank; there may be some sort of human or
> computer intervention before any credit is actually made. Such
> additional processing and protection within the deposit and withdraw
> operations help give BankAccount a “safer” design. Because all hidden
> processing and protection is easily circumvented when data members are
> exposed in the public: section, the object designer must enforce
> proper object use and protection by hiding the data members.

6.5.1 COHESION WITHIN A CLASS

> Th e set of messages described in the class interface should be
> strongly related. A class stores data, and that data should be
> strongly related. In fact, all elements of a class should have a
> persuasive affi liation with each other. Th ese ideas relate to the
> preference for tight cohesion (solidarity, hanging together,
> adherence, unity) within a class. For example, don’t expect a
> BankAccount object to understand the message isPreheated. Th is may be
> an appropriate message for an oven object, but certainly not for a
> BankAccount object. Here is one guideline related to the desirable
> attribute of cohesion:
>
> Object-Oriented Design Guideline

Keep related data and behavior in one place.

> Th e BankAccount class should hide certain policies such as handling
> withdrawal requests greater than the balance. Th e system’s design
> improves when behavior and data combine to accomplish the withdrawal
> algorithm. Th is makes for nice clean messages from the client code,
> like this:
>
> anAccount.withdraw(withdrawalAmount);
>
> Th is client code relies on the BankAccount object to determine what
> should happen. Th e behavior should be built into the object that has
> the necessary data. Perhaps the algorithm allows a withdrawal amount
> greater than the balance—with the extra cash coming as a loan or as a
> transfer from a savings account. Even though the BankAccount class of
> this textbook does very little, a real bank account class might have
> eight diff erent actions that are triggered for every withdrawal—all
> behind the scenes.

**6.5.2 WHY ARE ACCESSORS const AND MODIFIERS NOT? **

> You may be wondering why const is added to function headings intended
> to access, rather than modify, the object’s state. Th e answer has to
> do with the three diff erent parameter modes. When an object is passed
> by value or by reference to a function, that function can send any and
> all possible messages to that object inside the other function.
> However, when the const reference parameter mode is utilized, the
> function promises not to change that object. In fact, it cannot. To
> illustrate, consider the following function that will not
> compile—there is a compile time error at the attempt to withdraw from
> the const reference parameter ba. Th is is actually a good thing. Th e
> reason for using const reference parameters is to avoid accidental
> modifi cation of the associated argument.
>
> // Illustrate connection between member functions tagged as const
>
> // functions and passing objects of that class as const parameter
>
> \#include &lt;iostream&gt; // For cout and endl using namespace std;
> \#include "BankAccount.h" // For the BankAccount class
>
> void display(const BankAccount & ba) {
>
> // Can send accessing messages--they are declared const cout &lt;&lt;
> "{ BankAccount: " &lt;&lt; ba.getName() &lt;&lt; ", \$" &lt;&lt;
> ba.getBalance() &lt;&lt; " }" &lt;&lt; endl;
>
> // This modi er was not tagged with const. A compile time // error
> will be generated since ba is a const parameter.
>
> ba.withdraw(234.56); // &lt;-- ERROR at compile time }
>
> int main() { BankAccount anAcct("Angel Draper", 1234.56);
>
> display(anAcct); return 0; }
>
> Th is protection works fi ne for standard classes such as string. Th e
> same protection will only work with your new classes if care is taken
> to tag the accessors as const and leave the modifi ers as non-const.
>
> A consistent use of const accessors allows the accessing messages to
> be sent to the const parameters. At the same time, by not using const
> with modifi ers, a const parameter prevents use of a message that will
> change the object.

6.5: Object-Oriented Design Guidelines

> Object-Oriented Design Guideline

Only const messages are allowed on const parameters.

> On the other hand, it is okay to send messages that do not modify the
> object. Th is safety net is possible only when the programmer
> diligently tags accessing class member functions with const and always
> remembers not to tag a modifi er that way.
>
> class BankAccount {
>
> public: //--modi ers void deposit(double depositAmount); // No const
> for modi ers void withdraw(double withdrawalAmount);
>
> //--accessors
>
> double getBalance() const; // Use const on accessors string getName()
> const; // . . .
>
> Th is leads to another design guideline:
>
> Object-Oriented Design Guideline

Always declare accessor member functions as const.

> Perhaps the biggest problem with this guideline is in remembering the
> guideline. It is easily violated. You’ll never know the ramifi cations
> until an instance of your class is passed as a const reference
> parameter. As another example, consider the Grid class modifi ers,
> which are non-const, and some accessors, which are declared as const
> functions.
>
> class Grid { public: . . . //--modi ers void move(int spaces);
>
> . . .
>
> //--accessors int row() const; int column() const;
>
> . . .
>
> };
>
> Th e presence of const tells the compiler to allow the message to be
> sent even for objects passed by const reference (g here):
>
> void doSomething(const Grid & g) { cout &lt;&lt; g.row() &lt;&lt;
> endl; // OKAY cout &lt;&lt; g.nColumns() &lt;&lt; endl; // OKAY
>
> g.display(); // OKAY
>
> g.move(); // Compile time ERROR
>
> g.pickUp(); // Compile time ERROR }
>
> On the other hand, the attempt to send non-const messages such as
> Grid::move results in a compile time error like these (more cryptic
> error messages exist) depending on the compiler used:
>
> non-const member function 'Grid::move()' called for const object

-   or -

> attempt to modify a const object

-   or -

> member function 'pickUp' not viable: 'this' argument has type 'const
> Grid', but function is not marked const
>
> Declaring accessors as const functions allows existing objects to be
> safely passed to a const parameter. However, it takes diligence to
> maintain the same safety net for the new classes that you write.
> Remember these two class design guidelines:

1.  Modifi ers should *not* be declared const so the compiler can catch
    > attempts to modify const objects.

2.  Accessors should be declared const so objects can be safely passed
    > to const parameters and still allow non-modifying messages.

> It would be easier to completely ignore these rules, but the only way
> to get away with it would be to never pass objects to const
> parameters. Th is textbook uses const in a member function because it
> says something about whether or not a function modifi es the state of
> an object. And this is something object-oriented programmers must know
> about. Th e designer of the class must still decide if the message
> will modify an instance of the class or not.

SELF-CHECK

> 6-20 Using the class defi nition of the BankAccount class, list the
> lines that cause errors in a standard C++ compiler (1, 2, 3, and/or
> 4).
>
> \#include &lt;iostream&gt; using namespace std; \#include
> "BankAccount.h" // For the BankAccount class
>
> void check(const BankAccount & b, double amount) { cout &lt;&lt;
> b.getName() &lt;&lt; endl; // 1 b.deposit(amount); // 2
>
> b.withdraw(amount); // 3 cout &lt;&lt; b.getBalance() &lt;&lt; endl;
> // 4
>
> }

Chapter Summary

> int main() {
>
> BankAccount myAcct("Me", 12345.00); check(myAcct, 50.00); return 0; }

CHAPTER SUMMARY

-   Th is chapter showed class defi nitions with a collection of
    > function headings that represent the class interface. Th ese are
    > the message names that any object of the class will understand.

-   A class defi nition lists:

-   the class member functions with parameters and return types,
    > collectively known as the interface

-   the data members, known collectively as the state

-   Each object of a class may store many values, which may be of diff
    > erent classes. For example, each BankAccount object stores string
    > data for the name and numeric data for the balance.

-   Th e state object pattern guides class design when the primary need
    > for the object is to store state and provide adequate access
    > to it. Th e state object pattern in C++ recommends that the
    > following items be included in a class defi nition:

-   a constructor to initialize objects with programmer-supplied state

-   modifying functions

-   accessor functions

-   private data members to store the state of every object Modifying
    > class member functions changes the state of the object.

-   Accessor functions provide access to the state of an object.

-   Accessors have the keyword const attached at the end of the
    > function heading.

-   Ramifi cations of adhering to Object-Oriented Design Guideline “All
    > data should be hidden within its class” include:

-   Good: can’t mess up the state (compiler complains)

-   Bad: need to implement additional accessors (getBalance,
    > for example)

-   Th e ramifi cations of adhering to Design Guideline “Keep related
    > data and behavior in one place” include:

-   Good: results in a more intuitive design

-   Good: easier to maintain

-   Th e ramifi cations of adhering to Design Guideline “Always declare
    > accessor member func-tions as const” include:

-   Good: helps the user distinguish between modifi ers and accessors

-   Good: adheres to the principle that objects passed as const
    > reference parameters cannot be accidentally modifi ed by the
    > function while allowing the function to send const messages

-   Bad: it is easy to forget to use const and the error will not show
    > up until the object is passed in the three diff erent modes—the
    > result is more extensive testing to ensure the safety of const and
    > the effi ciency of const reference parameters

-   Class member functions are implemented in a manner similar to
    > nonmember functions. However, class member functions must be
    > qualifi ed with the class name and :: (the scope
    > resolution operator). Th is gives the function access to the
    > private data members.

-   Class defi nitions have historically been stored in .h fi les.

-   Member function implementations have historically been stored in
    > .cpp fi les. A class should be designed to exhibit high cohesion:
    > the data should be related to the operations

-   the messages should be related to each other

EXERCISES

1.  Does the interface of a class refer to its member functions or its
    > data members?

2.  Does the client code need to know the names of data members to use
    > objects of the class?

3.  Describe the scope of the public members of a class.

4.  Describe the scope of the private members of a class.

5.  Give one justifi cation for making the data members of a
    > class private.

6.  If the designer of BankAccount class changed the name balance to
    > my\_Balance, would programs using BankAccount need to be changed?

7.  If a designer changed the name of the withdraw message to
    > withdrawThisAmount after the class was already in use by dozens of
    > programs, would these dozens of programs need to be changed?

8.  What is responsible for deciding if a particular LibraryBook is
    > available for lending, the LibraryBook or the program using
    > LibraryBook?

9.  Should a BankAccount object understand the message
    > isThisBrakeLockingUp?

10. If an object is passed by value, which messages can be sent: modifi
    > ers, accessors, or both?

11. If an object is passed by reference (with &), which set of messages
    > can be sent: modifi ers, accessors, or both?

12. If an object is passed by const reference as in (const Grid &
    > aGrid), which set of messages can be sent: modifi ers, accessors,
    > or both?

13. Given this defi nition for a class Counter class, predict the output
    > from the test driver below:

Exercises

> /\*
>
> \* Filename: Counter.h
>
> \*/ class Counter { public:
>
> //-- constructor
>
> Counter(int maxValue);
>
> // post: Initialize count to 1 and set the maximum count
>
> // modi ers void click(); // post: If count is at maximum, set count
> to 1, otherwise add 1
>
> // to the count. This uses the % operator when adding to count.
>
> void reset(); // post: Resets the counter to 1
>
> // accessor
>
> int getCount() const; // post: Return the current count
>
> private:
>
> int count; // Current count, always start at 1 int max; // The largest
> value count can reach };
>
> **TEST DRIVER**
>
> \#include &lt;iostream&gt; using namespace std;
>
> \#include "Counter.h" // For the counter class de nition
>
> int main() { // Test drive counter class
>
> Counter aCounter(3);
>
> cout &lt;&lt; "a: " &lt;&lt; aCounter.getCount() &lt;&lt; endl;
> aCounter.click();
>
> cout &lt;&lt; "b: " &lt;&lt; aCounter.getCount() &lt;&lt; endl;
> aCounter.click();
>
> cout &lt;&lt; "c: " &lt;&lt; aCounter.getCount() &lt;&lt; endl;
> aCounter.click();
>
> cout &lt;&lt; "d: " &lt;&lt; aCounter.getCount() &lt;&lt; endl;
> aCounter.click();
>
> cout &lt;&lt; "e: " &lt;&lt; aCounter.getCount() &lt;&lt; endl;
> aCounter.reset();
>
> cout &lt;&lt; "f: " &lt;&lt; aCounter.getCount() &lt;&lt; endl; return
> 0; }
>
> 14\. Write all code that would go into Counter.cpp that completely
> implements all member functions defi ned in Counter.h so that the
> program above generates the correct output.

PROGRAMMING TIPS

1.  Working with three fi les is more diffi cult than working with one,
    > but some programming projects will now require that you work with
    > three fi les, not just one. Th is takes a little patience as you
    > grow accustomed to working with multiple fi les. Remember, the .h
    > fi le contains the class defi nition; the .cpp fi le contains the
    > member function implementations. Th e third fi le has the
    > main function.

2.  Th ere is a variety of ways to make classes available. Even though
    > the convention of having one fi le include the .h and .cpp fi les
    > is atypical, it makes things easier and matches the standard (many
    > \#include fi les do not have .h anymore). However, someday you may
    > be asked to create object fi les or project fi les to compile and
    > link programs using author-supplied classes. Th en your program
    > may just include the .h fi le so it can compile. Linking
    > comes later.

> \#include " BankAccount.h " // Other steps required to link int main()
> { // . . .
>
> }

1.  Th e nonmember function syntax applies to member function
    > headings also. Th e function heading in the implementation must
    > match the function heading in the class defi nition in terms of

    -   return type (none for constructors)

    -   function name

    -   number of parameters

    -   type of parameters

    -   order of parameters

    -   use of const in both places (or neither)

2.  Don’t write using namespace std; in header fi les. Once you use a
    > namespace you can’t unuse it. While it may not cause any problems
    > in the programs in this textbook, you should get in the habit now
    > to avoid future programming problems.

3.  Function headings in the implementation fi le (.h) diff er from the
    > function headings in the implementation fi le (.cpp).

    -   functions need className:: to precede the function name

    -   the function body { } replaces the semicolon

> /\* \* File name: CD.h
>
> \*/
>
> \#include &lt;string&gt; class CD {
>
> public:
>
> CD(std::string initArtist, std::string initTitle); std::string
> getArtist() const;
>
> private:
>
> std::string artist, title; };
>
> /\*
>
> \* File name: CD.cpp
>
> \*/
>
> \#include "CD.h" using namespace std;
>
> CD::CD(string initArtist, string initTitle) { // . . .
>
> }
>
> string CD::getArtist() const {
>
> // . . .
>
> }

PROGRAMMING PROJECTS

6A ADD int getTransactionCount TO BankAccount

> Allow BankAccount objects to keep track of and report the number of
> transactions, deposits, and withdrawals made since the initialization
> of any BankAccount object. Name this new function int
> getTransactionCount(). Use this test driver and ensure your output
> matches and compiles:
>
> \#include &lt;iostream&gt; using namespace std; \#include
> "BankAccount.h"
>
> int main() {
>
> BankAccount anAcct("Do 3", 3.00);
>
> cout &lt;&lt; "0? " &lt;&lt; anAcct.getTransactionCount() &lt;&lt;
> endl; anAcct.deposit(10.00); anAcct.withdraw(20.00);
> anAcct.deposit(30.00); cout &lt;&lt; "3? " &lt;&lt;
> anAcct.getTransactionCount() &lt;&lt; endl;
>
> BankAccount another("Do 1", 1.00); another.withdraw(25.00);
>
> cout &lt;&lt; "1? " &lt;&lt; another.getTransactionCount() &lt;&lt;
> endl;
>
> return 0;
>
> }
>
> Output
>
> 0? 0
>
> 3? 3
>
> 1? 1

6B ADD turnAround AND turnRight TO class Grid

> Add the following operations to the defi nition of the Grid class in
> the fi le named Grid.h:
>
> void turnAround(); // post: The mover is facing the opposite direction
>
> void turnRight(); // post: The mover is facing 90 degrees clockwise
>
> Also add both class member functions at the top of the fi le named
> Grid.cpp. Please try to ignore all the other stuff in that rather
> large fi le. You will fi nd it easier to use the existing member
> function turnLeft to implement these two new functions.

  -----------------------------------------------------------
  \#include "Grid.h"           > The grid:
                               >
  int main() {                 > . . . . . . . . . . . .
                               >
  Grid g(6, 12, 1, 9, east);   > . . . . . . . . . &gt; . .
                               >
  g.display();                 > . . . . . . . . . . . .
                               >
  g.turnAround();              > . . . . . . . . . . . .
                               >
  g.move(5);                   > . . . . . . . . . . . .
                               >
  g.turnLeft();                > . . . . . . . . . . . .
                               >
  g.move(2);                   > The grid:
                               >
  g.turnRight();               > . . . . . . . . . . . .
                               >
  g.move(3);                   > . . . . . .
                               >
  g.display(); return 0;       > . . . . . . . . . . .
                               >
  }                            > . &lt; . . . . . . .
                               >
                               > . . . . . . . . . . . .
                               >
                               > . . . . . . . . . . . .
  ---------------------------- ------------------------------
  -----------------------------------------------------------

6C CLASS AVERAGER

> Given the following defi nition of class Averager in the fi le
> Averager.h, implement all member functions in a new fi le
> Averager.cpp. You should be able to add any number of test or quiz
> scores and fi nd the average and number of scores added at any time.
>
> /\*

-   De ne class Averager that maintains the average for \* any number of
    > quiz or test scores.

-   \* File name: Averager.h (available on this book's website)

> \*/ class Averager { public:
>
> // Construct an Averager with no scores added.
>
> Averager();
>
> //-- modi ers void addScore(double score); // post: Add a score so the
> count and average are correct.
>
> //--accessors double getAverage() const; // post: Return the average
> of all scores entered.
>
> int getScoresAdded() const; // post: Return how many scores were added
>
> private:
>
> int n; // number of scores added so far, initially 0 double sum; //
> total of all scores added, initially 0.0 };
>
> Th is test driver should generate the expected output below:
>
> \#include &lt;iostream&gt; using namespace std; \#include "Averager.h"
>
> int main() {
>
> Averager averager;
>
> cout &lt;&lt; " 0? " &lt;&lt; averager.getScoresAdded() &lt;&lt; endl;
>
> averager.addScore(90.0);
>
> cout &lt;&lt; " 90? " &lt;&lt; averager.getAverage() &lt;&lt; endl;
> cout &lt;&lt; " 1? " &lt;&lt; averager.getScoresAdded() &lt;&lt; endl;
>
> cout &lt;&lt; endl; averager.addScore(100.0); averager.addScore(80.0);
> averager.addScore(70.0); averager.addScore(60.0);
> averager.addScore(53.0);
>
> cout &lt;&lt; "Scores Added 6? " &lt;&lt; averager.getScoresAdded()
> &lt;&lt; endl; cout &lt;&lt; " Average 75.5? " &lt;&lt;
> averager.getAverage() &lt;&lt; endl; return 0; }
>
> Expected Output
>
> 0? 0
>
> 90? 90
>
> 1? 1
>
> Scores Added 6? 6
>
> Average 75.5? 75.5

6D class PiggyBank

> A PiggyBank object encapsulates the contents of a piggy bank with
> messages associated with real world actions. It knows how many of each
> coin—pennies, nickels, dimes, and quarters—are in it along with total
> cash value. A PiggyBank object can also be emptied with a drainTheBank
> message, which also returns the amount of money at that moment. Here
> is the class defi nition:
>
> /\*

-   This class models a piggy bank to which pennies, nickels, dimes,

-   and quarters can be added. A PiggyBank object maintains how many

-   of each coin it holds and can tell you the total amount of money \*
    > in it.

> \*

-   File name: PiggyBank.h (available on this book's website)

> \*/ class PiggyBank { public:
>
> PiggyBank();
>
> // post: An PiggyBank is built with no coins
>
> void addPennies(int penniesAdded);
>
> // pre: penniesAdded &gt; 0
>
> // post: This PiggyBank has penniesAdded more pennies
>
> void addNickels(int nickelsAdded);
>
> // pre: nickelsAdded &gt; 0
>
> // post: This PiggyBank has nickelsAdded more nickels
>
> void addDimes(int dimesAdded);
>
> // pre: dimesAdded &gt; 0
>
> // post: This PiggyBank has dimesAdded more dimes
>
> void addQuarters(int quartersAdded);
>
> // pre: quartersAdded &gt; 0
>
> // post: This PiggyBank has quartersAdded more quarters
>
> double drainTheBank();
>
> // post: Remove all of the coins from this PiggyBank
>
> // and returns how much there was before it was emptied
>
> //-- Accessors int getPennies(); // post: Return the total number of
> pennies in this bank
>
> int getNickels(); // post: Return the total number of nickels in this
> bank
>
> int getDimes(); // post: Return the total number of dimes in this bank
>
> int getQuarters();
>
> // post: Return the total number of quarters in this bank
>
> double getTotalCashInBank();
>
> // post: return the total cash in the bank. Pennies are
>
> // \$0.01, nickels are \$0.05, dimes are \$0.10, and quarters
>
> // are \$0.25 (no half or one dollar coins).
>
> private:
>
> int pennies, nickels, dimes, quarters; };
>
> Th is test driver should generate the expected output below:
>
> \#include &lt;iostream&gt; using namespace std; \#include
> "PiggyBank.h"
>
> int main() { PiggyBank pb;
>
> cout &lt;&lt; " 0? " &lt;&lt; pb.getTotalCashInBank() &lt;&lt; endl;
> pb.addPennies(4); pb.addNickels(3); pb.addDimes(2); pb.addQuarters(1);
>
> cout &lt;&lt; " 4? " &lt;&lt; pb.getPennies() &lt;&lt; endl; cout
> &lt;&lt; " 3? " &lt;&lt; pb.getNickels() &lt;&lt; endl; cout &lt;&lt;
> " 2? " &lt;&lt; pb.getDimes() &lt;&lt; endl; cout &lt;&lt; " 1? "
> &lt;&lt; pb.getQuarters() &lt;&lt; endl; cout &lt;&lt; "0.64? "
> &lt;&lt; pb.getTotalCashInBank() &lt;&lt; endl; cout &lt;&lt; "0.64? "
> &lt;&lt; pb.drainTheBank() &lt;&lt; endl; cout &lt;&lt; " 0? "
> &lt;&lt; pb.getTotalCashInBank() &lt;&lt; endl; return 0; }
>
> Expected Output
>
> 0? 0
>
> 4? 4
>
> 3? 3
>
> 2? 2
>
> 1? 1
>
> 0.64? 0.64
>
> 0.64? 0.64
>
> 0? 0

6E class Employee

*Note: Th is type asks for a new member function in Chapter 7:
Selection*

> While programmers at Chrystal Bends, Inc., were designing the payroll
> system, they realized they needed an Employee type. An Employee object
> is responsible for maintaining the information necessary to complete
> an employee’s paycheck for employees who get paid on an hourly basis.
> Th is Employee object is responsible for computing its own gross and
> net pay and computing how much to withhold for Social Security tax
> (6.2% of the gross pay) and Medicare tax (1.45% of the gross pay) for
> the week. Th e Chrystal Bends, Inc. programming team has designed this
> C++ class defi nition, which you are asked to use to implement and
> test the member functions.
>
> /\* \* Model a weekly employee who gets paid on an hourly basis.

-   Only two taxes are included so far: Medicare and Social

-   Security. You may be asked to add Federal Income tax later

> \*

-   File name: Employee.h (available on this book's website)

> \*/
>
> \#include &lt;string&gt;
>
> \#include &lt;iostream&gt;
>
> \#include &lt;cmath&gt;
>
> class Employee { public:
>
> // Constants for two taxes. C++11 needed for initialization.
>
> const double SOCIAL\_SECURITY\_TAX\_RATE = 0.062; const double
> MEDICARE\_TAX\_RATE = 0.0145;
>
> // Contructor
>
> Employee(std::string initName, double hourlyRate);
>
> // post: A Employee is built with 0.00 hours worked.
>
> void giveRaise(double raise);
>
> // pre: raise &gt; 0. The argument 3.5 means a 3.50% raise.
>
> // post: The hourly rate of pay has changed
>
> void setHoursWorked(double hoursWorked); // pre: hoursWorked &gt;= 0.0
> // post: hours worked for the current week is set.
>
> // Gross pay, net pay, and taxes can now be computed.
>
> //--accessors std::string getName(); double getHoursWorked(); double
> getHourlyRate(); double getSocSecurityTax(); double getMedicareTax();
> double getGrossPay(); double getNetPay();
>
> private: // data members std::string name; double rate; double hours;
> };
>
> Th e following test driver sends all possible messages to one
> Employee. Th e hours worked per week must be set with a setHoursWorked
> message in order for the gross pay taxes and net pay to be computed.
> Th is test driver should generate the expected output below:
>
> \#include &lt;iostream&gt;
>
> \#include "Employee.h" using namespace std;
>
> // Test Driver int main() {
>
> Employee emp1("Ali", 10.00);
>
> cout &lt;&lt; " Ali? " &lt;&lt; emp1.getName() &lt;&lt; endl; cout
> &lt;&lt; " 10? " &lt;&lt; emp1.getHourlyRate() &lt;&lt; endl; cout
> &lt;&lt; " 0? " &lt;&lt; emp1.getHoursWorked() &lt;&lt; endl; cout
> &lt;&lt; " 0? " &lt;&lt; emp1.getGrossPay() &lt;&lt; endl;
>
> // Record the hours worked in the current week
> emp1.setHoursWorked(40.00);
>
> cout &lt;&lt; " 400? " &lt;&lt; emp1.getGrossPay() &lt;&lt; endl; cout
> &lt;&lt; " 24.8? " &lt;&lt; emp1.getSocSecurityTax() &lt;&lt; endl;
> cout &lt;&lt; " 5.8? " &lt;&lt; emp1.getMedicareTax() &lt;&lt; endl;
> cout &lt;&lt; " 369.4? " &lt;&lt; emp1.getNetPay() &lt;&lt; endl; cout
> &lt;&lt; endl; emp1.giveRaise(10); // 10% raise
>
> cout &lt;&lt; " 11? " &lt;&lt; emp1.getHourlyRate() &lt;&lt; endl;
> cout &lt;&lt; " 440? " &lt;&lt; emp1.getGrossPay() &lt;&lt; endl; cout
> &lt;&lt; "406.34? " &lt;&lt; emp1.getNetPay() &lt;&lt; endl; }
>
> Expected Output
>
> Ali? Ali
>
> 10? 10
>
> 0? 0
>
> 0? 0
>
> 400? 400
>
> 24.8? 24.8
>
> 5.8? 5.8 369.4? 369.4
>
> 11? 11
>
> 440? 440
>
> 406.34? 406.34

© 2018 Franklin, Beedle & Associates All rights reserved
