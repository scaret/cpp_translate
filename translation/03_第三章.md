# 第3章 自由函数的运用

**前章回顾**

我们现在应该已经在自己的系统中亲身体验了这门语言的语法、报错信息及其程序开发从头到尾的过程。而且，本书前几章中的大部分编程项目实施的都是IPO这个算法模式，相信读者现在应该也可以在实践中按照正常的顺序安排这三个步骤，并能理解省略其中某个步骤或以某种混合顺序执行的情况了。

**本章提要**

为了节省时间和资金，软件开发者通常会选择利用现有的软件来完成他们的工作。在本章，我们将介绍重用现有软件的其中一种方式，程序员们通常会将这些经过大量测试的软件作为自身工作的为起点。我们将学习如何通过函数的头信息（function headings）了解现有函数的用法，并通过阅读这些函数用法中的前置和后置条件来确定它们的功能。在本章的最后，我们还会列出一些你可能会遇到的错误种类。我们希望在完成本章的学习之后，你将：

* 学会使用一些数学函数和三角函数来进行求值运算。
* 学会在调用函数时使用参数。
* 理解为什么程序员们要将软件划分成一系列函数。
* 学会通过函数的头信息来了解现有函数的用法。

## 3.1 `cmath`函数

C++为我们定义了大量可用于双精度浮点运算的数学函数和三角函数。下面是其中的两个：

```C++
sqrt(x) // Return the square root of x
pow(x,y) // Return x to the yth power
```

如你所见，这些函数的*调用*都是通过指定函数名称，并紧随其后的括号中加上指定数量和类型的*参数*来执行的。这样我们就得到了一般函数调用的通用格式：

**通用格式 3.1**：*函数调用*

function-name(*arguments*)

在这里，*function-name*是一个已被声明的标识符，它代表的是目标函数的名标。而*arguments*则通常是一组由逗号分隔的零个或多个表达式。譬如在下面这个函数调用中，函数的名称是`sqrt`（即平方根），它的参数为`81.0`：

```C++
sqrt(81.0) // An example of a function call
```

函数通常会有零个或多个参数。尽管大多数数学函数都只需要一个参数，但也会有像`pow()`这种需要两个参数的函数。在接下来的这个函数调用中，函数的名称是`pow`（即power），参数是底数和指数。也就是说，函数调用`pow(base, power)`代表的就是指数运算${base}^{power}$：

```C++
double base = 2.0;
double power = 3.0;
cout << pow(base, power); // Output: 8.0
```

在函数调用的过程中，我们使用的所有参数都必须是一个该函数可接受类型的表达式。例如`sqrt("Bobbie")`这个调用就会出错，因为该参数并不属于数字类型。

另外，我们提供给函数的参数还必须要合乎要求。例如`sqrt(-4.0)`这个函数调用就可能是有问题的，因为-4.0并不在`sqrt`函数所要求的域中，平方根函数并没有为负数值做出相因的定义。也就是说，事实上`sqrt`函数只有在某些特定条件得到满足时才会正常执行。对于`sqrt`函数而言，这个条件就是它的参数值必须大于或等于0.0。下面，我们再来看一下`cmath`函数库中还有哪些可用的数学函数和三角函数。

 **`cmath`函数库中的部分函数** *提示：下面的`double`代表的是函数的返回值类型*

| 函数 | 返回值说明 | 调用示例 | 示例结果 |
|-----|-----------|---------|--------|
| `double ceil(double x)` | 返回大于等于`x`的最小整数 | `ceil(2.1)` | 3.0 |
| `double cos(double x)`  | 返回角度`x`的余弦值 | `cos(1.0)` | 0.5403 |
| `double fabs(double x)` | 返回`x`的绝对值 | `fabs(-1.5)` | 1.5 |
| `double floor(double x)`  | 返回小于等于`x`的最大整数 | `floor(2.9)` | 2.0 |
| `double pow(double x, double y)` | 返回$x^y$ | `pow(2, 4)` | 16.0 |
| `double sin(double x)` | 返回角度`x`的正弦值 | `sin(1.0)` | 0.84147 |
| `double sqrt(double x)` | 返回`x`的平方根 | `sqrt(4.0)` | 2.0 |

程序员只需要在`#include <iostream>`这条语句的上面加上一条`#include <cmath>`，就可以成功调用到`cmath`函数库中声明的函数了。也就是说，下面这段程序将会被成功编译：

```C++
// Show some mathematical functions available from cmath
#include <cmath>        // For fabs, ceil, floor, and pow
#include <iostream>     // For cout using namespace std;

int main() {
    double x = -2.1;
    cout << "fabs(-2.1): " << fabs(x) << endl
         << "ceil(-2.1): " << ceil(x) << endl
         << "floor(-2.1): " << floor(x) << endl
         << "pow(-2.1, 2.0): " << pow(x, 2.0) << endl;
    return 0;
}
```

**程序输出**

```shell
fabs(-2.1): 2.1
ceil(-2.1): -2
floor(-2.1): -3
pow(-2.1, 2.0): 4.41
```

需要提醒的是，这些`cmath`函数的参数也都可以使用整数表达式来调用。和赋值操作一样，它们会执行将整数值升格成`double`类型，所以`sqrt(4)`与`sqrt(4.0)`会返回相同的结果，不会有任何错误。

**自检题**

3-1 请求取`pow(4.0, 3.0)`的值。

3-2 请求取`pow(3.0, 4.0)`的值。

3-3 请求取`floor(1.6 + 0.5)`的值。

3-4 请求取`ceil(1.6 - 0.5)`的值。

3-5 请求取`fabs(1.6 - 2.6)`的值。

3-6 请求取`sqrt(16.0)`的值。

## 3.2 使用`cmath`函数解决问题

*问题：* 请编写一个能将指定数字四舍五入到某个小数位的程序。例如，将3.4589四舍五入到两位小数就是3.46，而四舍五入到一位小数就是3.5。

### 3.2.1 分析

下面我们按照软件开发的分析-设计-实现的步骤来进行，先进行如下分析动作：

1. 阅读并理解目标问题。
2. 定义用来表示答案的对象——即输出。
3. 定义用为获得答案必须键入相关内容的对象——即输入。
4. 编写测试用例（我们在上面已经提供了两个）。

### 3.2.2 设计

设计阶段的任务是提出算法。我们在这里可以借助IPO算法模式先开发出给予伪代码的算法。为了方便后续讲解，我们在这里先复习一下这个算法模式：

| 模式： | 输入/处理/输出（IPO） |
|-------|---------------------|
| 问题： | 程序需要基于用户的输入来计算并显示我们所需的信息。 |
| 纲要： | 1. 获取输入数据。<br> 2. 用某种有意义的方式处理数据。<br> 3. 输出结果。<br> |
| 示例： | 请参考我们接下来对于将`x`四舍五入到n位小数这个问题的描述。 |

IPO算法模式可以很好地帮助我们安排出良好的操作顺序。在这里，算法代表的是一般性设计，它是解决方案的纲要。为了让算法看起来更为详尽一些，我们还在其中的两处引入了先提示再输入模式，具体如下：

1. 提示用户指定要进行四舍五入的数字（并将其命名为`x`）。
2. 用户输入`x`的值。
3. 提示用户指定目标的小数位数（并将其命名为`n`）。
4. 用户输入`n`的值。
5. 将`x`四舍五入到`n`位小数。
6. 显示`x`被修改之后的值。

步骤1、2、3、4和6用C++实现起来都非常简单，它们直接用输入/输出语句就可以实现了。但第五步“将`x`四舍五入到`n`位小数”描述得还不够详尽。下面我们要继续改进第五步的设计。在其余部分不需要再考虑的情况下，我们现在可以将注意力集中到如何将`x`四舍五入到`n`位小数这个更难的问题上来了。这部分的解决方案的确会有点没法，下面我们来看其中一种方法。

为了将数字`x`四舍五入到`n`位小数，首先我们要让`x`先乘以$10^n$。然后再将新的`x`值加上0.5。接着再对`x`调用`floor(x)`。最后再让`x`除以$10^n$。于是，上述算法就多增加了以下四个步骤：

1. 提示用户指定要进行四舍五入的数字（并将其命名为`x`）。
2. 用户输入`x`的值。
3. 提示用户指定目标的小数位数（并将其命名为`n`）。
4. 用户输入`n`的值。
5. 将`x`四舍五入到`n`位小数的步骤如下：
   * a. 将`x`的值修改成$x * 10^n$。
   * b. 将`x`的值加上0.5。
   * c. 将`x`的值修改成`floor(x)`。
   * d. 将`x`的值修改成$x / 10^n$。
6. 显示`x`被修改之后的值。

下面我们来模拟跟踪一下程序执行的过程，看看当`x`为3.4567时，它是如何被四舍五入到两位小数的。

**将3.4567四舍五入到两位小数的过程：**

$$ x = x * 10^n     =      3.4567 * 10^2    =    345.67 $$
$$ x = x + 0.5      =      345.67 + 0.5     =    346.17 $$
$$ x = floor(x)     =      floor(346.17)    =    346    $$
$$ x = x / 10^n     =      346.17 / 100.0   =    3.46   $$

**自检题**

3-7 请模拟跟踪同一个算法在不同问题示例下的运行过程，当我们要将9.99四舍五入到一位小数是，其结果会是什么？请在下列空白处写下对应的新的`x`的值（即`x`在输入之后的四次变化）。

| 算法步骤                                                | x | n |
|--------------------------------------------------------|---|---|
| 1. 提示用户指定要进行四舍五入的数字（并将其命名为`x`）。       | ? | ? |
| 2. 用户输入`x`的值。                                  | 9.99 | ? |
| 3. 提示用户指定目标的小数位数（并将其命名为`n`）。         | 9.99 | ? |
| 4. 用户输入`n`的值。                                  | 9.99 | 1 |
| 5. 将`x`的值修改成$x * 10^n$。                       | _____ | 1 |
| 6. 将`x`的值加上0.5。                                | _____ | 1 |
| 7. 将`x`的值修改成`floor(x)`。                       | _____ | 1 |
| 8. 将`x`的值修改成$x / 10^n$。                       | _____ | 1 |
| 9. 显示`x`被修改之后的值。                            | _____ | 1 |

### 3.2.3 实现

下面，我们来看上述算法被转换成完整C++源码之后的版本。请留意一下源代码中的注释，我们在其中标出了各算法步骤在转换成c++之后的位置。

```C++
// Round a given number to a specific number of decimal places

#include <iostream>     // For cin and cout 
#include <cmath>        // For pow(10, n) and floor(x)
using namespace std;

int main() {
    // Declare objects identied during analysis
    double x = 0.0;
    double n = 0.0;
                                                    // Algorithm step number:
    // Input
    cout << "Enter number to round : ";             // 1.
    cin >> x;                                       // 2.
    cout << "Enter number of decimal places : " ;   // 3.
    cin >> n;                                       // 4.

    // Process (Round x to n decimals)
    x = x * pow(10, n);                             // 5a.
    x = x + 0.5;                                    // b.
    x = floor(x);                                   // c.
    x = x / pow(10, n);                             // d.

    // Output (Display the modied state of x)
    cout << "Rounded number : " << x << endl;        // 6.

    return 0;
}
```

**程序会话**

```shell
Enter number to round : ***3.4567***
Enter number of decimal places : ***2***
Rounded number : 3.46
```

**自检题**

3-8 请针对上述程序再列举三个测试用例。

3-9 在上述程序中，当用户输入`x`为3.15，`n`为1时，`x`的最终值是多少？

3-10 请根据第56页列出的“`cmath`函数库中的部分函数”，找出一个稍微有些不同的算法来完成相同的任务，只不过这次3.15四舍五入到一位小数的结果应该是3.1而不是3.2。（*提示：* 我们可以考虑将“加上0.5”这个步骤改成“减去0.5”。）

3-11 请写出以下函数调用的返回值。

* a. pow(2.0, 4.0)  
* b. sqrt(16.0)
* c. ceil(-1.7)
* d. floor(1.0)
* e. fabs(-23.4)
* f. pow(4.0, 2.0)

## 3.3 调用已被文档化的函数

在C++中，所有的函数都必须先要声明函数头信息，然后编译器才能确定相关的函数调用操作是否正确。另外，这些函数的头信息也能帮助程序员正确地调用他们。譬如，如果我们仔细阅读一下`cmath`这个文件，就会看到许多这样的函数头信息。

在这一节，我们就来重点介绍一下应该如何阅读这些函数的头信息，以及如何用其他说明文档来了解相关函数的预期和所要执行的动作，我们通常分别将它们称之为函数的前置条件与后置条件。

### 3.3.1 前置条件与后置条件

为了让函数能够正常执行它的操作，我们通常都会为其预设一些使用条件。譬如，对于`sqrt`函数来说，其预置条件就是要求函数参数是一个大于或等于0.0的数。函数的*前置条件*通常都是一些过于调用参数的一些假定。如果这些前置条件得不到满足，所有的预置动作都会被取消——这时函数行为将是未定义的，有些系统会以算术溢出错误终止程序，也有些系统会返回一个类似`-1.#IND`或`NaN`这样的只，告诉我们该值“不是一个数字”。总而言之，如果我们想让自己的函数调用得到可预期的结果，就必须要满足它的这些前置条件。

使用条件的另一部分叫做*后置条件*——这部分描述的是在前置条件得到满足的情况下函数会执行的动作。函数的前置条件和后置条件通常会被写入到该函数的文档部分中。例如下面就是`sqrt`这个函数关于其前置条件和后置条件的文档。

```C++
double sqrt(double x)
// precondition: x is not negative (x >= 0)
// postcondition: Square root of x replaces the function call
```

如你所见，注释说明了参数必须是一个大于或等于0.0的数字。如果该前置条件得到了满足，该参数的平方根就会被返回给*客户*——即调用该函数的代码。反之，结果将是未定义的。

| 函数调用       | 返回的结果      |
|---------------|---------------|
| `sqrt(4.0)`  | 前置条件得到满足，返回结果为2.0。|
| `sqrt(-1.0`) | 前置条件未被满足，该函数调用将返回`NaN`（即非数字）。|

当然，要想在调用函数之后获得预期的结果还有一个隐藏的前置条件，那就是客户代码必须提供正确的参数类型。例如，`ceil`函数需要的是一个`double`类型的参数，这意味着我们提供的参数必须要能被转换成`double`类型，包括`short`、`int`、`float`以及`char`。例如。`ceil`函数不接受`string`类型的参数，这可以说四个显而易见的先决条件：

```C++
double ceil(double x)
// precondition: Argument must be convertible to a double
// postcondition: Return the smallest integer >= x
```

但是，这类信息通常会被隐藏在参数声明中，编译器会根据声明自行检测出不正确的的参数。因此我们不会将这些内容写入前置条件。

前置条件的内容通常不是编译器能检测到的，例如，下面的程序在语法上是完全正确的：

```C++
cout << sqrt(-1.0); // Return depends on the system in use
```

从现在开始，我们会将前置条件的标签缩写成`pre:`，而后置条件则用`post:`来表示，这样的话，我们就可以上面同一个函数（`ceil`）的文档写成这样：

```C++
double ceil(double x) // post: Return the smallest integer >= x
```

当然，我们应该留意一下`pre:`和`post:`的用法，它们不一定非要放在函数头信息之后。不同的人对函数文档化的方式是不一样的，这里只是本书所采用的风格。

### 3.3.2 函数头信息

前置条件和后置条件可以帮助程序员确定相关函数的正确用法。如果我们想将这些作为文档提供给用户，它们通常会被列在函数的头信息之后。函数的头信息也是用于说明函数返回值和所需参数的非常重要的信息。下面我们来看一些函数头信息的通用格式：

**通用格式 3.2**：*函数头信息*

*return-type function-name* (*parameter-1, parameter-2, parameter-n*)

在这里，*return-type*可以是任何有效的C++类型或关键字`void`。函数的返回值为`void`时就表示它没有返回值。另外，在括号`( )`之间的参数可以是值类型参数、引用类型参数或者`const`的引用类型参数和值类型参数。下面我们先来看值类型参数。

一个函数通常都会有一个或多个参数，通过添加值类型参数来让我们可以将值传递给函数的格式如下：

**通用格式 3.3**：*值类型参数*

*class-name identifier*

**标准C++函数的头信息示例：**

```C++
int isapha(int c)
int tolower(int c);
double round (double x);
double remainder(double numerator, double denom);
```

如你所见，函数头信息指定了函数的返回值类型、函数的名称以及其要程序员体的参数数量。函数的参数类型也通过括号之间各参数的*class-name*部分做了指定。例如，由于下面的`pow`函数的参数`x`和`y`被声明成了`double`类型，所以我们可以确定调用`pow`函数的每个参数都必须是`double`类型，或者至少可以转换成`double`类型的，譬如整数类型。

```C++
double pow(double x, double y)
// pre:  When y has a fractional part, x must be positive
//       When y is an integer, x may be negative
// post: Returns x to the yth power
```

另外不要忘了，这里还声明了函数名是`pow`，返回值类型是`double`。

虽然这里并没有提供`pow`函数的完整实现，但前置条件、后置条件以及函数头信息所提供的信息已经足以有效地帮助人们了解该函数的用法了。

总而言之，函数头信息连同该函数的前置条件与后置条件一起为我们提供了以下信息：

1. *return-type*告诉了我们函数返回值的类型。
2. *function-name*告诉了我们如何启动一个有效的函数调用。
3. *parameter-list*告诉了我们在执行函数调用时要用到的参数数量以及这些参数的类型。
4. `pre:`告诉了我们在执行函数调用之前应满足哪些要求。
5. `post:`告诉了我们当一个函数的前置条件被满足之后，它会做哪些事。

In addition to revealing information to programmers, function headings supply information to the compiler to verify the validity of every attempt to call that function. Th e compiler informs you if a function is not called properly. Consider the oor function heading:



```C++
double floor(double x)
// post: Returns the largest integer <= x
```

The return type is double. Th is means that a double replaces any valid call to oor. Th erefore, the function call can be used wherever a double value is legal—in an arithmetic expression, for instance. Also present is the function name oor—very important information for effectively calling this or any particular function. The parameter list shows one double parameter named x. So the client code must supply exactly one numeric argument to properly call oor. For example, the following is a valid call to double and it is used in a proper spot in the code:

```C++
double x;
x = floor(5.55555); // This assignment is okay
```

However, these function calls are invalid:

```C++
string s;
s = floor(5.5555); // Error: floor doesn't return a string
cout << floor(1.0, 2.0);     // Error: too many arguments
cout << floor("wrong type"); // Error: wrong type argument
cout << floor();             // Error: too few arguments
```

**SELF-CHECK**

3-12 Given the following function heading, write “valid” for each correct function call or explain why it is not valid.

```C++
double ceil(double x)
```

  a. ceil(1.1)        d. ceil("Ceila")
  b. oor(2.9)         e. ceil -0.1
  c. ceil(1.2, 3.0)   f. ceil(-3)

3-13 Describe the error in each of the following attempts at function headings:

a.  double f ( x )
b.  int smaller(int n1 int n2)
c.  toUpper(string s)
d.  myClass g()
e.  int twoStrings(string s1, string s2,)
f.  unknownType initialize(" lename.dat")

Use the following documentation for the questions that follow:

```C++
double floor(double x)
// post: The oor function returns a oating-point value
// representing the largest integer that is less than or
// equal to x
```

3-14. Write four function calls (with diff erent arguments) that would help explain how oor works to someone who has never seen it before.

3-15. Write the values returned from each of the four function calls in your answer to the preceding question.

### 3.3.3 ARGUMENT / PARAMETER ASSOCIATIONS

A function heading may list zero, one, two, and sometimes more parameters. If there is more than one, the parameters must be separated by commas. Th e next function heading has two parameters—str and x.

```C++
double twoParameters(string str, double x)
```

Exactly one argument of an acceptable class is required for each parameter listed in a function heading. Th erefore, precisely two arguments must be present in every call to twoParameters. The compiler will report an error if you call this particular function with any other number of arguments than two. Additionally, the type and position of the arguments must match the type and position of the parameters. For example, a double argument cannot be associated with a string parameter. Here are some examples of correct calls of twoParameters:

**Valid Calls to the twoParameters Function**

```C++
twoParameters("abc", 1.2);
twoParameters("another string", 15);
twoParameters("\$", 3.4);
```

The following attempts to call twoParameters result in compile time
errors:

| Error                         | Reason for Error |
|-------------------------------|------------------|
| twoParameters("a");           | Needs two arguments. |
| twoParameters("1.1", "2.2");  | The string “ 2.2 ” can’t be assigned to a double . |
| twoParameters(1.1, 1.1);      | The number 1.1 can’t be assigned to a string . |
| twoParameters("a", 2.2, 3.3); | One too many arguments. |
| twoParameters;                | Generate a warning. Statement has no effect. |

Arguments associate with parameters by position—fi rst argument to the first parameter, second argument to the second parameter, and so on. For example, when twoParameters is called, the fi rst parameter is assigned the value of the fi rst argument and the second argument to the function is copied into the second parameter x. When twoParameters is called with arguments "abc" and 1.2, like this:

```C++
int twoParameters(string str, double x)
                           ↑     ↑
result4 = twoParameters ("abc", 1.2);
```

it’s as if these two assignment operations occur:

```C++
str = "abc";
x = 1.2;
```

> Whatever happens inside twoParameters now depends on the values of
> these two parameters. Th e parameters are used inside the function to
> produce the return result.

SELF-CHECK

> 3-16 What value is sent to parameter str with twoParameters("1st",
> 1.2)?
>
> 3-17 What value is sent to parameter x with twoParameters("2nd", 3.4)?
>
> Much can be deduced from a function heading when it is accompanied by
> the function pre- and postconditions. As review, here is the sin
> function heading complete with pre- and postconditions:
>
> double sin(double x) // post: Returns the sine of x radians
>
> Th e following information is ascertained:

-   What happens: returns the sine of x radians

-   Return type: double

-   Function name: sin

-   Number of arguments: one

-   Type of argument: double (or an expression convertible to double)

> Th e return results can now be determined (with the help of a
> scientifi c calculator in radian mode).

Function Call Return Result

> sin(3.1415926/2.0) 1.0 sin(1.0) 0.8421 // Approximately sin(3.1415926)
> 5.35898e-08 // close to 0.0

SELF-CHECK

> 3-18 Given the following pow function from cmath, complete with
> precondition and postcondition documentation, determine the
> information below:
>
> double pow(double x, double y) // pre: When y has a fractional part, x
> must be positive.
>
> // When y is an integer, x may be negative.
>
> // post: Returns x to the yth power

a.  return type d. class of fi rst argument

b.  function name e. class of second argument

c.  number of arguments f. class of third argument

    19. Write one proper function call to pow.

    20. Is pow(-81.0, 0.5) a valid function call? What is the return
        > value?

    21. Is pow(-10.0, 2) a valid function call? What is the return
        > value?

    22. Is pow(2, 5) a valid function call? What is the return value?

    23. Is pow(4.0, 0.5) a valid function call? What is the return
        > value?

    24. Is pow(5.0) a valid function call? What is the return value?

    25. Write a function heading that returns the fractional component
        > of the fi rst number divided by the second number. Write
        > appropriate pre- and postconditions. For example,
        > remainder(5.0, 2.0) must return 0.5 and remainder(1, 3) must
        > return 0.3333333.

### 3.3.4 A FEW FUNCTIONS FOR int, char, AND bool

> Some free functions work with the other primitive types. For example,
> the standard C++ library has free functions that can be used in an
> end-of-chapter programming project: min, max, and abs.
>
> \#include <iostream> using namespace std;
>
> int main() {
>
> cout << min(5, 7) << endl; cout << min(5.5, 7.7)
> << endl;
>
> cout << max(5, 7) << endl; cout << max(5.5, 7.7)
> << endl; cout << abs(5 - 7) << endl;
>
> return 0;
>
> }
>
> Output
>
> 5
>
> 5.5 7
>
> 7.7
>
> 2
>
> Th e min and max functions are defi ned in such a way that the same
> function name can be used with diff erent types. Th ey can take either
> two int arguments or two double arguments, but not a mix.
>
> C++ also has some methods that sound Boolean in nature because of
> names like islower and isdigit. Other functions seem as though they
> should have char parameters and return types because they convert
> characters to their upper or lower case equivalents. Consider the
> function heading for the free function islower when you
> \#include<cctype> to have access to its set of functions to
> classify and transform individual characters.
>
> int islower(int c);
>
> Th is function checks whether c is a lowercase letter. It would seem
> that the parameter should be char and the return type bool like this:
>
> bool islower(char ch); // This is not the function heading
>
> However, C++ allows an int to be assigned to a char and vice versa.
> Arithmetic operations can have a mix of integers and character
> operands.
>
> \#include <iostream> using namespace std;
>
> int main() {
>
> int anInt = 'A'; // 'A' equals 65 char aChar = 67; // 67 equals 'C'
>
> cout << "anInt: " << anInt << endl; cout <<
> "aChar: " << aChar << endl;
>
> cout << "aChar + anInt: " << (aChar + anInt) <<
> endl; cout << "anInt % aChar: " << (anInt % aChar - 2)
> << endl;
>
> return 0; }
>
> Output
>
> anInt: 65 aChar: C aChar + anInt: 132 aChar % anInt: 63

More confusion may occur because C++ considers true to be 1 and false to
be 0.

> \#include <iostream> using namespace std;
>
> int main() {
>
> bool aBool = 1; // C++ allows assignment of int to bool int
> anotherBool = false; // and a bool literal to an int cout <<
> aBool << " " << anotherBool << endl;
>
> return 0; }
>
> Output
>
> 1 0
>
> Th e output shows true prints as 1 and false as 0.
>
> If you need to classify if a char is an alphabetic letter like “A” or
> “a”, or a digit such as “9” or “3”, you can use one of the free
> functions from <cctype>. Th is program shows three more cctype
> functions:
>
> \#include <iostream>
>
> \#include <cctype> // For isalpha isblank isdigit using
> namespace std;
>
> int main() { char ch = 'a';
>
> cout << "isalpha('" << ch << "')? " <<
> isalpha(ch) << endl; ch = '?';
>
> cout << "isalpha('" << ch << "')? " <<
> isalpha(ch) << endl;
>
> ch = ' ';
>
> cout << "isblank('" << ch << "')? " <<
> isblank(ch) << endl; ch = 'N';
>
> cout << "isblank('" << ch << "')? " <<
> isblank(ch) << endl;
>
> ch = 'P'; // Oh, not zero
>
> cout << "isdigit('" << ch << "')? " <<
> isdigit(ch) << endl; ch = '5';
>
> cout << "isdigit('" << ch << "')? " <<
> isdigit(ch) << endl;
>
> return 0;
>
> }
>
> Output

isalpha('a')? 1 isalpha('?')? 0 isblank(' ')? 1 isblank('N')? 0
isdigit('P')? 0 isdigit('5')? 1

> Th e toupper and tolower functions convert a character to its
> lowercase or uppercase equivalent. Because the return type for both is
> int instead of char, the functions are cast to char with the code
> (char). Otherwise the output from this program would have been 88 97.
>
> \#include <iostream>
>
> \#include <cctype> // For toupper and tolower using namespace
> std;
>
> int main() { char lower = 't'; char upper = 'A';
>
> // (char) makes sure we the character, not the int cout <<
> (char)toupper(lower) << endl; // Cast required cout <<
> (char)tolower(upper) << endl; // to see chars
>
> return 0; }
>
> Output
>
> T a

CHAPTER SUMMARY

-   You have been confronted with a large variety of details concerning
    > the C++ programming language, expressions, program development,
    > function calls, and the types of errors that occur during
    > program development. Th is can be somewhat overwhelming at fi rst,
    > especially if you have never programmed before. However, most of
    > these details are necessary for implementation of even the
    > simplest program.

-   \#include<cmath> provides access to many mathematical and
    > trigonometric functions. \#include<cctype> provides access
    > to a set of functions that classify and transform
    > individual characters.

Exercises

-   Functions that have a return type of double can be used wherever a
    > double (or fl oating-point expression) can be used. Many of the
    > cmath functions return double.

-   Most cmath functions require one numeric argument; pow requires two.

-   Preconditions and postconditions represent a contract between the
    > function and the client code that calls the function. Th is
    > documentation and other forms of documentation are intended to
    > help someone understand what the function does.

-   Th e function heading itself provides vital usage information such
    > as the return type, the func-tion name, and the number of
    > parameters so the programmer knows how many arguments to include
    > in the call.

-   Arguments are associated with parameters by position. It doesn’t
    > matter what names are used. Th e fi rst argument is associated
    > with the fi rst parameter, the second argument with the second
    > parameter, and so on.

-   Arguments passed to parameters are like assignment statements. Th e
    > argument must be com-patible with the parameter (the same type).
    > Passing a double to an int results in loss of value.

EXERCISES

1.  Write the return result for each function call or explain the error.

  a\. pow(3.0, 2.0)    g\. fabs(-123.4)
  -------------------- ----------------------
  b\. pow(-2, 5)       h\. sqrt(-1.0)
  c\. ceil(1.001)      i\. sqrt(sqrt(16.0))
  d\. ceil(-1.2)       j\. ceil 1.1
  e\. pow(16.0, 0.5)   k\. oor()
  f\. pow(-16.0, 2)    l\. sqrt(0)

1.  Use these initializations to evaluate the expressions that follow:

> double x = 5.0; double y = 7.5;

  a\. sqrt(x - 1.0)       e\. oor(y + 0.5)
  ----------------------- ------------------
  b\. ceil(y - 0.5)       f\. pow(x, 3.0)
  c\. sqrt(y - x + 2.0)   g\. fabs(y - x)
  d\. pow(10, 2)          h\. pow(10, 3)

1.  What is the value of pow(4, pow(2, 3))?

2.  Write an algorithm that shows the range of a projectile. Th e
    > formula is

*range* = sin(2 \* *angle*) \* *velocity*^2^ / *gravity*

> where *angle* is the angle of the projectile’s takeoff (in radians),
> *velocity* is the initial velocity of the projectile (in meters per
> second), and *gravity* is acceleration due to gravity at 9.8 meters
> per second.

1.  What happens if the client program does not satisfy the
    > preconditions of a called function?

2.  What information do postconditions provide?

3.  Which of the following represent valid function headings?

  a\. int large(int a, int b)      d\. int f(a, int b)
  -------------------------------- ------------------------
  b\. double(double a, double b)   e\. double f()
  c\. int f(int a; int b;)         f\. string c(string a)

1.  Name three possible return types from a C++ function (there
    > are many).

2.  Given the following function heading with pre- and postconditions,
    > write six function calls (with diff erent arguments) that would
    > adequately test fmod and would also help explain how fmod works to
    > someone who has never seen it before.

> double fmod(double x, double y)
>
> // post: Calculates the oating-point remainder.
>
> // fmod returns the oating-point remainder of x / y.
>
> // If the value of y is 0.0, fmod returns Not a Number.
>
> // Header required: <cmath>

1.  Write the values returned from each of the six function calls in
    > your answer to the preceding question.

PROGRAMMING TIPS

1.  When calling existing functions, supply the correct number and type
    > of arguments. Th e function heading and documentation, if present,
    > provide this information. Count the number of parameters between (
    > and ). Make sure each associated argument is the same type, or
    > convertible to that type. An int can be assigned to a oat, a oat
    > to a double, an int to a long, for example.

2.  Don’t mix arguments types with min and max functions. max(2, 3.0)
    > and min(1.0, 4) are compile time errors.

3.  Th ree C++ types appear to be the same. C++ allows integer literals
    > to be treated as character literals and vice versa. Also,
    > underneath, false is 0 and true is 1. Th e reason there is no
    > output here is because aChar is storing the non-printable char
    > value of 1.

Programming Projects

> char aChar = true; // assign 1
>
> cout << ">" << aChar << "<" << endl; //
> Output: ><

1.  If you do not have the line using namespace std; you will have to
    > prepend std:: before every occurrence of the cmath function
    > you use.

> \#include <iostream> // For cout
>
> \#include <cmath> // for ceil and oor
>
> // using namespace std; Without this, prepend with std::
>
> int main() {
>
> std::cout << std::ceil(5.99) << std::endl; // 6 std::cout
> << std:: oor(5.99) << std::endl; // 5 }

**PROGRAMMING PROJECTS**

3A cmath FUNCTIONS

> Write a program that allows the user to enter any number. After an
> appropriate label, show the return value from each of the following
> functions (assume x represents the number input by the user):

1.  the square root of x

2.  x to the 2.5 power

3.  the ceiling of x

4.  the fl oor of x

5.  the absolute value of x

> Your dialogue should look like this:
>
> Enter a number for x: ***2.5*** sqrt(x) : 1.5814 pow(x, 2.5) : 6.25
> ceil(x) : 3 oor(x) : 2 fabs(x) : 2.5

3B CIRCLE

> Write a C++ program that inputs a value for the radius of a circle (r)
> from the keyboard and then outputs the diameter, circumference, and
> area of the circle. Use the pow function to compute the area.

-   *diameter* = 2 \* *radius*

-   *circumference* = *pi* \* *diameter*

-   *area* = *pi* \* *radius* ^2^

> Initialize PI as a constant object with the value of 3.14159. Your
> dialogue should look like this (*Note:* Output of fl oating-point
> numbers varies among C++ compilers, so your output might be slightly
> diff erent—especially in the number of decimal places shown for
> Circumference and Area):
>
> Enter Radius: ***1.0***
>
> Diameter: 2.0
>
> Circumference: 6.28318
>
> Area: 3.14159
>
> Run your program with radius = 1.0. Verify that your values for
> circumference and area match the preceding dialogue. After this, run
> your program with the input radii of 2.0 and 2.5 and verify that the
> output is what you expect.

3C MORE ROUNDING

> Write a program that asks the user for a number and displays that
> number rounded to zero, one, two, and three decimal places. Your
> dialogue should look like this:
>
> Enter the number to round: ***3.4567***
>
> 3.4567 rounded to 0 decimals = 3
>
> 3.4567 rounded to 1 decimal = 3.5
>
> 3.4567 rounded to 2 decimals = 3.46
>
> 3.4567 rounded to 3 decimals = 3.457

3D RANGE

> Write a program that determines the *range* of a projectile using this
> formula: *range* = sin(2 \* *angle*) \* *velocity*^2^ / *gravity*
>
> where *angle* is the angle of the projectile’s path (in radians),
> *velocity* is the initial velocity of the projectile (in meters per
> second), and *gravity* is acceleration at 9.8 meters per second (a
> constant). Th e takeoff angle must be input in degrees. Th erefore you
> must convert this angle to its radian equivalent. Th is is necessary
> because the trigonometric function sin(x) assumes the argument (x) is
> an angle expressed in radians. An angle in degrees can be converted to
> radians by multiplying the number of degrees by π/180 where π ≈
> 3.14159. For example, 45° = 45 \* 3.14159/180, or 0.7853975 radians.
> Th e velocity is presumed to be input in meters per second. Make your
> interactive dialogue look like this:
>
> Takeoff angle (in degrees)? ***45.0***
>
> Initial velocity (meters per second)? 100.0
>
> Range = 1020.41 meters

Programming Projects

3E TIME TRAVEL

> For astronauts approaching the speed of light in a spaceship, time
> passes more slowly. Also, the weight of their spaceship increases. Th
> e Lorentz factor indicates this change in time and weight depends on
> the spaceship velocity v
>
> 1 *factor* =
>
> where *v* is velocity and *c* is the speed of light (299,792,458
> meters/second). Th e *factor* can be used to compute how much
> perceived time is decreased for the astronauts and by how much the
> weight of their spaceship is increased. For example, at 74948114.5
> meters per second (1/4 the speed of light) the factor is 1.038. Time’s
> passage is reduced by the factor and the weight is increased by that
> factor.
>
> Write a program that reads the weight of the spaceship on earth
> (90,000 kilograms), the fraction of the speed of light (0.25, less
> than 1.0), and the distance to travel in light years (Alpha Centauri
> is about 4.35 light years away).

**Dialog 1:**

> Weight of spaceship on earth in kilograms? ***90000***
>
> Velocity as a fraction of the speed of light 0.0 to 1.0? ***0.25***
>
> Distance to travel in light years? ***4.35***
>
> Travel time: 4.35 light years
>
> Perceived time: 4.21187 years
>
> Earth weight of spaceship: 90000 kg

Weight of spaceship: 92951.6 kg traveling at 7.49481e+07 m/s **Dialog
2:**

> Weight of spaceship on earth in kilograms? ***90000***
>
> Velocity as a fraction of the speed of light 0.0 to 1.0? ***0.9***
>
> Distance to travel in light years? ***4.35***
>
> Travel time: 4.35 light years
>
> Perceived time: 1.89612 years
>
> Earth weight of spaceship: 90000 kg
>
> Weight of spaceship: 206474 kg tra veling at 2.69813e+08 m/s

